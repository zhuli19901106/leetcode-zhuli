# LeetCode 一句话题解 - 0001-0500

[返回目录](./algorithms-review-overview.md)

- [LeetCode 一句话题解 - 0001-0500](#leetcode-一句话题解---0001-0500)
  - [0001 - 0100](#0001---0100)
  - [0101 - 0200](#0101---0200)
  - [0201 - 0300](#0201---0300)
  - [0301 - 0400](#0301---0400)
  - [0401 - 0500](#0401---0500)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500)

## 0001 - 0100

1 Two Sum

题意：给定一个无序数组和一个值target，返回下标[i, j]使得a[i] + a[j]等于target。

难度：easy

解法：使用哈希表，记录已访问到的值x和下标i，比较当前值是否等于剩余部分target - x。

<hr>

2 Add Two Numbers

题意：使用链表表示两个十进制大数，做加法。

难度：medium

解法：第一道链表题，注意边界case，比如进位问题即可。

<hr>

3 Longest Substring Without Repeating Characters

题意：给定一个字符串，求出最长的不带重复字符的子串长度。

难度：medium

解法：第一道滑动窗口题，后面会有无穷多的类似<b>滑动窗口、子串、子数组类型</b>的问题。使用前后两个指针向前走，中间夹住部分即为滑动窗口。同时使用一个计数器（哈希表）来统计个数，确保条件成立（或者刚好不成立）。

<hr>

4 Median of Two Sorted Arrays

题意：给定两个升序数组，求出两者归并后的中位数。

难度：hard

解法：第一道经典的费脑子题，你就很难理解有的人为什么可以瞬间想到。线性解法是显然的，难点在于如何在<b>不归并</b>的情况下，使用二分方法求出中位数。第一次做我想了一个多钟头也没想清楚。

<hr>

5 Longest Palindromic Substring

题意：给定字符串，返回最长回文子串，需要返回子串。

难度：medium

解法：O(n^2)解法显然，难点在于巧妙且经典的<b>Manacher算法</b>。对于没接触过的人，凭自己琢磨出同样算法几乎不可能，实在太精妙了。

<hr>

6 Zigzag Conversion

题意：把字符串按奇怪的方式排列一下，按部就班的模拟题。

难度：medium

解法：照做即可。

<hr>

7 Reverse Integer

题意：给定一个整数，把除了符号位以外的数位倒过来。

难度：medium

解法：不用字符串，直接用除10模10的办法即可。

<hr>

8 String to Integer (atoi)

题意：实现atoi，字符串转整数的功能。

难度：medium

解法：非常非常经典的，适合用来面试的题目。不难，但考察你耐心、仔细的程度，是很好的工程师考题。

<hr>

9 Palindrome Number

题意：判断一个数是否是回文数。

难度：easy

解法：水题，负数都不是回文数。

<hr>

10 Regular Expression Matching

题意：实现正则表达式中的单字符以及.和*匹配。

难度：hard

解法：第一道parser题，编译原理是计算机科学里极其优雅且复杂，但也非常有用的一门课。写各种解析器就是一种打地基式的劳动，值得练习。正则表达式既简短又博大精深，这个是非常简化的版本。

<hr>

11 Container With Most Water

题意：给定一些高高低低的挡板从左到右排列，相邻宽度都是1。允许你选其中两个挡板，连同地板组成一个容器。请问最多能存多少水？

难度：medium

解法：这个不是著名的接雨水，是一道比较简单的题。<b>双指针</b>逐渐往中间靠拢，一边靠拢一边不断更新能存水的最大值即可。

<hr>

12 Integer to Roman

题意：古老的罗马数字，IVXLCDM。做一下数字转换，把阿拉伯翻译成罗马。

难度：medium

解法：按部就班。

<hr>

13 Roman to Integer

题意：罗马数字转阿拉伯，和前面类似。

难度：easy

解法：按部就班。

<hr>

14 Longest Common Prefix

题意：给定一组字符串，找出最长的公共前缀。

难度：easy

解法：不要考虑<b>字典树</b>之类的复杂结构，直接保留当前最长前缀，逐个比较并更新即可。

<hr>

15 3Sum

题意：给定无序数组和目标值0，返回所有<b>元素和</b>加起来等于0的三元组的下标(i, j, k)。注意不要有重复结果。

难度：medium

解法：第一道<b>变体题</b>，这也是算法题的妙处之一。以同一类问题进行<b>延伸</b>，考察人对事物的理解，以及灵活变通的能力。2Sum有好多变体，包括3sum，4sum等等。3sum可以枚举第一维，对后两维使用2sum做法。

<hr>

16 3Sum Closest

题意：类似3sum，但要求返回一个三元组(i, j, k)使得元素和<b>最接近</b>目标值target。

难度：medium

解法：3sum的变体，和之前方法完全一样，只是更新答案的比较条件有所变化而已。从判断相等改为了<b>判断更为接近</b>。

<hr>

17 Letter Combinations of a Phone Number

题意：给定老式的手机9键键盘，把一串数字翻译成所有可能的字母映射。

难度：medium

解法：按部就班，直接搜即可。

<hr>

18 4Sum

题意：2sum的变体，这次是4个元素相加等于target，要求返回所有可能的组合。

难度：medium

解法：其实还是类似，枚举的维度多了一维，剩余的维度还是按2sum做法搞定。比如你可以左右各一维进行枚举，中间两维进行2sum。方法很多，灵活掌握。

<hr>

19 Remove Nth Node From End of List

题意：给定单链表，删除倒数第n个节点并返回表头。

难度：medium

解法：传统链表题，主要考察仔细一遍过的能力，注意边界case。

<hr>

20 Valid Parentheses

题意：给定括号序列，可能包括大中小括号的混合，判断是否是一个开闭匹配的合法序列。

难度：easy

解法：入栈出栈即可。

<hr>

21 Merge Two Sorted Lists

题意：给定两个有序链表，合并为一个，返回表头。

难度：easy

解法：水题。

<hr>

22 Generate Parentheses

题意：给定长度n，请生成所有不同的，长度为n的，合法的小括号序列。

难度：medium

解法：结果个数是卡塔兰数，至于生成，用记忆化搜索+递归的方法可以完成，且效率可接受。

<hr>

23 Merge k Sorted Lists

题意：给定k个有序链表，合并为一个有序链表，返回表头。

难度：hard

解法：虽然标记为hard，其实思路并不难。保证每次取最小元素的效率即可，因此使用<b>最小堆</b>，不断把k个表头往里放并总是取出当前值<b>最小的表头</b>。

<hr>

24 Swap Nodes in Pairs

题意：给定链表，按每两个元素一对，进行交换。返回表头。

难度：medium

解法：按部就班，注意边界case即可。

<hr>

25 Reverse Nodes in k-Group

题意：和上面的交换两个节点类似，这次是每k个节点一组进行反转。返回表头。

难度：hard

解法：按部就班，多多注意边界case。

<hr>

26 Remove Duplicates from Sorted Array

题意：给定有序数组，<b>去重</b>并把剩余的元素依次往前放，返回剩余元素个数。

难度：easy

解法：解法比讲清楚题意还简单的一道题。

<hr>

27 Remove Element

题意：给定数组，去掉其中所有值为val的元素，并把剩余元素依次往前放，返回剩余元素个数。

难度：easy

解法：水题。

<hr>

28 Find the Index of the First Occurrence in a String

题意：实现strstr，即字符串匹配的功能。

难度：easy

解法：<b>字符串匹配</b>是最最最经典的问题之一，有Sunday、BM、KMP还有多模式匹配的AC自动机等神奇算法。这个题要求比较低，所以暴力匹配也能接受。

<hr>

29 Divide Two Integers

题意：给定两个整数，返回整除结果，但不能用 * / %运算。

难度：medium

解法：很有意思的一题，<b>绑手绑脚还要秀功夫</b>的类型。我专门看了一眼自己当年的代码，一分钟还没理解到底在干嘛。又看了一遍，发现是用类似<b>位运算和除法器</b>（学过数字电路的话肯定就懂了）的思路去做除法。

<hr>

30 Substring with Concatenation of All Words

题意：给定一个长字符串s，和一组<b>长度相同</b>的单词words。找出所有s的子串，使得这些子串恰好等于words中的<b>全部单词</b>以<b>任意顺序</b>拼接起来。返回这些子串的<b>起始下标</b>。

难度：hard

解法：确实比较hard，放下现在算是medium hard。从数据规模，不允许暴力搜索。考虑用滑动窗口+统计出现字符串出现次数的方法。当年用cpp写，还设计了个非常蹩脚的字符串哈希函数，导致代码读起来很费劲。如果用py重写，两个Counter对象就搞定了。我看了大概五分钟才看明白当年的代码想表达什么。

<hr>

31 Next Permutation

题意：给定一个<b>无序且可能有重复元素</b>的数组，返回按<b>字典序</b>的下一个排列。要求就地完成，不复制数组。

难度：medium

解法：总归是个O(n)时间的操作，因为挪动数组元素是线性时间的。

<hr>

32 Longest Valid Parentheses

题意：给定一个小括号序列，返回其中能找到的最长合法序列的长度。

难度：hard

解法：难度是hard，规模上不允许O(n^2)的直白解法。既然是<b>括号匹配</b>，必然想到用栈。但一个栈可以作为数组用，却无法给你快速查找某个值的功能。因此换了一个比较巧的做法，用一个<b>计数</b>表示栈大小，同时用一个<b>哈希表</b>来存放内容，这样就能快速查找并更新内容了。所以这也<b>不能算是个栈</b>，但思路还是用了栈。

<hr>

33 Search in Rotated Sorted Array

题意：一个有序数组经过了（也可能没有）循环移位，请找出target值所在的下标。

难度：medium

解法：和那个“两个有序数组求中位数”一样，属于经典的<b>脑洞题</b>。直白解法很直白，但最高效解法你可能就是想不出来，这种类型的坑货题在LeetCode上还有十几题，散落在各处。二分做法反正我第一次费了很大劲才想出来，<b>自愧不如</b>。我也很难用一句话描述清楚怎么<b>独立想出来这种鬼点子</b>，因为我<b>做不到</b>。

<hr>

34 Find First and Last Position of Element in Sorted Array

题意：给定有序但可能有重复元素的数组，找出某个值target的起始和终止位置。

难度：medium

解法：二分查找，其实就是bisect_left和bisect_right的定义。

<hr>

35 Search Insert Position

题意：给定有序数组，要插入一个新值，请找出应该插入的位置。

难度：easy

解法：二分查找。

<hr>

36 Valid Sudoku

题意：三阶数独，9x9的那种。这次只需要检查一个填法是否合法而已。

难度：medium

解法：按数独的规则记录和检查即可。每行1-9，每列1-9，每个3x3小方格1-9。

<hr>

37 Sudoku Solver

题意：三阶数独，9x9的那种。这次要你用算法来填了。

难度：hard

解法：倒是算个hard，不过按部就班地使用<b>搜索+回溯</b>的方法，其实也不算难。如果一定要求用神奇的<b>Dancing Links算法</b>去做，我还是放弃吧。其实这辈子估计也没打算学会这个算法。

<hr>

38 Count and Say

题意：给定初始字符串“1”，使用游程编码（RLE）的方式不断把这个字符串“读出来”，并用读的结果替换原字符串。如此重复n-1次，返回最终结果。

难度：medium

解法：按部就班，模拟题。

<hr>

39 Combination Sum

题意：给定一个无重复元素的候选集合，找出所有加起来和为target的不同组合，返回全部组合。

难度：medium

解法：非常经典的<b>搜索题</b>，注意设计好递归函数，处理边界case即可。第一次写这种递归代码容易晕，写多了就能找出比较简洁的方式。注意适当<b>剪枝</b>，提高效率。

<hr>

40 Combination Sum II

题意：组合求和的变体，候选集合是可以有重复元素的。

难度：medium

解法：思路完全一样，就是改用一个map计数器来代替set，因为可以有重复值，需要统计每个值当前用了多少次。

<hr>

41 First Missing Positive

题意：给定一个长度为n的无序数组，请找出<b>不在数组中的</b>最小的<b>正整数</b>。要求不能用额外数组或存储结构做记录。

难度：hard

解法：这好像是一道近乎脑筋急转弯的<b>小聪明式的算法题</b>，要求做一件很直白的事，但不能用额外空间。个人非常反感这类<b>“专考聪明人”</b>的题。你得不到任何训练，且每一个这种题都<b>独一无二</b>，没什么规律可言。这题想要省空间，其实就是<b>直接把原数组当成一个bool数组用</b>，在上面叠一层True or False标记，来记录1-n是否都出现过了。如果你做不出来或者想不到，<b>不用有任何失望</b>。这不代表你不聪明，只代表你此时此刻在这道题上不聪明，和过去、和未来毫无关系。

<hr>

42 Trapping Rain Water

题意：给定一个高高低低的一维地形，雨水可以存在各种地势低洼处，给定无穷多的雨量，问总共能存下多少水。

难度：hard

解法：<b>接雨水</b>，这个是LeetCode名梗之一了，二维接雨水也被视为算法题里嘲讽功能最强的题目之一。这种题目虽然很精妙，但也因为其费脑、解法五花八门且实在没什么鸟用，而被视为浪费脑细胞的最佳途径。一维接雨水其实还好，可以视为传统的O(n) DP题。这个hard当年确实费了很多人的脑细胞，而且也很经典。<b>二维接雨水</b>还要离谱的多。

<hr>

43 Multiply Strings

题意：大数乘法，但是用字符串表示的大数。

难度：medium

解法：按部就班，不过对数据格式做一下转换，注意别出错即可。

<hr>

44 Wildcard Matching

题意：通配符匹配，和正则匹配类似，但要求实现?和*匹配功能。

难度：hard

解法：<b>比正则匹配简单</b>，但也算名副其实的hard问题。难度主要在把事情想清楚，代码其实很短。

<hr>

45 Jump Game II

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问最远能到哪儿。

难度：medium

解法：跳数组系列问题中比较简单的一题，这系列有好多个变体。只要<b>每前进一步</b>，不断更新<b>当前能跳到的最远位置</b>即可。

<hr>

46 Permutations

题意：给定无重复元素的数组，返回它的所有不同排列方式。

难度：medium

解法：最直接的思路其实是先排序，然后不断使用<b>next permutation</b>找到下一个排列，直到<b>找不到（也就是变成倒序了）为止</b>。另一种思路就是搜索+记录排列的方式。前者更直观，代码也更好写。

<hr>

47 Permutations II

题意：和上题一样，返回所有排列，但这次数组可能有重复元素。

难度：medium

解法：我还是选择next permutation，这个无所谓重复元素。

<hr>

48 Rotate Image

题意：给定一个n x n矩阵，顺时针旋转90度。

难度：medium

解法：按部就班，注意奇偶情况的处理。

<hr>

49 Group Anagrams

题意：给定一组字符串，把互为anagram的词归到一个组里。

难度：medium

解法：<b>anagram</b>没有中文叫法，只能叫“同字母异序词”。对anagram的处理就是<b>排序之后统一比较</b>，相等就是anagram。

<hr>

50 Pow(x, n)

题意：给定整数x和n，都可以是负数，求x的n次方。

难度：medium

解法：快速幂，二分法。

<hr>

51 N-Queens

题意：N皇后问题，在n x n棋盘上放置n个皇后，不能存在同行、同列、同对角线、同反对角线的情况。返回所有摆法。

难度：hard

解法：这是算法和数据结构课的教科书例子了，可以说是<b>搜索+回溯</b>的教材。

<hr>

52 N-Queens II

题意：N皇后问题，并不能算变体。这次只需要返回解的个数。

难度：hard

解法：搜索+回溯。

<hr>

53 Maximum Subarray

题意：给定数组，求出其中最大的子数组和，返回和。

难度：medium

解法：<b>贪心策略</b>的最经典例子之一。累加并更新最大值，如果累加和为负数，就直接放弃，重置为0。

<hr>

54 Spiral Matrix

题意：给定m x n的矩阵，按照顺时针螺旋方式从外向内遍历。

难度：medium

解法：模拟题，逐字逐句照做即可。

<hr>

55 Jump Game

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问能不能跳到最后一格。

难度：medium

解法：思路和Jump Game II完全一样，为什么这个的题号反而在后面？

<hr>

56 Merge Intervals

题意：给定一些用[x, y]表示的区间，将其进行合并，使得结果中的区间互不重叠。

难度：medium

解法：按<b>先首后尾</b>的顺序进行<b>排序</b>，然后逐个进行合并处理。python的<b>元组默认顺序</b>是个很有用的特性，可以处理很多这类问题。

<hr>

57 Insert Interval

题意：给定一组有序且互不重叠的区间，插入一个新区间[x, y]并进行适当的合并，使得结果依然有序且互不重叠。

难度：medium

解法：和上面的合并区间同一思路，二分找到插入位置，然后逐个合并，直到无需合并为止。

<hr>

58 Length of Last Word

题意：给定一个句子，找出最后一个词的长度。

难度：easy

解法：水题。

<hr>

59 Spiral Matrix II

题意：给定n x n的方阵，按照顺时针由外向内的方式，螺旋遍历这个矩阵，并把1到n^2依次填入每个每个位置。返回结果方阵。

难度：medium

解法：和前面的螺旋遍历一样，模拟题照做即可。

<hr>

60 Permutation Sequence

题意：给定整数n，{1, 2, ..., n}可以组成n!个不同排列。给定整数k，请求出<b>字典序排第k</b>的排列。

难度：hard

解法：<b>组合数学题</b>。可以按<b>子问题</b>逐个考虑。当第1位固定，剩下的n-1位则有(n-1)!种不同排列。逐个往下减，最后一位减完了，整个排列就确定了。

<hr>

61 Rotate List

题意：对一个单链表进行循环右移k次，返回表头。

难度：medium

解法：对k的一些特殊情况处理一下，剩下小心完成即可。可以通过<b>反转数组</b>的方式实现<b>循环移位</b>。[a...a b...b]，先反a，再反b，最后反全部，结果就等效于循环移位。

<hr>

62 Unique Paths

题意：给点m x n矩阵，你从(0, 0)出发，每次只允许向右或者向下，请问到达(m - 1, n - 1)有多少种方法。

难度：medium

解法：其实是个<b>纯数学题</b>，可以用<b>组合公式</b>直接求。但依然可以用土办法，开个二维数组进行累加。组合公式多数人不一定记得住，或者现场推也推不清楚，不必强求。这个应该就是著名的<b>杨辉三角</b>了，二项式定理。

<hr>

63 Unique Paths II

题意：Unique Paths的变体，但这次矩阵中存在无法通过的障碍格子。求到达(m - 1, n - 1)的路径个数。

难度：medium

解法：这次不能套数学公式了，还是用之前相同的办法，<b>二维数组</b>统计个数。

<hr>

64 Minimum Path Sum

题意：给定一个m x n矩阵，每个格子有一个值。从(0, 0)出发，每步只允许向右或向下，到达(m - 1, n - 1)。求可能累加得到的最小路径和。

难度：medium

解法：非常典型且直白的DP题。既然只能<b>右和下</b>，那就在<b>左和上</b>里找一个较小的值即可，这样最后得到的就是最小的路径和。

<hr>

65 Valid Number

题意：给定字符串，判断是否是一个有效的整数、小数或者科学计数法表示的数。

难度：hard

解法：难度全在于是否<b>够仔细，够严谨，够耐心</b>。能一次过这种题的，反正我挺难想象的。<b>边界case</b>多的出奇。

<hr>

66 Plus One

题意：给定用数组表示的一个大数，对其执行+1操作。

难度：easy

解法：没有难度，就是注意进位的情况。

<hr>

67 Add Binary

题意：两个字符串表示的大数相加，二进制。

难度：easy

解法：十进制，二进制，没什么大区别。

<hr>

68 Text Justification

题意：给定一系列单词，要求在<b>保持单词顺序</b>的情况下，按照一个最大宽度进行逐行排版。最终得到的<b>每行总宽度相同</b>，且每行内的单词间空格要尽可能均匀。这个其实就是我们常见的<b>“分散对齐”</b>功能。

难度：hard

解法：难度主要在于要求比较多，费事，实现每一步倒是不难。小心完成即可。

<hr>

69 Sqrt(x)

题意：给定非负整数，求它的平方根，结果<b>向下取整</b>。

难度：easy

解法：二分查找。

<hr>

70 Climbing Stairs

题意：从0级台阶开始，每次允许向上1级或者2级，求到达第n级台阶的方法有多少种。

难度：easy

解法：Fibonacci数列。

<hr>

71 Simplify Path

题意：给定一个“/”分割的文件路径，可能存在“.”和“..”这样的相对路径。求简化后的<b>绝对路径</b>。

难度：medium

解法：解析路径，用栈处理一下，然后拼回完整路径即可。

<hr>

72 Edit Distance

题意：给定两个字符串s和t，求其最短编辑距离。一次编辑包括<b>增、删或改一个字符</b>。

难度：medium

解法：教科书里讲<b>动态规划</b>的经典例子，DP。编辑距离还有个专有名词，叫“Levenshtein distance”。

<hr>

73 Set Matrix Zeroes

题意：给定一个01矩阵，如果某个元素值为0，就把它对应的整行和整列都设为0。要求对所有元素同时做这个操作，且<b>就地完成</b>，不使用额外的矩阵。

难度：medium

解法：挺巧妙的一题，难度当然是<b>就地完成</b>了，否则直接记录一下再处理就很简单。使用第0行和第0列作为标记，再单独用两个变量r0和c0记录0行和0列本身是否有0，这样就<b>有地方做记录</b>了。起码没要求我<b>一个变量也不能用</b>，对吧？

<hr>

74 Search a 2D Matrix

题意：给定一个m x n矩阵，每行向右都是递增的，且下一行的第一个元素都大于上一行末尾。请设计一个高效算法在其中查找目标值是否存在。

难度：medium

解法：注意，这个并不是<b>Young tableau</b>，只是一个有序的一维数组被变形成了二维。把它还原成一维，进行常规的二分查找即可。

<hr>

75 Sort Colors

题意：给定一个包含红白蓝三色的数组，要求<b>就地进行排序</b>，得到红、白、蓝顺序的结果。

难度：medium

解法：既然只有三种颜色，那就把红、蓝<b>往两边放</b>好了，以<b>交换</b>的方式实现。我记得很清楚，当时很讨厌这种<b>“自废武功”</b>式的题目，一边这也不让那也不让，一边又要你做这做那。

<hr>

76 Minimum Window Substring

题意：给定长串s和短串t，请找出<b>长度最短</b>，但<b>包含了t中所有字母</b>的s的子串。t可能有重复字母，所以要在个数上包含。

难度：hard

解法：放在现在是很标准的medium了，<b>滑动窗口题</b>。甚至题目里都提示了window。<b>滑动、计数、判断，再滑动</b>。这会成为一个标准的统计手法，后面经常用到。

<hr>

77 Combinations

题意：给定正整数n和k，返回从1-n中选k个数的所有不同<b>组合</b>。

难度：medium

解法：搜索即可。

<hr>

78 Subsets

题意：给定一个无重复元素的数组（其实就是集合），返回它的所有子集（其实就是幂集）。

难度：medium。

解法：搜索即可。

<hr>

79 Word Search

题意：给定一个m x n矩阵，每一格有一个字母。给定一个目标字符串word，从任意位置出发，上下左右走不重复的格子，对应序列是否能组成word？

难度：medium

解法：<b>搜索+回溯</b>，成功就结束，失败就回溯。

<hr>

80 Remove Duplicates from Sorted Array II

题意：有序数组就地去重，但是重复元素<b>至多保留两个</b>，而不是一个。

难度：medium

解法：大同小异，往前挪的时候，留两个位置即可。

<hr>

81 Search in Rotated Sorted Array II

题意：和之前Search in Rotated Sorted Array类似，一个有序数组经过了（也可能没有）循环移位，但这次数组可能有<b>重复元素</b>。在其中查找一个目标值target。

难度：medium

解法：依然二分，但因为重复值的存在，可能需要做一些+1、-1的O(n)操作，因此<b>最坏时间是线性</b>，最优时间是对数。

<hr>

82 Remove Duplicates from Sorted List II

题意：给定有序单链表，把存在重复值的对应节点<b>全部去掉</b>，只留下无重复值的节点。

难度：medium

解法：注意读题，<b>不是去重</b>，而是有重复的直接全删了。

<hr>

83 Remove Duplicates from Sorted List

题意：给定有序单链表，去重并返回表头。

难度：easy

解法：这个是去重，标准操作。

<hr>

84 Largest Rectangle in Histogram

题意：给定一个高高低低的直方图，每格的宽度是1，求在其中能画出的<b>最大的矩形面积</b>是多少。

难度：hard

解法：很经典也很著名的一道面试题，DP解决。主要思路就是对每个位置，看看<b>往左、往右</b>能找到多少个<b>连续的，高于它的位置</b>。因为必须<b>更高才能继续扩展这个矩形</b>。算好左右宽度之后，乘以高就是<b>面积</b>。

<hr>

85 Maximal Rectangle

题意：给定一个01矩阵，允许在其中<b>框一个矩形</b>，要求其中<b>所有元素都是1</b>。求这个矩形框的最大面积。

难度：hard

解法：相当巧妙的一题，其实就是上一题，<b>直方图矩形面积</b>的变体。我当时花了10多分钟才想到。每往下扫一行，直方图的数据就更新一次。当然，<b>遇到0的时候</b>，直方图的对应列就归零了。

<hr>

86 Partition List

题意：给定一个链表和一个值x，对节点进行划分，使得小于x的元素在前，大于等于x的在后。两组节点的<b>内部顺序</b>要和之前保持一样。

难度：medium

解法：题目已经暗示得很明显了，<b>按顺序</b>一个个分类，两条链表再拼起来即可。

<hr>

87 Scramble String

题意：给定一个长度大于1的字符串s，可以随机选取一个位置切分为两个子串x + y，并将两串交换，变为s' = y + x，称为一次“乱序”。乱序操作可以<b>对子串递归执行</b>。当对一个字符串s递归执行<b>任意次乱序操作</b>后，能否将其变为字符串t？

难度：hard

解法：第一念头当然是DP或者搜索，但既然是hard难度，一定要在效率上有所考虑。其实DP还是搜索没有本质区别，都是对<b>子问题</b>的表达方法。搜索如果效率不达标，也需要<b>记忆化</b>的办法去提高效率。最后我还是选了DP，对s和t的不同位置的<b>同长度子串</b>进行匹配。循环层数比较多，注意不要搞晕了。

<hr>

88 Merge Sorted Array

题意：有序数组归并，但这次<b>数组1</b>中留了足够的位置给你。

难度：easy

解法：水题。

<hr>

89 Gray Code

题意：格雷码，一种很神奇的编码方式。任意相邻的两个代码（包括第一和最后）之间都只有1位不同。给定长度n，请生成一种合法的n位格雷码编码。

难度：medium

解法：<b>递归</b>的完美例子，你用脑子硬想格雷码，肯定想不明白。但想一想n和n-1之间的关系，代码就很容易写出来。递归是一种非常<b>反直觉</b>的思维方式，但又极其优雅，很能体现数学的魅力。你把n-1位格雷码反转过来，开头都加个“1”，再拼起来不就是n位格雷码。

<hr>

90 Subsets II

题意：还是求集合的幂集，但这次元素可能有重复，相当于数学上的multiset。

难度：medium

解法：依然是搜索，这次有重复元素，改用map代替set来进行计数。

<hr>

91 Decode Ways

题意：按照1-26对应A-Z的编码方式，给定一个<b>数字串</b>，请求出有多少种不同的翻译方式来<b>翻译成字母</b>。

难度：medium

解法：线性DP，无序使用数组，只记录最近两三个位置的结果即可。

<hr>

92 Reverse Linked List II

题意：给定单链表和left、right位置，将[left, right]位置内的部分链表反转，并返回表头。

难度：medium

解法：注意处理各种<b>边界case</b>即可，只求仔细。

<hr>

93 Restore IP Addresses

题意：给定一个数字串，允许在其中插入“.”，请返回能得到的所有<b>有效IP地址</b>。

难度：medium

解法：一边搜一边插入点，检查有效性即可。

<hr>

94 Binary Tree Inorder Traversal

题意：给定二叉树，求中序遍历。

难度：easy

解法：这是必知必会了，<b>前中后序遍历</b>。用栈来<b>模拟递归</b>，也属于不算很难的东西。但我记得还有个非常诡异且偏难怪的<b>O(1)空间遍历</b>，那个我至今也没学会。好像和教材里讲过的“线索树”有关。

<hr>

95 Unique Binary Search Trees II

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。返回所有树。

难度：medium

解法：其实这和括号匹配一样，都是卡塔兰数的例子。搜索记录即可，这个规模是<b>阶乘级</b>的，n不可能给到很大，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

96 Unique Binary Search Trees

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。只需要返回个数。

难度：medium

解法：就是<b>卡塔兰数</b>，标准的，原封不动的，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

97 Interleaving String

题意：给定字符串s1、s2、s3，判断s3是否可以由s1、s2的字符<b>按次序穿插组成</b>。

难度：medium

解法：穿插，也就是把s2的字符<b>依次分散插入</b>s1，或者s1分散插入s2（同理）。使用两个指针逐个判断s3的当前字符是否和其中一方匹配，一步步往前。但是，<b>这个思路是错的</b>。虽然很直观，但行不通。需要用DP解决，贪心策略不对。从这点看，这题其实挺hard，属于medium里比较坑人的。

<hr>

98 Validate Binary Search Tree

题意：给定一个二叉树，判断它是不是一个二叉搜索树。

难度：medium

解法：按定义来即可，对<b>每个位置</b>，判断<b>左子树最右</b>和<b>右子树最左</b>是不是分别小于、大于根节点。

<hr>

99 Recover Binary Search Tree

题意：给定一个二叉搜索树，有两个节点的位置被交换了，请在不改变节点指向的情况下，找到两个值并换回来。

难度：medium

解法：挺巧妙且有点难的一题。利用<b>BST的中序遍历结果有序</b>这个特点，如果乱序了，这个地方一定有节点被换了。记录下<b>发现乱序</b>的位置，做交换。要注意两个点<b>恰好相邻</b>和<b>不相邻</b>两种情况

<hr>

100 Same Tree

题意：给定两个二叉树，判断它们是否完全相同。

难度：easy

解法：递归比较即可。

## 0101 - 0200

101 Symmetric Tree

题意：给定一个二叉树，判断是不是左右镜像对称。

难度：easy

解法：从根节点开始，左右同时往下走，按对应位置递归检查即可。

<hr>

102 Binary Tree Level Order Traversal

题意：二叉树层序遍历。

难度：medium

解法：我忘了是不是叫“层序遍历”，总之就是一层层横着扫，使用<b>队列</b>。

<hr>

103 Binary Tree Zigzag Level Order Traversal

题意：还是层序遍历，但是这次按照左右、右左、左右这样交替进行。

难度：medium

解法：可以层序遍历之后，把结果反转一下。

<hr>

104 Maximum Depth of Binary Tree

题意：求二叉树的最大深度。

难度：easy

解法：属于树的基本操作之一，求长度、求深度。递归统计即可。

<hr>

105 Construct Binary Tree from Preorder and Inorder Traversal

题意：给定二叉树的前序和中序遍历结果，重建这棵树。

难度：medium

解法：教科书级的题目，有<b>前中</b>或者<b>中后</b>，就可以重建整棵树，但是<b>前后</b>不行。想一想怎么逐渐往下递归，并找到<b>当前哪个点是根节点</b>。如果值唯一的话，还可以用<b>哈希表</b>把<b>值的对应下标</b>记下来，方便快速找到。

<hr>

106 Construct Binary Tree from Inorder and Postorder Traversal

题意：同上，通过中序和后序遍历结果，重建二叉树。

难度：medium

解法：同上，就是前序和后序的位置不同而已，关键其实都在于用好<b>中序遍历</b>。

<hr>

107 Binary Tree Level Order Traversal II

题意：还是层序遍历，但这次要求从下到上。

难度：medium

解法：把层序遍历的结果上下反转一下即可。

<hr>

108 Convert Sorted Array to Binary Search Tree

题意：给定有序无重复数组，将其转换成一个二叉搜索树。

难度：easy

解法：二叉搜索树的中序遍历是有序的。为了使树的<b>左右子树尽可能平衡</b>，递归重建。每次<b>左右都取一半</b>，中间是根节点。

<hr>

109 Convert Sorted List to Binary Search Tree

题意：这次是有序链表，转换成一个二叉搜索树。

难度：medium

解法：思路完全一样，不过你无法直接取链表的下标，所以要小心往前走到对应位置。链表题考察的都是<b>“仔细”</b>二字。递归时记得记录链表片段的<b>头尾节点</b>。

<hr>

110 Balanced Binary Tree

题意：给定二叉树，检查高度是否平衡。

难度：easy

解法：平衡的定义是，<b>每个节点</b>左右子树的<b>高度差不大于1</b>。按定义递归检查即可。

<hr>

111 Minimum Depth of Binary Tree

题意：给定二叉树，以根节点深度为1，求最小的叶节点深度。

难度：easy

解法：和节点值毫无关系，递归搜索即可。

<hr>

112 Path Sum

题意：给定二叉树和目标值target，判断是否有一条从根到叶的路径，<b>节点值之和</b>等于target。

难度：easy

解法：水题。

<hr>

113 Path Sum II

题意：给定二叉树和目标值target，找出所有<b>节点值之和</b>等于target的路径，并返回。

难度：medium

解法：递归搜索，判断并<b>收集结果</b>。完成后全部返回。

<hr>

114 Flatten Binary Tree to Linked List

题意：给定二叉树，请将其做一下变换，按<b>右指针</b>连接，变成一个链表。要求链表的值恰好和二叉树的<b>前序遍历</b>一样。

难度：medium

解法：一道有点脑洞的题，后面还有好几个这种<b>链表魔术题</b>。肯定是递归，对吧？前序的做法是<b>“根左右”</b>，那就递归处理好，然后按根->左->右把<b>递归结果</b>拼起来。

<hr>

115 Distinct Subsequences

题意：给定字符串s和t，从s中取出子序列，使其等于t。请问有多少种不同取法。

难度：hard

解法：既然是问<b>多少种不同的取法</b>，而不是要<b>找一个</b>，或者判断<b>能不能</b>，那应该是DP了。有这个思路了，设计DP关系式应该不难。凡是这种只关心<b>“上一步”</b>的DP，在空间上都是可以优化的，滚动数组。

<hr>

116 Populating Next Right Pointers in Each Node

题意：给定一个<b>满二叉树</b>（不是完全二叉树，是满），每个节点有一个next指针，将其指向它<b>层序遍历</b>的<b>右边最近</b>的节点。但是不准用层序遍历。

难度：medium

解法：<b>脑洞题</b>，而且脑洞还不小。其实不论是什么树，用<b>层序遍历</b>，相邻的两个节点如果在同一层，肯定要连上一个next指针的。这种思路<b>直观且易实现</b>。但这题就是给你出个脑洞，要求O(1)空间。这个也是满二叉树这种丰满结构才有的特点，左右挨得非常近。我没法解释那个代码是怎么设计出来的，当年<b>我应该没有独立想出来</b>。

<hr>

117 Populating Next Right Pointers in Each Node II

题意：同上116，这次不是满二叉树了，任意二叉树。还是不准用层序遍历。

难度：medium

解法：怎么说呢，用递归思路做其实也不算难，但还是有脑洞的。但是递归显然不符合O(1)空间的要求，递归最起码栈空间是O(h)对吧，h是树的高度。我不太理解这种<b>天才题</b>到达有什么意义，特定场景下如果实在没内存了，一定要做这些<b>走钢丝</b>的事吗？

<hr>

118 Pascal's Triangle

题意：帕斯卡三角，中国叫<b>杨辉三角</b>。给定整数n，输出1-n行杨辉三角。

难度：easy

解法：水题。

<hr>

119 Pascal's Triangle II

题意：同118，这次只输出第n行。

难度：easy

解法：水题。

<hr>

120 Triangle

题意：给定一个三角形的二维数组，每行比上一行多一个元素。从顶部往下左右走，求<b>累加和的最小值</b>。

难度：medium

解法：常规DP题，在<b>上一步的两种路里</b>，找更小的即可。

<hr>

121 Best Time to Buy and Sell Stock

题意：给定一个数组，表示一只股票的每日价格。允许你选一天买入，另一天卖出，<b>做一次买卖交易</b>，求出最大的盈利。如果无法盈利则不交易。

难度：easy

解法：<b>炒股系列</b>，应该总共四五题。总是记录<b>当前的最低价</b>即可。

<hr>

122 Best Time to Buy and Sell Stock II

题意：还是炒股。这期间你可以<b>多次买卖</b>，但不能<b>同一时间多次买入或者持有</b>，必须卖出才能再买。求最大盈利。

难度：medium

解法：其实比121更简单，<b>只要涨价就买</b>，第二天就卖出。属实是<b>短线之神</b>了。

<hr>

123 Best Time to Buy and Sell Stock III

题意：还是炒股。这次你<b>至多</b>可以进行两次买卖，还是不能在同一时间内多次买入持有。求最大盈利。

难度：hard

解法：比121稍微难一点，并不能算真的hard。既然至多2次，那就在0次、1次的基础上，再处理2次的情况。DP解决，后面还会遇到<b>至多k次</b>的情况，还是DP。

<hr>

124 Binary Tree Maximum Path Sum

题意：给定一个二叉树，每个节点有一个值。允许从任意点出发，到达任意点。求所得路径和的最大值。

难度：hard

解法：早年的hard，现在属于中规中矩的medium了。这题如果把树转换成无向图，再去搜索，那就搞复杂了。其实思路就是递归向下，走<b>左右两条路拼起来</b>。另一种情况就是从<b>当前根节点</b>直接出发走一条路。注意，是<b>“当前根节点”</b>，不是整棵树的根节点。

<hr>

125 Valid Palindrome

题意：给定字符串，只保留字母并转换为小写之后，判断是不是回文串。

难度：easy

解法：水题。

<hr>

126 Word Ladder II

题意：给定一个起始词，一个终止词，和一个<b>单词长度都相同</b>的词表。从起始词开始，每次允许<b>更改一个字母</b>，逐步将其变为终止词，并要求每步<b>变换后的词都要在词表中</b>。请给出<b>最短的</b>变换方法，如果不存在则返回空。

难度：hard

解法：这是个图。对，很多<b>图论题</b>的关键在于能<b>看到图</b>。因为每次只能变一个字母，对词表里相差一个字母的情况，可以<b>建一条双向边</b>，这图就出来了。以图为根据，从起点开始执行<b>BFS</b>，到达终点为止。因为求的是<b>最短的</b>，每条边<b>权重都是1</b>，BFS正合适。奇怪的是，我当年代码写得巨长，还用了DFS，搞不懂。

<hr>

127 Word Ladder

题意：和126完全相同，这次只需要返回变换序列的长度。

难度：hard

解法：很奇怪为什么简化版的放在后面，更难的反而在前。同上。

<hr>

128 Longest Consecutive Sequence

题意：给定一个无序数组，求出其中的最长连续序列的长度。最长连续序列指的是在<b>排序之后</b>可以构成一个<b>公差为1的等差数列</b>。

难度：medium

解法：当然，你不能排序，要求在O(n)时间完成，因此这个挺有难度的。为了保证效率，我用了个区间延伸、合并的方法。用<b>两个哈希表</b>来记录区间的<b>首尾位置</b>，每增加一个元素，就检查<b>哪个区间可以延伸，哪两个区间可以合并</b>。这样全处理完后，找到最长的区间即可。思路不算很麻烦，但代码写得还挺麻烦。<b>确实有难度</b>。我想不出<b>更简洁或者更诡异</b>的方法了。很多人都说这题应该是hard，我同意。

<hr>

129 Sum Root to Leaf Numbers

题意：一个二叉树，每个节点有一个0-9的数字。从根到叶的路径可以代表一个<b>大数</b>。请求出所有<b>这些路径构成的数</b>的和。

难度：medium

解法：递归即可。

<hr>

130 Surrounded Regions

题意：给定一个m x n矩阵，每个格子是X或者O，和上下左右四个方向相邻。对于一个连同的O区域，如果周围全被X格包围，则该区域全部变成X。处在边界的O不算被包围。<b>就地进行</b>以上变换。

难度：medium

解法：<b>搜索</b>，不论深度还是广度都行。需要注意，搜完之后要判断<b>全包围</b>才能<b>统一处理</b>。还有一种做法，就是可以先把<b>和边界相邻的区域</b>设为另一值（以便保护起来），这样就不受包围操作的影响了。

<hr>

131 Palindrome Partitioning

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回所有划分方式。

难度：medium

解法：长度很短，可以暴力搜索。当然，提前把判断回文串的工作做好也行。

<hr>

132 Palindrome Partitioning II

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回<b>最少的划分次数</b>。

难度：hard

解法：比131难一点，不过也不算很难。很明显的DP思路，O(n^2)解决。

<hr>

133 Clone Graph

题意：给定一个<b>单连通</b>的无向图，请设计算法将其复制一份，并返回<b>和输入同一位置</b>的节点。

难度：medium

解法：这个其实更多是帮助初学者了解基础知识，比如<b>深拷贝浅拷贝</b>。当然，最标准的思路，要克隆一个东西，还是知道它的<b>序列化、反序列化</b>方式最靠得住。搞一些<b>奇奇怪怪的指针操作</b>，那就是纯属无事生非了。我记得我就是<b>用哈希做了一对一映射</b>，按部就班做的。

<hr>

134 Gas Station

题意：给定一个长度为n的<b>环形路</b>，每个加油站前往下一站会有一定的油耗cost[i]。假定你的油箱不限量，每个加油站有一定的油量gas[i]提供。如果你可以从任一站，以0油量出发（起步可以加油），要求<b>能走完一整圈</b>，请返回<b>选定的出发站</b>。

难度：medium

解法：处理<b>循环数组</b>有个通用的技巧，就是<b>把同一数组拼两份</b>，来个a + a，这样就<b>不怕下标越界</b>了。从任意点出发，你始终关心的是<b>当前油量是否变成负的</b>。是的话，<b>当前这段就可以放弃</b>，因为<b>你油不够</b>了。这个题和<b>最大子数组和</b>有点像，都是略有脑洞，但不过分的程度。

<hr>

135 Candy

题意：给定n个小朋友和一些糖果。每个小朋友有个<b>排位值ratings</b>。如果你至少每个小朋友要给1颗糖，且如果一个小朋友的<b>排位比相邻小朋友高</b>，糖的个数也<b>对应要更多</b>。请问最少需要准备多少糖，才能满足分配要求。

难度：hard

解法：确实挺难的，读完题目大概5分钟毫无想法的那种难度。再想5分钟，判断是不是可以<b>贪心</b>，结论是可以。按照全部1颗起步，遇到排位有高低的情况，就给高的+1。<b>从左到右，从右到左。</b>注意，+1不是加一颗，而是要<b>比旁边的多一颗</b>。

<hr>

136 Single Number

题意：给定一个数组，出了一个数之外，其他数都出现了两次。找出这个单独的数。

难度：easy

解法：好像是《编程珠玑》还是《编程之美》上的一个经典例子吧？<b>异或</b>是位运算里最神奇，最有魔性的一个。有很多坑货玩法，都可以借助异或实现。

<hr>

137 Single Number II

题意：136的变体题，这次其他数都出现了3次，而不是2次。找出这个单独的数。要求只使用O(1)空间

难度：medium

解法：有点<b>脑洞</b>了，这次不能用异或来抵消结果。用的是逐个二进制位统计1的个数。因为是出现3次，那个数肯定是3个倍数。因此，如果<b>余数是1</b>，就表示单独的数<b>在这一位是1</b>，否则这位是0。这样<b>一位位拼起来</b>就是最终结果。

<hr>

138 Copy List with Random Pointer

题意：给定一个链表，每个节点有一个random指针，指向了链表里另一个节点，位置没有规律。请设计算法复制这个链表，使得复制链表的random指针仍指向新表中的对应位置。挑战是<b>只使用O(1)额外空间</b>。

难度：medium

解法：这题是我见过的链表题里，<b>最诡异、最偏难怪、最奇技淫巧</b>的一题。直接通过哈希、数组或者随便什么<b>辅助结构</b>来完成的话，当然不难。难点在于不开辟额外结构，直接对next、random两个指针做出一些极难理解的操作。反正我无法描述清楚，到底发生了什么...你需要做一些p->random->next = xxx、p->next->random = xxx之类的魔法才能完成O(1)空间的解法。我觉得这题是<b>名副其实的hard</b>，也可以算tricky hard。

<hr>

139 Word Break

题意：给定一个长字符串s和一个词表。判断s是否可以被<b>划分成多个子串</b>，每个子串<b>都在词表中</b>。

难度：medium

解法：<b>正向思维</b>就是往后搜，<b>逆向思维</b>就是DP往前找。其实本质是一样的，只要效率够高就可以。

<hr>

140 Word Break II

题意：同139，但这次要求返回所有划分方式，结果中的<b>单词用空格连成句子</b>。

难度：hard

解法：这次就<b>必须搜</b>了，因为要求返回所有划分方式。

<hr>

141 Linked List Cycle

题意：给定一个单链表，判断是否存在环路。

难度：easy

解法：找有环链表的入口节点，这应该是《编程之美》上的例子了。不过这个只需要确定是否有环，不用找位置。有直白的<b>哈希表</b>解法，有<b>快慢指针跑圈</b>解法。快慢跑圈就是两个指针，快的走2步，慢的走1步，如果<b>能追上并且重新相遇</b>，就一定有环。

<hr>

142 Linked List Cycle II

题意：类似141，给定一个有环的链表，你需要找出环的入口节点。

难度：medium

解法：《编程之美》上的经典例子。还是哈希解法或者快慢指针解法。不过这次因为要找到入口节点，快慢指针会有一个很有意思的用法（也非常难想）。当两指针第一次相遇时，把其中一个<b>放回表头</b>，然后两个用<b>相同速度</b>前进。当两者再次相遇，就在入口处。<b>神奇吧？我反正第一次看到都懵了。</b>

<hr>

143 Reorder List

题意：给定一个链表，按照1、n、2、n-1、...的方式重新排列节点。不允许修改节点的值。

难度：medium

解法：照做即可。拆分，反转，拼装。注意边界case。

<hr>

144 Binary Tree Preorder Traversal

题意：二叉树前序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

145 Binary Tree Postorder Traversal

题意：二叉树后序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

146 LRU Cache

题意：就是LRU Cache，定义就不说了，操作系统课的内容。主要是说起来比较麻烦，懒得写。

难度：medium

解法：这题是<b>完美的面试题</b>。东西描述得清清楚楚，说难其实也不难，但就是<b>很麻烦</b>。你知道自己会做，但你要<b>耐心，仔细，还得写得快</b>。实现方式的话，就用<b>一个双向链表和一个哈希表</b>配合。这题在面试时<b>通常用来刷人</b>，犯一点错或者写的太慢，就挂了。这题其实是面试的hard，题目本身属于medium。<b>hard在于心理压力。</b>

<hr>

147 Insertion Sort List

题意：插入排序。按照插入排序的定义，对链表进行排序。

难度：medium

解法：也是<b>教科书内容</b>了，首先你得知道<b>插入排序</b>的具体做法。因为插入排序是顺序寻找位置的（没用二分查找，也就没有<b>随机访问</b>），所以同样的方法也可以在链表上实现。照做即可，注意边界case。

<hr>

148 Sort List

题意：给定单链表，进行元素排序。

难度：medium

解法：教科书。排序是算法课的最基础且重要的内容之一，<b>必知必会</b>。可以用归并排序的思路做，都是顺序访问。如果用<b>快速排序</b>，你的划分元素就只能用<b>表头</b>了。当然，也不是不能做，但比较费劲而且不好理解。<b>对链表来说，还是归并排序最直接。</b>

<hr>

149 Max Points on a Line

题意：给定一些<b>整数点</b>，请问一条直线最多可以穿过多少点。

难度：hard

解法：其实不算难，平方复杂度能解决就行。对于每个点，考虑其他点连线的<b>斜率</b>，同斜率就等于共线了。但如果直接这么做，就错了。因为<b>浮点数计算</b>会有<b>精度问题</b>。另外，别忘了有<b>重合点</b>的情况。应该用<b>x/y这种分数来表示斜率</b>，也包括0/1和1/0两种特殊情况。分数，记得<b>约分</b>。

<hr>

150 Evaluate Reverse Polish Notation

题意：给定一个算数表达式的<b>逆波兰表达式</b>写法，计算它的结果。

难度：medium

解法：属实是专业术语了，这是形式语言的一部分。<b>逆波兰表达式</b>是<b>语法树</b>的<b>后序遍历</b>。语法树是什么呢？不展开了，都在编译原理的基础课里。比如`1+2*3`，对应的后序就是`['1', '2', '3', '*', '+']`。思路就是<b>栈</b>。递归是栈操作，所以你要模拟递归，就用栈做一遍。

<hr>

151 Reverse Words in a String

题意：给定一个句子，单词间用空格连接。请反转单词顺序，但不要反转单词里的字母。

难度：medium

解法：水题。题目还提到了，如果字符串结构是<b>可变</b>的（很多语言的字符串是<b>不可变类型</b>），有没有什么更高效的O(1)空间做法。

<hr>

152 Maximum Product Subarray

题意：给定一个整数数组，可能有正负数和0，求累乘最大的子数组，返回乘积。

难度：medium

解法：这题很有意思，也有点难。如果只有正数的话，可以直接取对数，<b>把乘积化为求和</b>。如果有正数和0的话，可以<b>把0作为分界线</b>，因为跨过分界线乘积一定是0。但还有负数，问题就复杂了，因为负负得正。也可能整个数组都是负数。我的思路是既要求<b>最大值</b>，也要求<b>最小值</b>，因为<b>最小值再乘一个负数</b>，可能就<b>变最大</b>了。讲了很多，其实代码挺简短的。并没有取对数，没必要。

<hr>

153 Find Minimum in Rotated Sorted Array

题意：给定一个<b>可能经过</b>循环移位的有序数组，找出最小值。

难度：medium

解法：二分，肯定二分。

<hr>

154 Find Minimum in Rotated Sorted Array II

题意：同153，但数组可能包含重复。

难度：hard

解法：给升级到hard其实夸张了，并没有变难。对于重复元素，也只能采取下标+1的办法。这个思路之前已经遇到过了，因此最坏时间是O(n)，最好依然是O(logn)。

<hr>

155 Min Stack

题意：设计一个最小栈，既可以像普通栈一样<b>出栈入栈</b>，也可以随时返回当前栈内最小元素。

难度：medium

解法：额外用一个<b>单调栈</b>，始终只放入<b>不大于栈顶</b>的元素。这样得到的单调栈是<b>递减</b>的。在出栈时，如果当前<b>栈顶元素</b>也等于<b>单调栈的栈顶</b>，则单调栈也出一个。后面还会有几个类似的题，在<b>栈、队列</b>之间玩一些<b>左右互搏的魔法</b>。

<hr>

156 Binary Tree Upside Down

题意：给定一个特殊的二叉树，所有非叶节点<b>都有左右子树</b>。请执行上下反转操作，<b>使得右邻居节点变为左子树，父节点变为右子树。</b>

难度：medium

解法：付费题。LeetCode的<b>第一道付费题</b>，我现在已经打不开题目页面了。这个反转方式比较诡异，读一遍题都看不懂。解法<b>并不需要递归</b>，在草稿纸上画一下形状，用循环可以搞定。因为题目要求比较奇怪，解法自然也奇怪。

<hr>

157 Read N Characters Given Read4

题意：如果你有一个read4函数，每次可以读4个字符，请设法实现一个read函数，读任意长度字符。

难度：medium

解法：付费题。这个需求倒是不奇怪，很多通讯方式就是定长的，需要各种特殊处理。这题考点就是<b>处理剩余的字符，不要丢失数据</b>。

<hr>

158 Read N Characters Given Read4 II - Call multiple times

题意：157的变体，这次你实现的读取n个字符的read函数<b>可能被调用多次</b>。

难度：hard

解法：付费题。多次调用，那就有<b>更多的边界case</b>要处理。

<hr>

159 Longest Substring with At Most Two Distinct Characters

题意：给定字符串s，求出其中最多包含<b>两种不同字符</b>的最长子串。返回长度。

难度：medium

解法：付费题。和后面还会遇到n次的各种类似题目一样，<b>滑动窗口+计数</b>。

<hr>

160 Intersection of Two Linked Lists

题意：给定两个单链表，可能在某一点交汇。请找出交汇点。

难度：easy

解法：这题也是链表脑洞合集之一。如果先统计长度，然后对齐位置找汇合点，就没什么脑洞。我记得好像有个奇奇怪怪的解法，涉及到反转链表。但考虑到<b>先求长度再对齐位置</b>的方法已经是O(1)空间了，没必要节外生枝。

<hr>

161 One Edit Distance

题意：给定两个字符串s和t，判断它们的编辑距离是否为1。

难度：medium

解法：付费题。之前已经讲过编辑距离的定义了，增、删、改一个字符，算一次编辑。第一念头是DP，但想了下发现不需要。直接<b>双指针</b>对应位置匹配，如果不匹配，则需要1次编辑。如果编辑次数大于1，就可以返回了。你并不是在找<b>最短编辑距离</b>。

<hr>

162 Find Peak Element

题意：给定一个数组，所有相邻元素都不想等。峰值元素的定义是，比左右邻居都大。边界处可以视为负无穷，也满足定义。请找出任一峰值的下标。要求在O(logn)时间完成。

难度：medium

解法：线性解法是显然的，不讨论。对数当然要依靠<b>二分</b>。二分的思路，就是如果处在上坡`a<b<c`，就应该<b>向右</b>；如果处在下坡`a>b>c`，就应该<b>向左</b>。这样逐渐缩小范围，总能夹出一个峰值。

<hr>

163 Missing Ranges

题意：给定一个有序数组，以及<b>闭区间</b>的上下界lower和upper。请返回所有<b>不在数组中的值</b>构成的<b>区间列表</b>。

难度：medium

解法：付费题。倒是没什么特别，一个个地添加、合并区间，然后<b>用总区间减一下</b>。或者也可以从`[lower, upper]`开始，一个个去掉数组中的元素。总之思路很简单，<b>实现起来麻烦</b>，而且<b>边界case很多</b>。

<hr>

164 Maximum Gap

题意：给定无序数组，请返回排序后，<b>相邻元素</b>的最大差值。但是<b>不允许排序</b>，需要在O(n)时间空间完成。

难度：medium

解法：多年之后，我重新花了10分钟想，没想出来。看了当年的代码，原来是<b>桶排序</b>。没错，当年想不出来，现在还是想不出来。这种<b>神谕时刻</b>，不是后天训练能学会的。统计<b>最大最小值</b>，和<b>不同值的个数</b>，对所有元素进行<b>区间分桶</b>。那么，关键来了，最大的相邻差值，一定来自`某桶的最小值 - 之前某桶的最大值`，且这两个元素之间没有任何元素了，否则它们就不相邻了。事后你再看，整个设计其实非常清晰、系统化，但不得不说脑洞就是很大。<b>“这是人想得出来的？”</b>。这可以算是super tricky hard了，设为medium难度不合理。最后，其实<b>桶排序不能算线性</b>，所有这个脑洞并不是100%讲道理，有点耍赖了。鉴定为<b>纯纯的坑货</b>。

<hr>

165 Compare Version Numbers

题意：给定两个类似1.1、1.2.34格式的版本号，比较其大小。版本号内数字<b>按整数处理</b>，无视多余的前置“0”。

难度：medium

解法：其实就是字典序，注意细节即可。

<hr>

166 Fraction to Recurring Decimal

题意：给定一个分数的分子分母，请用字符串表示它的<b>小数形式</b>。对于循环小数，要标记出<b>循环节</b>。

难度：medium

解法：小学数学，<b>分数和循环小数</b>的定义，这个挺有意思的。不断<b>做除法</b>，用一个数组（或者哈希表）来标记余数。如果一个余数<b>被第二次访问到</b>，就说明循环了。这个计算过程中记录的商，就是循环节。要注意开头可能<b>有不循环的部分</b>，不要漏掉。如果余数为0，则除尽了，结果是<b>有限小数</b>。总之是一道有点难度，要小心处理的题。

<hr>

167 Two Sum II - Input Array Is Sorted

题意：给定有序数组，找出两个元素，使得和等于target。返回下标。

难度：medium

解法：因为有序，可以直接用<b>双指针</b>向中间靠拢了。

<hr>

168 Excel Sheet Column Title

题意：给定列数，返回Excel中对应的列名称。

难度：easy

解法：Excel确实是这么定的。做一下特殊的进制转换，26进制。

<hr>

169 Majority Element

题意：给定一个数组，有一个值在其中出现超过了一半，找出这个值。

难度：easy

解法：这个称为<b>“众数”</b>，也是《编程之类》里的例子。如果不用哈希表统计个数，那就只留一个counter变量。是它，就+1；不是它，就-1。<b>计数减到负数了，就换掉。</b>因为数量超过了一半，怎么减最终也会大于0。因此留下的那个值肯定是众数。

<hr>

170 Two Sum III - Data structure design

题意：还是two sum，但这次要设计一个可以<b>不断添加元素</b>，可以<b>随时查找</b>two sum的数据结构。

难度：easy

解法：付费题。所幸只用判断<b>是否存在</b>，用一个哈希表统计已有元素，就可以随时查了。查找的方式就是遍历x，看`target - x`是否存在。注意处理`target = x + x`的情况。还有一种解法不如这个直白，效率上也不算优秀，不讨论了。

<hr>

171 Excel Sheet Column Number

题意：和168一样，但这次反过来了。给定Excel列名称，转换成列数。

难度：easy

解法：26进制，转换方式反过来即可。

<hr>

172 Factorial Trailing Zeroes

题意：给定自然数n，求n!末尾有多少个0。

难度：medium

解法：《编程之美》的经典题目之一。很巧妙，可以<b>一步步想出来</b>。多少个0，就代表<b>10的多少次方</b>。10的多少次方就是<b>2*5</b>的多少次方。阶乘嘛，<b>5的个数肯定比2少</b>，那就是多少个5。n!有多少个5？5是1个5，25是两个5，125是3个5。想出来了吗？

<hr>

173 Binary Search Tree Iterator

题意：给定一个二叉树，设计一个迭代器，用于<b>逐个访问</b>这个二叉树的<b>中序遍历</b>结果。每调用一次next()函数，得到中序遍历的下一个值。

难度：medium

解法：<b>栈</b>，用栈来模拟递归。

<hr>

174 Dungeon Game

题意：m x n的地下城，勇士从(0,0)出发，要去营救位于(m-1,n-1)的公主。每次允许<b>向右或者向下</b>移动一格。如果格子为正，表示<b>加血的瓶子</b>；如果格子为负，表示<b>打怪损失的血量</b>。请问勇士<b>最少需要多少血量出发</b>，才能成功救出公主。在任意位置，<b>至少血量为1</b>才能生存。

难度：hard

解法：要是允许上下左右走，那就复杂了。只能向右向下的话，可以<b>DP</b>解决。可以考虑<b>倒推</b>，从公主的位置，往左上走。

<hr>

179 Largest Number

题意：给定一系列非负整数，允许你用<b>任意顺序将其拼接起来</b>组成一个大数，请返回最大的结果。

难度：medium

解法：这题有个妙处，你想得很复杂，那就会越想越复杂。其实只做个排序就可以了。关键是，<b>排序的依据</b>。如果`a+b>b+a`，那就a在前，b在后。

<hr>

186 Reverse Words in a String II

题意：给定一个句子，只反转每个单词的字母，而不反转单词顺序。

难度：medium

解法：付费题。水题，和之前151的要求相反。

<hr>

187 Repeated DNA Sequences

题意：给定一个ATCG构成的DNA序列，请找出所有<b>长度为10</b>，且出现至少2次的子串。

难度：medium

解法：生物课知识就不讲了，DNA是ATCG，RNA是AUCG。如果直接暴力匹配或者统计的话，可以把各种子串都<b>哈希一下</b>，效率当然不高。因为字符只有4种，长度为10，给位运算提供了方便。所以改为用一个<b>20位二进制</b>来表示<b>10长度的DNA序列</b>，剩下的就是统计了。

<hr>

188 Best Time to Buy and Sell Stock IV

题意：同123，但这次你<b>至多可以做k次买卖</b>。求最大盈利。

难度：hard

解法：做两次买卖的时候，其实已经可以用<b>DP</b>思路解决了。延伸到k次，没有区别。考虑k-1次买卖的情况，递推即可。注意，是<b>至多</b>。

<hr>

189 Rotate Array

题意：给定数组和k，把数组循环右移k次。

难度：medium

解法：左反，右反，全反。

<hr>

190 Reverse Bits

题意：给定一个整数，把它的<b>二进制表示</b>反转一下。

难度：easy

解法：和数位反转一样，二进制十进制都一样。就是<b>模10乘10</b>和<b>模2乘2</b>的区别。

<hr>

191 Number of 1 Bits

题意：给定一个整数，求二进制表示里1的个数。

难度：easy

解法：经典位操作。`b=x&-x`提取一位，`x&=x-1`去除一位。

<hr>

198 House Robber

题意：给定n个房子依次排列。你是小偷，规定不能在相邻的房子偷东西。请问最多能偷到多少钱？

难度：medium

解法：比较直白的线性DP，保留<b>倒1和倒2</b>的状态，不断<b>滚动更新</b>即可。

<hr>

199 Binary Tree Right Side View

题意：给定一个二叉树，如果从<b>最右侧</b>看树，请返回能看到的节点值的列表。按<b>从上到下顺序</b>返回。

难度：medium

解法：其实方法倒是很多，目的都是遍历找到<b>最右边的节点</b>。可以按<b>先右后左</b>的方式进行<b>前序遍历</b>。也可以直接<b>层序遍历</b>。

<hr>

200 Number of Islands

题意：给定一个01矩阵表示的地形图。1表示陆地，0表示水。陆地按照上下左右相邻。请返回<b>连成一片的岛屿</b>的个数。

难度：medium

解法：搜，深度广度都可以。课本里管这个叫<b>“flood fill”</b>，洪泛算法。画图的<b>填色功能</b>，就是这么做的。

## 0201 - 0300

201 Bitwise AND of Numbers Range

题意：给定闭区间`[left, right]`，求其中所有数的<b>按位与&</b>的结果。

难度：medium

解法：位运算的<b>小聪明题</b>，`x = (x & x - 1);`。这种题都挺扯的，想不出来就很离谱，想出来了就很无聊。这就跟<b>法国国旗变荷兰</b>一样，小聪明。

<hr>

202 Happy Number

题意：给定一个正整数，用它<b>各位数的平方和</b>去替换它，不断重复这个过程。如果最终结果为1，则称为“快乐数”。判断一个数是否为快乐数。

难度：easy

解法：水题。

<hr>

203 Remove Linked List Elements

题意：给定链表，删除所有值为val的节点，返回表头。

难度：easy

解法：注意边界case即可。

<hr>

204 Count Primes

题意：给定正整数n，返回小于n的<b>质数</b>的个数。

难度：medium

解法：筛法，这个筛子的名字，是纪念古希腊数学家Eratosthenes的。

<hr>

205 Isomorphic Strings

题意：给定字符串s和t，问是否<b>同构</b>。同构的定义是，可以对s的字符进行某种<b>一对一映射</b>，映射之后的s串恰好变换为t，比如abb和xyy。

难度：easy

解法：首先检查长度是否相同。逐个找新字符，<b>建立这个映射即可</b>。如果映射过程中发现不匹配了，那就不同构。

<hr>

206 Reverse Linked List

题意：反转链表。

难度：easy

解法：标准题，原题。

<hr>

207 Course Schedule

题意：你需要学习n门课，标号为0到n-1。给定一些前置要求`[x, y]`，表示你需要<b>先完成y课才能学x</b>。请判断能否完成所有课。

难度：medium

解法：怎么感觉说反了？题目一目了然，有向图，<b>拓扑排序</b>，检查是否有环。拓扑排序是图论的标准算法之一，必知必会。记录每个点的入度，总之<b>不断找入度为0的点</b>，删除<b>它发出的边</b>，同时更新<b>指向点的入度</b>，再继续找。所有入度为0的点都找完了，如果还有剩余的点和边，<b>那就有环</b>。得到的<b>点顺序</b>就是拓扑排序。这个后面还会经常遇到，图论题里经常要用的方法。

<hr>

208 Implement Trie (Prefix Tree)

题意：实现<b>字典树</b>。

难度：medium

解法：就是标准的字典树，教科书题目。不解释细节了。字典树主要适合大量数据插入，且数据分布比较均匀的情况。好处是<b>随时更新、随时检索</b>。

<hr>

209 Minimum Size Subarray Sum

题意：给定整数数组和target值，找到<b>和大于等于target</b>的<b>最短的</b>子数组。返回长度。

难度：medium

解法：所有元素都非负，因此累加和是<b>单调递增</b>的。用这个方法可以弄个O(nlogn)的解法。但用<b>滑动窗口</b>的话，一前一后还可以更快，O(n)。

<hr>

210 Course Schedule II

题意：同207，课表问题。这次你需要求出<b>合理的选课顺序</b>。如果无法学完所有课，则返回空。

难度：medium

解法：如前所述，<b>拓扑排序</b>。这次要的就是拓扑顺序。如果有环的话，拓扑排序的结果就是不完整的，<b>不会包括环里的节点</b>。

<hr>

211 Design Add and Search Words Data Structure

题意：设计一个数据结构，可以添加单词，也可以查询单词是否存在。查询功能要支持以“.”表示任意单字符的功能。比如“b..”可以匹配“bcd”、“bxy”等等。

难度：medium

解法：一种比较直白，但实现略麻烦的思路是<b>字典树</b>。之前遇到过，所以应该会写了。对于“.”单字符通配的情况，那就<b>分叉搜</b>吧。看了下我的代码，确实用了字典树。

<hr>

212 Word Search II

题意：给定一个m x n的字母矩阵和一个词表。允许从矩阵<b>任一位置出发</b>，<b>上下左右走</b>，但不能<b>重复访问格子</b>。请返回词表中所有可以<b>在矩阵中拼接出来</b>的词。

难度：hard

解法：这个hard，其实现在看来也不算很难了。因为思路是很明确的，<b>搜</b>，但效率不能太差。<b>矩阵不大，每个单词也很短，但词表很长。</b>因此可以利用这个特点，做一些针对性的优化。我用了<b>字典树</b>，把词都装进去后，再做的搜索。所以可以认为这个“hard”主要体现在<b>费劲</b>，而不是难想。

<hr>

213 House Robber II

题意：同198，小偷系列的第二题。这次房子首尾排成一个圈，你还是不能在相邻房子偷东西。请问最多能搞多少钱？

难度：medium

解法：<b>循环数组</b>，还是同类问题。用a+a的方式处理循环下标问题，其他的和198没有区别。

<hr>

214 Shortest Palindrome

题意：给定一个字符串s，允许你在<b>左侧</b>添加字符，将其变为<b>回文串</b>。请返回得到的最短回文串。

难度：hard

解法：题目规模要求必须O(n)时间解决。第一思路是，如果我知道前k位是回文串，那剩下n-k位就要补全，总长度是n+n-k。让这个k尽可能大，总长度就会尽可能小。因此要求<b>最长的回文串前缀</b>。必须是前缀，因为你只能往左添加字符。最后我想了个比较丑，但是能用的办法。<b>字符串，滚动哈希值。</b>利用类似多项式计算的办法，快速求出子串的哈希。目的就是<b>快速比较两个子串是否相同</b>。这题是回文串，因此你需要<b>正反比较</b>，因此计算哈希的方式也需要<b>一正一反</b>。多年之后再看这题，除了这个思路我还是没什么好点子。不过，这应该就是<b>Rabin-Karp字符串匹配算法</b>的思路，也不算什么诡异的设计。看评论区都说<b>KMP</b>，那个比RK算法还烧脑。

<hr>

215 Kth Largest Element in an Array

题意：给定无序数组，返回第k大元素。

难度：medium

解法：教科书题目，快速排序的变体，<b>快速选择算法</b>。注意是第k大，不是第k小。也可以用堆完成，保持一个<b>大小为k的最大堆</b>。个人更倾向于用堆。

<hr>

216 Combination Sum III

题意：组合求和系列的第三题。给定整数n和k，从1-9中选出k个数，使其加起来等于n。不能重复选数，返回所有<b>组合方式</b>。

难度：medium

解法：搜。

<hr>

217 Contains Duplicate

题意：给定数组，判断是否有重复元素。

难度：easy

解法：水题，集合判重即可。

<hr>

218 The Skyline Problem

题意：给定一些用矩形表示的房子，互相可能重叠。要求你画出一个<b>总的轮廓</b>，也就是城市天际线。返回的方式比较奇特，只返回所有<b>天际线高度发生变化</b>的<b>拐角点</b>。

难度：hard

解法：挺经典的一道hard。比较复杂，也很有意思。第一思路是一堆区间，高度就是区间的值。那么要拼出总轮廓，就要<b>对区间进行拆分、合并</b>，这样才能知道任何地方的最大值（也就是高度）。所以按照区间排序、合并的方法，可以做出来。但这么做，很费劲而且容易出错，所以不推荐。还有一种思路，是<b>以高度为入手点</b>，你只关心<b>当前最高的</b>，因此如果你需要有<b>排好序的高度</b>，还要<b>能增能删</b>，因此使用map可以达到目的。总体思路就是，不断地<b>添加建筑、删除建筑</b>，同时更新高度记录，并<b>能随时查到最大高度</b>。确实hard，<b>难想且比较难写</b>。

<hr>

219 Contains Duplicate II

题意：给定一个数组，判断是否有重复元素，且重复元素的<b>下标距离</b>不超过k。

难度：easy

解法：滑动窗口，不断<b>记录下标</b>，移出窗口的元素删掉就行了。

<hr>

220 Contains Duplicate III

题意：数组判重第三题。给定数组，请判断是否存在两个元素，它们值相差小于某个阈值，位置相差也小于某个阈值。也就是<b>值接近，位置也接近</b>。

难度：hard

解法：这个都不能算判重了，可以算是<b>“判接近”</b>。同理，还是<b>滑动窗口</b>。因为要判断值<b>接近</b>，而不是<b>等于</b>，那就找一个可以<b>增删查</b>，还可以<b>搜范围</b>的数据结构，因此用map正合适。python里的OrderedDict，也可以用bisect方法来进行二分查找。总之思路是一样的，<b>滑动窗口</b>更新记录，配合<b>二分查找</b>附近的值是否存在。

<hr>

221 Maximal Square

题意：给定m x n的01矩阵。请找出其中元素全为1的最大正方形。返回面积。

难度：medium

解法：之前85题是最大矩形，这个是正方形。这题更简单，不需要做各种变形，用<b>DP</b>。每个位置的dp[i][j]记录以这个点为<b>右下角</b>，能<b>往左上延伸多大的正方形</b>。想想这个关系式怎么列？最终max(dp[i][j])就是答案。不过我看了下<b>当年写的代码</b>，好像想的特别复杂，<b>不是我现在这个思路</b>。

<hr>

222 Count Complete Tree Nodes

题意：给定一个<b>完全二叉树</b>，在<b>小于O(n)时间</b>内，求出树的节点数。

难度：easy

解法：完全二叉树是除了最后一层之外，其它层都是满的。这种树可以用<b>紧凑的数组</b>表示，可以用来做<b>堆</b>。其实就是让你二分，二分找那个分界点，每次二分的代价是O(h)，h其实就是logn，你需要执行logn次二分，因此总代价是O((logn)^2)。log在多项式阶数是等效于0阶的，平方之后还是0阶，小于O(n)。符合要求。平心而论，这也不easy了，考察的东西<b>非常“科班”，近乎教条</b>。

<hr>

223 Rectangle Area

题意：给定两个和<b>坐标轴对齐</b>的矩形，求总共覆盖面积。

难度：medium

解法：初级的几何题。要知道如何求<b>矩形的交集</b>。相加，减去交集即可。

<hr>

224 Basic Calculator

题意：给定算数表达式，求值。要求支持整数的+、-、()运算。表达式可能带有无用的空格字符。

难度：hard

解法：很不错的面试题。东西不算很难，但能考察一个完整功能的实现，也包含了一些理论知识。知识点就是词法解析、语法树、栈操作。注意三点，运算数<b>入栈</b>；运算符<b>出栈</b>，且执行对应运算函数；括号调整<b>优先级</b>。后面的题目还会遇到<b>加减乘除</b>，对优先级也需要处理。

<hr>

225 Implement Stack using Queues

题意：请用<b>队列</b>实现一个<b>栈</b>。

难度：easy

解法：<b>这题很奇怪</b>。栈是反的，队列是正的。你可以负负得正，但不能正正得负吧？用两个队列也可以勉强实现，但我很确定这样得不到全O(1)的结果。<b>总之，是有问题的。</b>注意不能用deque，<b>deque是双向队列</b>，属于栈和队列的复合体。

<hr>

226 Invert Binary Tree

题意：反转二叉树。

难度：easy

解法：<b>LeetCode名梗之一</b>，用于嘲讽不刷题也不会写代码的菜，或者超会写代码且不屑于刷题的大佬。递归解决。

<hr>

227 Basic Calculator II

题意：224的变体。这次要支持<b>加减乘除</b>，但好像不用支持括号运算？

难度：medium

解法：其实没必要，之前已经写了<b>括号的逻辑</b>，就要<b>处理好优先级逻辑</b>。这次加入乘除，还是注意优先级即可。

<hr>

228 Summary Ranges

题意：给定<b>有序数组</b>，将其整理为区间段，每个区间表示<b>数组用已全部包含的数</b>。

难度：easy

解法：<b>因为有序</b>，所以难度大大降低了。直接逐个区间统计出来即可。

<hr>

229 Majority Element II

题意：169的变体。众数，但这个要求返回所有<b>出现超过1/3</b>的元素，不是1/2。

难度：medium

解法：还是脑洞题，问能不能在O(1)空间下解决。仿照之前的办法，<b>用两个计数器</b>，用同样的+1 -1的办法。你要是1/k，我就用k-1个计数器。不过这种脑洞搞得太多，就没意思了。

<hr>

230 Kth Smallest Element in a BST

题意：给定二叉搜索树，求其中第k小的值。

难度：medium

解法：首先，BST的中序遍历有序。做完整遍历取第k个是直接解法，时间O(n)。那么目标就是能不能在<b>对数时间</b>完成。而且题目还提出了，如果<b>树经常修改</b>，随时要求查询，有没有优化方法。看了下我的代码，用的是<b>统计节点个数，做记录</b>的方法。<b>用节点个数来判断左右走</b>。这方法其实不怎么好，但也没想出更好的。如果你说再用一个k大小的<b>最大堆</b>来记录k个值，那就有点耍赖了。都考察二叉树了，再用一些更复杂的数据结构来辅助，是不合理的。总之，这题<b>我没有很优雅的解法</b>。

<hr>

231 Power of Two

题意：给定一个整数，判断是不是2的整次幂。

难度：easy

解法：位运算，`x&x-1 == 0`。

<hr>

232 Implement Queue using Stacks

题意：请用<b>栈</b>实现一个<b>队列</b>。

难度：easy

解法：记住复杂度，如果原本都是O(1)，你的解法<b>至少要保证都是均摊O(1)</b>。如果弄成O(n)，那就失败了。具体做法，就是<b>两个栈</b>，左手倒右手，负负得正。

<hr>

233 Number of Digit One

题意：给定自然数n，求从0-n的所有数里，数字1出现的总次数。

难度：hard

解法：<b>数位动归</b>题。这种应该是非常标准的“算法题”了，不论题目还是思维，在工作、生活里估计一辈子也用不上。<b>DP</b>解决。具体就是考虑所有k位数里总共有多少个1，递推k和k-1的关系。DP关系式是从低往高推，对n则是从高往低处理。<b>第一次遇到确实挺难想的</b>。

<hr>

234 Palindrome Linked List

题意：给定链表，判断是否是回文链表。

难度：easy

解法：单链表，<b>不能随机访问，也不能回头</b>，因此还是有点难度。做法是对半拆分、反转、比较。这么想其实挺费劲的。当然，如果你<b>不在乎O(1)空间</b>的话，直接放到数组里就好了。

<hr>

235 Lowest Common Ancestor of a Binary Search Tree

题意：给定二叉搜索树，求两个点的<b>最近公共祖先</b>。

难度：medium

解法：<b>最近公共祖先，LCA问题</b>，是算法课遇到的最精妙（且难理解）的问题之一。主要是<b>Tarjan离线算法</b>的功劳，实在太神奇了。这题因为是二叉搜索树，有一个<b>有序</b>的特点，要容易很多。如果你发现x、y一个比r大，一个比r小，<b>那不就要分叉了</b>？那答案就是r，找到了。如果你发现r<b>恰好等于</b>x或者y，那也找到了。

<hr>

236. Lowest Common Ancestor of a Binary Tree

题意：235的变体，这次是普通二叉树了，无序。还是找<b>最近公共祖先</b>。

难度：medium

解法：这次没有<b>有序</b>的特点了。直白的做法，就是确定x、y两节点的深度，把<b>深度对齐</b>了，然后<b>一起往上走直到汇合</b>。神奇的<b>Tarjan算法</b>可以<b>一次性处理</b>很多这样的<b>批量查询</b>，这是它的神奇之处。这题就先用土办法搞定吧。

<hr>

237 Delete Node in a Linked List

题意：给定一个链表，你要删除某个节点。但你<b>只有这个节点的位置</b>，没有表头，请<b>就地修改</b>。

难度：medium

解法：脑洞题。反正在<b>“这也不行那也不行”</b>的情况下，我选择把<b>下一个节点的值</b>赋给它，然后把下一个点删了。这题目还特地提示你，这个点<b>不会出现在表尾</b>，你说是不是成心的？这种题就没意思，<b>为赋新词强说愁</b>。

<hr>

238 Product of Array Except Self

题意：给定数组，对每个元素，求出<b>除了它以外</b>其他元素的乘积。要求O(n)时间完成，且不使用除法。

难度：medium

解法：有意思的一题，且这个<b>思维方式</b>在后面还会用到。用<b>前缀、后缀</b>的方式，记录左连乘、右连乘，然后乘起来就行了。这样需要O(n)空间，因为要用数组记录左右结果。也可以省一个，但<b>不能两个都省</b>。

<hr>

239 Sliding Window Maximum

题意：给定长度为n的数组，用一个k大小的滑动窗口不断向前。在每个位置，求出<b>当前窗口的最大值</b>。

难度：hard

解法：这题是手把手教你用<b>滑动窗口</b>了，很有<b>教育意义</b>的一题。最直接的方法就是<b>map</b>，java叫TreeMap，python叫OrderedDict。这些结构的更新代价是O(logn)，查询最大最小值则是O(1)的。不断更新窗口的统计，按要求进行增删，每次都查询map里的最大值即可。

<hr>

240 Search a 2D Matrix II

题意：给定一个特殊的m x n矩阵，<b>每行向右</b>都是递增的，<b>每列向下</b>也是递增的。请在其中查找target值<b>是否存在</b>。

难度：medium

解法：74题和这个长得非常像，<b>但不一样</b>。74题的矩阵可以展开成<b>一个有序的一维数组</b>，而这个矩阵则是一种特殊的<b>数学结构</b>，叫Young tableau。有一种比较好理解的线性解法，提示是<b>“向左、向下”</b>。查资料显示<b>O(logn)的解法应该是不存在的</b>，但论证过程复杂点，没看懂。另外有O(nlogn)解法，也很容易想，逐行（或逐列）进行二分查找即可。但已经有线性解法，这个就没有必要了。

<hr>

241 Different Ways to Add Parentheses

题意：给定一个包含<b>加减乘</b>的算数表达式，允许你<b>任意添加括号</b>，请求出所有可能的计算结果。

难度：medium

解法：意思是你可以随便处理<b>优先级</b>。既然这样，就<b>递归搜</b>每个表达式片段的结果。当然，可以变动的是<b>结合优先级</b>，<b>运算数的先后</b>不能变。有点难，有点麻烦，但不算很难。

<hr>

242 Valid Anagram

题意：给定两个串s和t，判断是否为anagram。

难度：easy

解法：<b>排序后比较</b>即可。不排序的话，那就统计字母，再比较。

<hr>

243 Shortest Word Distance

题意：给定一个词表和其中两个词，求它们的<b>位置之差</b>。

难度：easy

解法：付费题。水题。

<hr>

244 Shortest Word Distance II

题意：243的变体，这次词表是固定的，但<b>查询单词位置之差</b>的操作会多次调用。请设计<b>高效算法</b>。

难度：medium

解法：付费题。用<b>哈希表</b>记录单词的下标即可。

<hr>

245 Shortest Word Distance III

题意：243的变体，这次词表可以有重复，选取的两个词也可以重复。

难度：medium

解法：付费题。那就还是<b>记录下标</b>，找最小差值就行了。没什么大区别。我琢磨至少需要<b>访问整个数组</b>才知道有哪些词，在什么位置。所以你不可能在O(logn)时间内完成，因此最优的时间也是线性的。不过这题也有点小技巧，就是<b>用两个变量i1、i2记录你找到的word1和word2的位置</b>，不断更新这个位置。当你<b>两个词都找到了</b>，就有结果了。你不断更新位置，也同时不断更新结果，使其越来越小。

<hr>

246 Strobogrammatic Number

题意：给定一个数，判断是否为中心对称的数。

难度：easy

解法：付费题。这个单词就够艰深的，strobogrammatic。意思是<b>中心对称</b>，旋转180度那种。<b>619</b>，6和9，中间的1。题目倒是水题。

<hr>

247 Strobogrammatic Number II

题意：246的变体，这次要求出所有<b>长度为n</b>的中心对称的数。

难度：medium

解法：付费题。稍微麻烦一点，但也不难。0对0、1对1、6对9、8对8，就这么多了。<b>左半边枚举</b>，右半边是确定的。

<hr>

248 Strobogrammatic Number III

题意：246的变体，这次要求出所有在`[low, high]`范围内的中心对称数。

难度：hard

解法：付费题。忘了为什么难度是hard，应该是<b>low、high的范围很大</b>。还是按照01689去搜就行了。注意搜的时候处理好low和high的<b>边界终止条件</b>。

<hr>

249 Group Shifted Strings

题意：给定一些只包含a-z的字符串，如果通过<b>任意次</b>字符循环后移可以变成<b>同一字符串</b>，则归为一组。<b>字符循环后移</b>是指类似`acc->bdd->...->zbb`这样的变换。请返回分组后的结果。

难度：medium

解法：付费题。<b>锚定一个位置</b>，进行对齐即可。比如所有字符串都移位成首字母为“a”，比较结果是否相同，相同就是一组的。

<hr>

250 Count Univalue Subtrees

题意：给定二叉树，求出单值子树的个数。<b>单值</b>的意思是，整棵树的节点值都相同。

难度：medium

解法：付费题。<b>递归搜</b>，同时用<b>集合</b>记录当前子树的不同值个数。个数为1就是单值子树了。

<hr>

251 Flatten 2D Vector

题意：设计一个迭代器，用来访问<b>二维数组</b>。按照<b>先行后列</b>的顺序，逐个访问每个元素。

难度：medium

解法：付费题。也没什么特别的，就一行行扫。

<hr>

252 Meeting Rooms

题意：给定一些会议的起始终止时间，问一个人能否参加所有会议。

难度：easy

解法：付费题。就是判断<b>区间是否重叠</b>。

<hr>

253 Meeting Rooms II

题意：252的变体。这次要判断组织这些会议至少需要多少个会议室。

难度：medium

解法：付费题。有一点难度了。这题要求的是同一时间，最多<b>有几个会议在同时进行</b>。评论区肯定有不少搞竞赛的说<b>这肯定线段树啊、树状数组秒了</b>这个那个。其实目的就是<b>针对区间做+1</b>，最后统计最大值。没必要搞那些，用<b>后缀和累加的方式</b>，也能搞定，不需要复杂的数据结构。需要注意，如果这个+1操作和查询操作是穿插的，换言之，不是<b>一口气加完了再查</b>，那就必须用奇奇怪怪的工具才行了。这就是<b>离线算法</b>和<b>在线算法</b>的区别。我看了下当年的代码，怎么用了个<b>排序+堆</b>的解法，搞不懂。

<hr>

254 Factor Combinations

题意：给定一个整数n，返回所有<b>n的约数相乘等于n</b>的<b>组合方式</b>。所选约数必须小于n。

难度：medium

解法：付费题。<b>搜</b>，注意搜法，使得结果不重复。如果<b>花额外代价做去重</b>，就不值得了。

<hr>

255 Verify Preorder Sequence in Binary Search Tree

题意：给定一个二叉树的<b>前序遍历</b>结果，判断对应的二叉树是否为<b>二叉搜索树</b>。

难度：medium

解法：付费题。比较直接的解法，是对`<值, 下标>`做一下映射记录，然后递归比较。如果是BST的话，左边都小于根，右边都大于根，这样能找到<b>分界位置</b>。递归往下找。如果发现矛盾，则不是一个合法的BST。还有一种思路，就是用<b>栈</b>。因为前序遍历<b>总是尝试往左走，越走越小</b>，走不动了就往右。利用这个特点想一想怎么入栈出栈，怎么做判断。题目还提出了<b>O(1)空间</b>的挑战，这个有点<b>小聪明</b>。在栈解法的基础上，直接把<b>原数组的头部</b>当成栈来用。总体上，这题挺扯的，有点费脑子。

<hr>

256 Paint House

题意：有n个房子依次排列，每个房子可以涂成红绿蓝的一种。每个房子涂每种颜色的代价用cost[i][j]表示，可能各不相同。现在要求<b>相邻房子</b>不能同色，问<b>最低代价之和</b>是多少？

难度：medium

解法：付费题。很标准的<b>DP</b>题。以前难度定为easy，后来改medium了。

<hr>

257 Binary Tree Paths

题意：给定二叉树，返回所有<b>从根到叶</b>的路径。用一种特定格式输出。

难度：easy

解法：<b>搜</b>，拼装结果。

<hr>

258 Add Digits

题意：给定一个整数，不断将它替换为它的<b>数字和</b>，直到<b>剩下一位数</b>。返回最终结果。

难度：easy

解法：水题。

<hr>

259 3Sum Smaller

题意：15的变体。给定数组和target值，求出所有加起来<b>小于target</b>的<b>三元组</b>的个数。

难度：medium

解法：付费题。思路依然类似。<b>枚举第一维</b>，另外两维采取<b>滑动窗口</b>的方法统计个数。

<hr>

260 Single Number III

题意：136的变体。给定一个数组，除了<b>两个值出现一次外</b>，其他值都出现两次。找出这两个值。

难度：medium

解法：脑洞题。肯定又要<b>位运算</b>了。重新想了十分钟，想不出来。看答案，发现是按<b>异或和</b>进行分类。针对某一位，0站一边，1站另一边。注意，是“某一位”，不是“每一位”。选哪一位呢？随便找两数不相同的一位就行，也就是异或和里<b>随便找个1</b>就行。不得不说这个<b>脑洞是真的大</b>，<b>天才题</b>。

<hr>

261 Graph Valid Tree

题意：给定一个无向图，判断是否是一棵树。

难度：medium

解法：付费题。树的定义其实就是<b>单连通、n个点、n-1条边</b>。你想想，这个条件卡下来，一定是棵树。<b>重复边不算</b>，有重复边也不能算是树了。

<hr>

263 Ugly Number

题意：一个数如果没有2、3、5之外的<b>质因数</b>，称为<b>丑数</b>。判断给定n是否是丑数。

难度：easy

解法：水题。

<hr>

264 Ugly Number II

题意：263的变体。给定n，返回第n个丑数。

难度：medium

解法：有点难度了，可以用<b>最小堆</b>实现。起步思路是3个指针指向x2、x3、x5，每次都从里面取出最小的那个，并把对应指针<b>往前一步</b>。不过毕竟<b>只有3条路</b>，用代码<b>手工取最小</b>也行。

<hr>

265 Paint House II

题意：256的变体。这次三颜色变成了k颜色。还是求最小代价。

难度：hard

解法：付费题。和之前完全一样，<b>DP</b>思路不变。3和k没有区别。

<hr>

266 Palindrome Permutation

题意：给定一个字符串，判断能否通过<b>字母乱序</b>变为一个回文串。

难度：easy

解法：付费题。水题，统计字符个数即可。

<hr>

267 Palindrome Permutation II

题意：266的变体。这次要求返回所有可通过<b>字母乱序</b>而变换出的<b>回文串</b>。

难度：medium

解法：付费题。有一点难度，需要想清楚。因为是回文串，后半部分是确定的，<b>前半部分可以自由枚举</b>。因此，用<b>next permutation</b>的方式枚举所有的前半部分，每次都<b>对应拼出后半段</b>就行了。<b>不用递归，都是循环。</b>

<hr>

268 Missing Number

题意：给定一个长度为n，且元素都在`[0,n]`范围内的数组。请找出<b>范围内没出现</b>的值。要求O(1)空间完成。

难度：easy

解法：<b>1-n累加</b>，看看差哪个。还有很多奇奇怪怪的做法，不讨论了。

<hr>

269 Alien Dictionary

题意：给定一种奇怪的外星语言，用了26个字母，但是顺序和正常的不一样。给你一组外星单词，且是<b>按照这个语言的字典序排列</b>的词表。请你推测出26个字母的先后顺序。

难度：hard

解法：付费题。有意思的一题，难度定为hard可能夸张了，但确实有意思，也不脑洞。这题的难点在于能快速看出<b>它是个图</b>。图在哪儿？就是26个字母建成一张图，你需要判断谁前谁后，就是<b>拓扑排序</b>。要拓扑就需要边，<b>边在哪儿</b>？就是词表里，<b>相邻两个单词的比较</b>，第一个不同的字母，就是边。当然，需要有不同字母的比较，才有用。比如`['bax', 'baxde']`这样是没用的。比如`['bax', 'bacd']`就有用，你知道了`x>c`。

<hr>

270 Closest Binary Search Tree Value

题意：给定一个二叉搜索树和一个target值，求出最接近target的节点值。

难度：easy

解法：付费题。不用想太复杂，按BST的规矩左右走，记录上一个访问到的值。因为当前值和上一个值，都可能是<b>最接近target</b>的值。另一种更暴力的办法就是先中序遍历，再从结果里找。但那样就效率低了。

<hr>

271 Encode and Decode Strings

题意：设计一个<b>编解码器</b>，把一组字符串编码成一个串。同时提供对应的解码方式。

难度：medium

解法：付费题。这是个<b>系统设计题</b>了，不太属于算法题。这个需要一些<b>编码理论课程</b>了，如果没学过完全凭自己创意做，估计会离题万里或者有各种问题。我当年怎么写了个base64的解法，代码还巨啰嗦。

<hr>

272 Closest Binary Search Tree Value II

题意：270的变体。这次要返回最接近target值的k个节点值。

难度：hard

解法：付费题。这题确实有难度了，难在比较麻烦。这个查询需求其实在实际工作里挺常见，尤其是<b>数据分析时</b>，所以这是道好题。我的思路是借助270的方法，用<b>正反两个方向</b>找到接近target的位置，然后<b>朝两边延伸，直到凑够k个结果</b>。想不出比较简洁的实现，所有代码巨长，专门写了<b>正反迭代器</b>。其实<b>思路是可以的</b>，应该是代码写得太差了

<hr>

273 Integer to English Words

题意：给定整数，用<b>英语</b>把它读出来。

难度：hard

解法：很费劲，而且要处理一些语法规则。很考验耐心的一题。<b>这个hard指的是work hard</b>。

<hr>

274 H-Index

题意：学术界有个H-index，能表示一个学者的<b>著作影响力</b>。定义是这个人如果<b>有h篇著作的引用数不低于h</b>，这个<b>h的最大值</b>就是其H-index。

难度：medium

解法：可以<b>排序</b>，然后<b>二分再二分</b>。先二分值，每个值二分查个数。

<hr>

275 H-Index II

题意：274的变体。这次<b>已经排好序</b>了，要求在<b>对数时间</b>完成。

难度：medium

解法：274里其实已经说了思路。<b>二分再二分</b>，复杂度是O((logn)^2)。

<hr>

276 Paint Fence

题意：有一个篱笆，有n个桩子。你可以选择k种颜色，给每个桩子上色。要求不能有<b>3个以上的相邻桩子</b>使用同一颜色。请问有多少种上色方法？

难度：medium

解法：付费题。思路上当然是个DP题，不过<b>可以不使用数组</b>。你只关心过去两个元素是<b>相同</b>还是<b>不同</b>。相同如何，不同如何，按这个思路递推。

<hr>

277 Find the Celebrity

题意：给定一些“谁认识谁”的关系，请找出圈子里的名人。名人的定义，就是大家都认识他，他不认识大家。

难度：付费题。嗯，名人，很拽。统计<b>入度和出度</b>即可。

解法：

<hr>

278 First Bad Version

题意：给定一个<b>检测函数</b>，告诉你某个版本号是否损坏。你需要设计策略，尽快找出第一个坏版本。

难度：easy

解法：二分。

<hr>

279 Perfect Squares

题意：给定一个整数n，请将其划分为几个完全平方数之和，并使得划分的个数最少。

难度：medium

解法：可以<b>DP</b>解决，也可以<b>BFS搜索</b>解决。个人觉得搜索的思路更直观。

<hr>

280 Wiggle Sort

题意：给定一个无序数组，将其乱序，使得结果满足类似“小大小大小大...”的关系，称为<b>摇摆排序</b>。返回<b>任意一种</b>有效结果即可。

难度：medium

解法：付费题。一种比较容易的思路，是<b>先排序</b>，然后把后半段<b>大的部分</b>穿插进<b>前半段里</b>。因为要求“小大小大小...”，穿插的部分都是<b>“大”</b>，用后半段正合适。不过我看了下自己以前的代码，用了更奇怪的一种思路。使用快选quick select的方式选一个中轴点，然后左右摆放，很难理解。<b>不知道当年怎么想的。</b>

<hr>

281 Zigzag Iterator

题意：给定一个二维数组，设计一个迭代器，采取<b>“先列后行”</b>的方式迭代访问这个数组。

难度：medium

解法：付费题。不难，就是有点麻烦，注意边界case即可。

<hr>

282 Expression Add Operators

题意：给定一个数字串和一个target值，允许你在任意位置插入<b>加减乘</b>号来构成一个<b>有效的</b>算术表达式。请问有多少种方法使得结果为target，返回所有方法。

难度：hard

解法：难度是hard，其实思路非常明确，<b>搜</b>。处理过程稍麻烦一点，而且注意进行剪枝。耐心完成即可。

<hr>

283 Move Zeroes

题意：给定一个数组，把0移到末尾，同时把非0元素<b>依次</b>往前移动。

难度：easy

解法：水题，和<b>就地去重</b>的方法一样。

<hr>

284 Peeking Iterator

题意：给定一个已有迭代器，请在此基础上设计一个迭代器，增加peek()功能，可以在<b>不前进的情况下</b>得到当前元素。

难度：medium

解法：题目没有说用于<b>访问什么具体的结构</b>，也就是没让你在某种特定结构上想点子。那就考虑peek()本身了。既然已有的iterator你调用一次next()必然会前进一步，那就<b>把调用的值存起来，下次不调就行了。进货，存货，出货</b>，对吧？就这个思路。

<hr>

285 Inorder Successor in BST

题意：给定二叉搜索树和一个<b>特定节点p</b>，请返回p在<b>中序遍历</b>的后继结点。

难度：medium

解法：付费题。注意，给的是节点对象，<b>不是节点值</b>。BST，中序遍历，显然还是用<b>栈</b>解决。想想进出栈的设计。

<hr>

286 Walls and Gates

题意：给定一个m x n矩阵，-1表示墙、0表示门、INF表示空地。请求出所有<b>空地</b>到<b>离它最近的门</b>的距离。如果找不到门，那就保持INF值。

难度：medium

解法：付费题。像这种每走一步距离都是1的问题，第一直觉都是<b>BFS，搜</b>。那么要找所有空地，就在开始时<b>把所有空地放进队列</b>去搜好了。看了下当年代码，确实这么写的。

<hr>

287 Find the Duplicate Number

题意：给定一个n+1长度的数组，所有元素都在`[1,n]`范围。只有一个值存在重复，请找出这个值。

难度：medium

解法：这题和268不一样，因为这题的<b>重复元素不一定出现两次</b>，也可以是很多次。挑战是<b>O(1)空间</b>，那就用常规的<b>统计思路</b>，但是就地取材。在原数组上“叠一层”，用+n表示+1，+2n表示+2，如此点点点。其实就和<b>二维坐标打平成一维</b>的思路相同，`a[i][j]等效于a[i*m+j]`。

<hr>

288 Unique Word Abbreviation

题意：单词简写的一种常用方式是`<首字母><中间的个数><尾字母>`，比如i18n、l10n，国际化和本地化。现在给定一个词表，按这种方式简写，请判断<b>每个词的对应简写</b>在词表中是否<b>唯一</b>，也就是是否<b>有其他词使用了相同简写</b>。

难度：medium

解法：付费题。思路不难，简写然后归类即可。

<hr>

289 Game of Life

题意：由英国数学家John Conway发明的生命游戏，一个很有<b>哲学内涵</b>的玩具模型。具体规则不讲了，给定m x n的棋盘和起步状态，请推算出下一步的棋盘状态。

难度：medium

解法：怎么说呢，<b>自动机理论</b>也是一种很优雅，且很有哲学味道的<b>世界观</b>。比如<b>“命运的齿轮、造物主”</b>就是一种对人生和万事万物的很工程化的理解。挑战是不使用额外矩阵，<b>就地完成</b>。其实这个挑战有点取巧，用类似287的<b>“叠罗汉”</b>做法，在数据范围不大的情况下，叠一层就行。叠完了，用除法给变回来就是最终结果。你想想<b>一个整数表示32位真彩色，包含了argb四个通道，每个8位</b>，这不就是叠罗汉？

<hr>

290 Word Pattern

题意：给定模式串p和句子s。请判断是否存在一种`p的字符<->s的单词`的一对一映射（双射），能将p变换为s。

难度：easy

解法：和205的<b>字符串同构</b>有点相似，不过稍难。这题之所以easy，是因为<b>帮你做好了分割</b>，给你明确的“单词”了。如果s中的字母都连在一起，那难度就高一些了，但依然可解。

<hr>

291 Word Pattern II

题意：290的变体。<b>这次s中的字母都连一起了</b>，还是判断是否存在p到s的一一映射。

难度：hard

解法：付费题。如上，难点就是<b>找到分割方式</b>了。在<b>字符串不那么长</b>的情况下，可以<b>边搜边做映射</b>，映射出现矛盾就回溯。所以是<b>搜索+回溯</b>的思路。没想出其他更高效的思路。

<hr>

292 Nim Game

题意：博弈论烧脑系列。A和B玩游戏，有一堆n个石头，两人交替拿。每次拿1-3个，成功拿到最后一个的人赢。问谁赢。

难度：easy

解法：几乎所有人都对“both players play optimally”这句话深恶痛绝。这是直觉无法理解的神仙操作。讲道理这种题目的难度标记都没有意义，因为你<b>想不清楚</b>的话，就和<b>看天书</b>一样。比如此刻我就没理解为什么是easy，然后我<b>突然懂了</b>。<b>4的倍数</b>，你想吧。就这么坑人脑细胞。

<hr>

293 Flip Game

题意：给定一个<b>+-号组成的字符串</b>，允许你选<b>两个相邻的同符号</b>进行反转。请返回所有有效的反转结果。没有，则返回空。

难度：easy

解法：付费题。下一题就难了，这题是热身。

<hr>

294 Flip Game II

题意：293的变体。两人轮流执行如上的反转操作，无法执行的人输。如果两人都用<b>最优策略</b>，请问谁赢。

难度：medium

解法：付费题。博弈论。说实话，想不出来。<b>暴力搜索</b>很容易想，但效率肯定很差（其实可以过，够用了）。看了下当年写的代码，注释里提到了<b>Sprague Grundy定理</b>。查了一下发现是有关<b>博弈论</b>里<b>公平游戏</b>和<b>nim game模型</b>的转换。也就是前面提到的nim game。如此<b>理论且晦涩</b>的东西，我当年肯定也没做出来，代码也不是独立想出来的。躺了吧。我又尝试看了下当年的代码，实在看不懂。

<hr>

295 Find Median from Data Stream

题意：给定一个不断流入的数据源。你需要提供<b>随时添加数据和查询中位数</b>的功能。

难度：hard

解法：有意思，有一定难度。首先，它是动态更新且随时查询的，当然不能<b>排序</b>。其次，你不能把以前的数据<b>丢掉</b>，因为新来的数据不知道大小，你丢了就没法比较，也没法确定中位数了。那么关键就是怎么添加，怎么存了。最后想出来一个比较好理解的方法，<b>两个堆</b>。一个<b>最大堆存小的一半</b>，一个<b>最小堆存大的一半</b>。剩下不多说了。查询代价是O(1)，添加代价是O(logn)。看了下当年代码，怎么用的是map，奇怪。

<hr>

296 Best Meeting Point

题意：给定一个m x n的01矩阵，1表示人，0表示空地。<b>所有人</b>希望选取<b>一个地点</b>见面，请计算所有人要移动的<b>最小总距离</b>。距离计算采用<b>曼哈顿距离</b>，也就是`|x1-x2|+|y1-y2|`。

难度：hard

解法：付费题。确实有点难，起步能想出很多<b>搜法</b>，但效率好像都不高。因为没有<b>“障碍物”</b>的概念，也就不存在<b>上下左右“绕路”</b>的需求了。那么，思路有了。比如选取(x,y)作为集合点，你算出了总距离是d。请问能不能用<b>O(1)的代价</b>，把(x-1,y)、(x+1,y)、(x,y-1)、(x,y+1)的对应总距离算出来。<b>答案是可以</b>，往下想吧。再具体点说，<b>行距离和列距离是分开算的</b>，互不影响。如果不用曼哈顿距离，问题就完全不同了。

<hr>

297 Serialize and Deserialize Binary Tree

题意：设计一个二叉树的序列化、反序列化方案。

难度：hard

解法：不是算法题，是<b>系统设计题</b>。序列化、反序列化的要求就是两点。一个是<b>编解码的唯一性</b>，要<b>一一对应</b>，这样才能反回来。一个是<b>执行效率要高</b>，实际应用的序列化函数都是<b>要在性能、安全上做极致要求</b>的，毕竟是<b>很底层的函数</b>，不能马虎。这道题的话，给出一种看得懂且效率不错的方案就可以了。我用了个挺土，不算很好的方案。<b>前序遍历，配合“#”表示null</b>来做序列化。前序最直观，第一个元素就是根。

<hr>

298 Binary Tree Longest Consecutive Sequence

题意：给定二叉树，允许从任意点出发<b>向下走</b>。请找出得到的最长连续序列的长度。连续指的是<b>公差为1且递增</b>。

难度：medium

解法：付费题。递归搜索即可。

<hr>

299 Bulls and Cows

题意：玩一个4位猜数游戏。你有一个4位数字，朋友猜一个4位数字，进行比较。如果<b>位置数字都对</b>，称为“A”；如果<b>位置错误但数字对</b>，称为“B”。给定这两个4位数，请返回检查结果。

难度：medium

解法：公牛和奶牛？为什么叫这个名字，应该是习俗了。完全匹配叫bull，数字对但是位置错误叫cow。你玩《辐射4》的话，还会用这个规则开锁。

<hr>

300 Longest Increasing Subsequence

题意：给定数组，求最长<b>严格</b>递增子序列的长度。

难度：medium

解法：这个，也没什么大区别吧。LIS是递增，可以相等。这个就是要求<b>严格递增</b>。还是一样，就是<b>比较时<=和<的区别</b>。

## 0301 - 0400

301 Remove Invalid Parentheses

题意：给定一个小括号序列，允许你通过<b>删除尽量少的字符</b>，使得<b>括号序列匹配</b>。请返回所有可能得到的结果。

难度：hard

解法：要返回所有结果，就不能DP了，需要<b>搜</b>。如果只考虑结果字符串的长度，就是DP。我当时想了一个针对s[i:j+1]子串进行递归搜索，并保存结果的办法（就是<b>记忆化</b>），后来应该是实现得太乱了，最后放弃。后来看了提示，这份代码不是我独立完成的。可见就是<b>同样的思路</b>，<b>代码水平高低</b>也是有天壤之别的。有的人就是能一针见血，三五句话讲清楚。这份代码里的最精妙之处，在于那个<b>反转</b>。

<hr>

302 Smallest Rectangle Enclosing Black Pixels

题意：给定一个用01矩阵表示的图像，1黑0白。已知所有黑点都是连在一起的。给定一个黑点位置，请确定最大的<b>矩形框面积</b>，能覆盖所有黑点。

难度：hard

解法：付费题。没理解为什么是hard，应该<b>直接搜</b>，找到<b>上下左右</b>的最远黑点的<b>坐标边界</b>即可。

<hr>

303 Range Sum Query - Immutable

题意：给定一个数组，值不会变化。请设计一个数据结构，可以随时查询其中<b>任意子数组</b>的和。

难度：easy

解法：水题，<b>前缀和</b>相减。下一问就会让你搞<b>树状数组</b>了。

<hr>

304 Range Sum Query 2D - Immutable

题意：303的变体，这次的固定数组是二维的。求任意的子矩阵和。

难度：medium

解法：思路完全相同，前缀和相减。但这次运算稍微变一下，改为`sm[][] + sm[][] - sm[][] - sm[][]`。<b>图形化思维</b>，想一下。

<hr>

305 Number of Islands II

题意：200的变体。这次从一片m x n水域开始，每次添加1格陆地。请在<b>每次添加后</b>，求出当前的<b>小岛个数</b>。

难度：hard

解法：付费题。有点意思，如果每次都进行完整的搜索，必然浪费时间。第一个思路是考虑相邻关系，比如<b>相邻格子有1</b>，如何如何。没想太明白。第二思路是用<b>并查集</b>，比如<b>相邻格子</b>已经是一个<b>1的连通分量</b>了，那么这个分量的根节点是同一个，把周围邻居里1的根节点都<b>find一下</b>。如果根不同，则<b>进行union操作</b>。每次有效的union，都减少一个岛屿。这个思路可以。看了下当年代码，确实这么做的。

<hr>

306 Additive Number

题意：给定一个<b>整数序列</b>，如果第三个起的<b>每一元素恰好等于前两元素之和</b>，则称为<b>加性序列</b>。将序列所有数拼起来，得到的大数称为“加性数”。请判断一个数是不是加性数。

难度：medium

解法：注意，不是一位数，<b>可能有多位</b>，因此需要<b>递归搜索</b>。除此之外，没什么特别难点。其实用<b>反推</b>的方式，<b>DP</b>也能解决，而且思路不难想。

<hr>

307 Range Sum Query - Mutable

题意：303的变体。这次还是做子数组求和，但数组可以随时变化。

难度：medium

解法：这次数组可以<b>随时变化</b>了，实在想不出什么常规方法，就用<b>树状数组</b>吧。树状数组学名叫<b>Fenwick tree</b>，是一种利用位运算高效进行单查、区间查、单改、区间改的数据结构。有三种主要用法，不能兼得。<b>第一，单改区间查；第二，单查区间改；第三，区间查区间改。</b>其中第三种更难一点，前两种复杂程度完全一样。所有基本操作都是<b>对数时间</b>。虽然在信息学竞赛里，这属于很多人小学就会背的基础东西，在实际工作中则<b>非常罕见</b>，一辈子用不上也正常。因此视为偏难怪比较好。<b>避免使用，但思维值得学习。</b>比这个更难，且功能类似但更强大的，就是<b>线段树</b>了。那个难写得多。

<hr>

308 Range Sum Query 2D - Mutable

题意：303的变体。这次不但数组可以随时变，还是二维数组。求任意子矩阵和。

难度：hard

解法：没得选了，<b>二维树状数组</b>。不用这个我真没办法了。会写一维数组数组的话，二维确实不难。<b>用同样的思维</b>，x、y各搞各的就行。也是单查批改、单改批查、批改批查三种。这题当然选<b>单改批查</b>这种。<b>子矩阵求和</b>的方式是`sm[][] + sm[][] - sm[][] - sm[][]`，只是改用二维树状数组来做这个操作，<b>这个关系是依然成立的</b>。

<hr>

309 Best Time to Buy and Sell Stock with Cooldown

题意：121的变体。你可以进行多次交易，还是不能再在同一时间多次持有。这次额外有1天的交易cd时间。也就是<b>上次卖出和这次买入</b>至少间隔一天。求最大盈利。

难度：medium

解法：还是<b>DP</b>，总体思路不变。只是这次DP往前判断的位置要隔一位。看了下以前写的代码，很奇怪。为什么没用DP，而是写了个看不懂的状态转换。又看了一遍，理解了。怎么说呢，其实以前那份代码里的<b>状态机</b>，可以理解为<b>local、global数组做DP</b>的另一种表达方式。<b>状态机思维</b>是很有用的，比DP这种<b>方方正正的数组式思维</b>更灵活。

<hr>

310 Minimum Height Trees

题意：给定一个以<b>无向图</b>表示的<b>树</b>。请选取一个点作为根，使得整个树的高度最小。返回<b>最小高度</b>。

难度：medium

解法：这题有意思。这种树也称为<b>无根树</b>，指的是我们<b>不指定任何一点为根节点</b>，你可以随便选。想要树尽可能矮，自然选择<b>“靠近中间”</b>的节点。但这个怎么量化呢？另一种思路，是选<b>度数尽量多</b>的节点。但这个能保证树最矮吗？<b>这些直觉都对，但都不够严格。</b>现在做一个假设，如果我们选定两个点u、v，使得uv之间路径是整个树里最长的，那么选一个不论怎么选根节点，得到的树的高度至少是这个长度的一半，对吧？因此，结论就是，<b>搜</b>。搜出这棵树里距离最远的路径(u,v)。<b>你还得搜两次</b>，第一次搜最长，得到两个端点(p,q)；第二次从p出发再搜最长，得到两个端点(p,r)。这个(p,r)就是你要找的(u,v)。这个<b>路径长度的一半</b>（注意奇偶）就是最终答案。<b>讲道理，这题很难了</b>，应该算hard。<b>这个最长路径称为“树的直径”</b>，也是一个有用的概念。

<hr>

311 Sparse Matrix Multiplication

题意：给定稀疏矩阵A和B，求乘积。

难度：medium

解法：付费题。首先，需要<b>线性代数</b>的基础，矩阵乘法。其实没什么特别，按定义来，用<b>稀疏的三元组</b>这种方式来做。

<hr>

312 Burst Balloons

题意：给定n元素的数组nums，表示n个气球的分数。如果你踩破了第i个气球，会得分`nums[i-1]*nums[i]*nums[i+1]`，边界外的情况视为1。允许选择<b>踩全部气球</b>的顺序，问最大得分是多少？

难度：hard

解法：这种问题往往难点在于判断它到底是<b>贪心、DP、搜索</b>还是什么，通常都在这三大类里。想了挺久，最终认为还是DP。DP的状态当然是`nums[i:j+1]`这段的最大得分，但有个<b>依赖项</b>，就是到达这段时，<b>左边界、右边界</b>还有两个从外部输入的值。你不论在`nums[i:j+1]`内部选择什么顺序，最后都要和左边界、右边界两个值相乘。因此用了<b>记忆化搜索</b>的方式。不难写，但是<b>挺难想</b>的。

<hr>

313 Super Ugly Number

题意：264的变体。给定一个质数数组primes，定义“超级丑数”为质因数只有primes中元素的数。请返回第n个超级丑数。

难度：medium

解法：和264思路完全一样，比如primes有k个质数，那就用k个指针。都放入一个<b>最小堆</b>中，每次取<b>最小的一个</b>并把<b>指针前进一步</b>。看了下以前的代码，好像用的是O(nk)的暴力解法。<b>应该用堆的</b>。

<hr>

314 Binary Tree Vertical Order Traversal

题意：给定一个二叉树，返回<b>“垂直遍历”</b>的结果。垂直遍历的定义是优先<b>列顺序从左到右</b>，然后行顺序从上到下。

难度：medium

解法：付费题。方式比较奇怪，但没什么难点。递归的时候随时记录当前位置即可。

<hr>

315 Count of Smaller Numbers After Self

题意：给定一个数组，针对每个元素，求出<b>它之后且小于它</b>的元素个数。

难度：hard

解法：感觉应该用<b>队列或者栈</b>之类的结构，<b>单调性</b>之类的思路。但是，想不出来。以前我是用<b>树状数组+计数统计</b>的方式做的。从右往左，每添加一个元素x，就把那个元素的统计值+1。统计的时候，针对某个元素x，则统计[-INF,x-1]的元素个数，这就需要<b>区间求和</b>。因此树状数组的能力正好满足。这个树状数组要<b>对范围做一下偏移</b>。除此之外，依然想不出什么好办法。评论里说归并排序，没看懂也没想出来。确实hard。

<hr>

316 Remove Duplicate Letters

题意：给定一个只包含a-z的字符串，请进行字母去重，使得结果的字典序最小。

难度：medium

解法：有比较直白的<b>DP</b>做法，但应该是<b>O(n^2)</b>以上的。看数据规模，似乎不可接受。想想<b>贪心策略</b>，如果一次删除能让当前字母变小，那么<b>肯定应该删</b>，因为<b>字典序的排序方式就是贪心的</b>。看了下当年的代码，确实是贪心策略，具体讲来，就是不断往结果里填充字符，<b>且保证没有重复</b>。如果发现<b>当前字符比结果字符更小</b>，就换掉它。但前提是被换掉的字符<b>后面还得出现至少一次</b>，否则这个字符就弄丢了。<b>思路也不简单，挺难想的。</b>难怪我在注释里写了，我自己的代码太烂了，虽然思路是贪心，但就是写不清楚。

<hr>

317 Shortest Distance from All Buildings

题意：296的变体。给定一个m x n二维矩阵，0表示空地、1表示房子、2表示墙。你需要选一处空地建造一个中转站，使得<b>到所有房子的总距离</b>最短。由于存在障碍物，距离计算以<b>上下左右</b>移动的<b>最短路径</b>为准。

难度：hard

解法：付费题。变体，且这次真的有<b>障碍物</b>了，因此不能用简单的<b>曼哈顿距离</b>来算。最直白的思路，当然<b>枚举每个空地作为起点，进行BFS</b>，找到到达所有房子的最短距离，加起来。这样的理论复杂度就是O(mn*mn)，四次方了。这题的数据规模已经看不到了（要氪金），但我记得有个条件，是<b>房子的数量不会很多</b>，但空地可能很多。因此反其道而行之，<b>以房子作为搜索起点</b>。搞定了。做BFS时，注意不要搞混两个概念：搜n次和<b>搜1次但同时用n个起点</b>，这是两码事。

<hr>

318 Maximum Product of Word Lengths

题意：给定一个词表words，请找出其中两个单词，使得它们<b>没有共同字符</b>，且<b>长度的乘积最大</b>。返回最大乘积，如果不存在则返回0。

难度：medium

解法：其实是两件独立的是。第一，没有共同字符；第二，长度乘积最大。第一件事，其实可以在O(n)时间做完。因为只有26个字母，可以用<b>位操作</b>来表示是否存在某个字符。没错，就是用`(1<<26)-1`表示26个1，作为<b>掩码</b>。出现了就置1，否则就置0。那么两个掩码如果做<b>按位与</b>，结果是0就表示<b>没有共同字符</b>。第二件事，枚举就行了。总体上略麻烦，但没有难度。

<hr>

319 Bulb Switcher

题意：给定n盏灯，编号1-n，开始都是关的。在第i轮（从1开始），你把所有<b>i的倍数的灯</b>按一下。如此进行n轮，请问最后有多少灯是亮的。

难度：medium

解法：<b>神一般的脑洞题</b>，其实是非常巧妙的<b>数学脑筋急转弯</b>。可以直接模拟，没问题。但也可以仔细想想，一盏灯如果最后亮了，表示被按了奇数次。那么什么情况会被按呢？就是<b>当i是它的约数</b>，它就被按一次。那<b>什么数的约数是奇数个</b>呢？你想想一个数`x=p*q`，pq不相等，总是两个，只有pq相等才是一个。因此，<b>完全平方数</b>。那1-n有<b>多少个完全平方数</b>呢？根号n，向下取整。

<hr>

320 Generalized Abbreviation

题意：给定一个单词word，返回所有缩写。缩写可以是任意一部分变为长度表示。比如“word”可以变为“w1rd”、“w2d”、“2rd”、“4”等等。

难度：medium

解法：付费题。<b>好无聊</b>的一道题，搜+枚举即可。

<hr>

321 Create Maximum Number

题意：给定两个数组nums1、nums2，元素都在0-9范围。允许你从两数组中<b>依次</b>选出k个数子，组成一个大数。注意，依次的意思是<b>同一数组内的先后次序</b>不能改变。请返回能得到的<b>最大的结果</b>。

难度：hard

解法：很容易直觉认为这是<b>贪心</b>的，其实不是。比如两边是`[6,7]`和`[6,0]`，对于6，都一样。那你怎么知道选哪一个呢？如果选了后者，下一步的选择就会得到66，而最佳选择其实是67。因此，不贪心，用<b>DP</b>。题目提示你设计O(n^2)的解法，也很容易想到。以dp[i][j]表示<b>选了i个nums1元素、j个nums2元素的最佳结果</b>。因为结果是个数组，为方便起见，<b>转成了字符串</b>，用于存储和比较。剩下不多说了。这个hard主要体现在<b>要找到DP思路</b>，且<b>处理格式有点麻烦</b>。

<hr>

322 Coin Change

题意：给定一些面值的硬币，每种有<b>无数个</b>。给定一个金额amount，请问最少多少个硬币能凑出这个金额。

难度：medium

解法：<b>完全背包问题</b>。按比较常规的思路应该是<b>开辟O(amount)空间来记录结果</b>，然后执行<b>两层循环O(nc*amount)计算结果</b>。还有一种方法就是每次添加一枚硬币，看能搜到多少个新值。搜到amount了就结束计算。为了效率更高，应该<b>把硬币的面值按降序排列</b>。

<hr>

323 Number of Connected Components in an Undirected Graph

题意：给定无向图，判断连通分量的个数。

难度：medium

解法：付费题。<b>并查集</b>。

<hr>

324 Wiggle Sort II

题意：280的变体。给定一个数组，请调整元素顺序，满足“小大小大小...”的关系。挑战是要求在O(n)时间O(1)空间完成。

难度：medium

解法：我忘了这个<b>变体到底变了什么</b>，好像一模一样。之前用了一个奇怪的quick select方式去找到中位数，然后左右两边的元素进行穿插摆放。这种解法<b>挺难想，也难写</b>。但这样时间是O(n)，空间却不是O(1)的，因为<b>递归的栈代价</b>不能算是O(1)。除此之外，实在想不出效率高，而且好理解的思路了。看了下代码，调用的<b>库函数nth_element也是做快速选择的</b>，一样。

<hr>

325 Maximum Size Subarray Sum Equals k

题意：给定一个数组nums和目标值k，请找出子数组和为k的<b>最长子数组</b>。返回长度。

难度：medium

解法：付费题。这题不难。为了数组尽可能长，那就让<b>左侧尽量靠左</b>。因此用一个哈希表记录前缀和，用`前缀和->首次下标`的映射方式。这样如果<b>当前前缀和为x</b>，你就<b>找x-k是否有记录</b>，有的话，k就找到了。

<hr>

326 Power of Three

题意：给定整数，判断是不是3的幂。

难度：easy

解法：取对数就行了。

<hr>

327 Count of Range Sum

题意：给定数组nums，请问有多少个子数组和在`[lower,upper]`范围内？元素可以取任意int范围内的值。

难度：hard

解法：因为<b>元素可以为负</b>，累加和就没有单调递增的特点了。且数组规模要求在O(n)，至多O(nlogn)时间内完成。现在两步走。第一步，先把这个问题转化成求`[-INF,k]`的个数，令k分别等于upper和lower-1，两个一减。第二步，求这个`[-INF,k]`问题的解。这个符合<b>统计+1、查区间和</b>的做法，因此用<b>树状数组</b>。但因为值可以在整个int范围内，不可能开那么大的数组，因此用一个哈希表，<b>对所有涉及到的值做映射</b>，且保持它们的<b>大小次序不变</b>。映射完成后，用树状数组解决问题。<b>整个过程足够复杂、难想，实现也略麻烦。</b>确实很难的一题。评论区都说<b>一眼看出归并排序</b>，我就是看不出来，没办法。

<hr>

328 Odd Even Linked List

题意：给定链表，把值为奇数的节点放在前，偶数节点放在后。但要求保持两部分的<b>内部顺序不变</b>。

难度：medium

解法：水题，记录两个<b>表头和表尾</b>，一个个节点进行分类。最后拼起来即可。

<hr>

329 Longest Increasing Path in a Matrix

题意：给定m x n矩阵，从任意点出发，在不重复访问格子的情况下，请找出上下左右移动的最长递增路径。返回路径长度。

难度：hard

解法：关键在于<b>要不要搜</b>，是否可以<b>DP解决</b>。答案是可以的。可以按<b>矩阵值的大小</b>把访问的格子<b>降序排列</b>，<b>值越大的越早确定</b>。这个排序策略是<b>贪心</b>的。然后针对每个格子，以`dp[i][j]`表示以(i,j)为起点的最大长度。这样，按<b>从大到小倒序排列</b>就好理解了。按排好的顺序，逐个和<b>周围四个邻居</b>比较并更新dp值即可。所以总思路是<b>贪心+DP</b>。这个hard难在想清楚，代码比较好写。

<hr>

330 Patching Array

题意：给定一个升序排列的正整数数组nums和目标n。允许你通过补充元素，使得从1-n的所有数，都可以通过<b>补充后的nums</b>的某些元素求和得到。问<b>最少补充多少个</b>。

难度：hard

解法：确实hard，想不明白就只能干瞪眼。一旦想明白，发现真的坑人。首先第一个思路是用2^k这种形式的数去补充，因为`{1,2,4,8,...}`这种加起来最紧凑了，什么数都能表示。至今我也无法证明这个思路是错的，但也无法证明它对。实际执行来看，<b>这思路确实是错的</b>。还有另一种思路，<b>贪心</b>，这个就很脑洞了。假设现有集合可以加出1-k所有数，但<b>正好得不到k+1</b>，那应该补充什么？<b>答案是必须补充k+1。</b>补充任何小于k+1的数（比如k），都不如k+1好。想想为什么？想明白了，就知道怎么做了。<b>贪心到底。</b>数学就是这样，没办法。不会的想破头也不会，会的一瞬间就会了。

<hr>

331 Verify Preorder Serialization of a Binary Tree

题意：给定一个用逗号分隔、用“#”表示null的字符串，用于表示一棵二叉树的前序遍历的<b>序列化结果</b>，请验证这个结果是否合法。

难度：medium

解法：就按照<b>二叉树</b>和<b>前序遍历</b>的规则检查即可。

<hr>

332 Reconstruct Itinerary

题意：给定一些机票，每张有<b>起点终点</b>，请安排整个行程，使得每张机票恰好使用掉。如果有多种排法，请返回字典序最小的一个。结果按<b>访问路径</b>的格式返回。

难度：

解法：不知为何，这个范围的hard特别多。这题的题目都看不懂，读了两三遍才明白。这题考察的是<b>欧拉路径</b>，对每条边恰好访问一次。有个专门的<b>Hierholtzer算法</b>用来处理欧拉路径，但当年我完全没听过。这题就是用的土办法，<b>搜索+回溯</b>、<b>统计边数</b>并给<b>每条边加一个计数</b>来避免重复访问。这办法也是可以的，总归效率都是O(E)。至于题目要求的<b>字典序最小</b>，在建图时，让边按字典序排列就行了。挺累人的一题。

<hr>

333 Largest BST Subtree

题意：给定一个二叉树，请返回其中满足<b>二叉搜索树</b>要求的最大子树。返回<b>节点数</b>。

难度：medium

解法：付费题。<b>递归执行</b>检查BST有效性的逻辑即可。

<hr>

334 Increasing Triplet Subsequence

题意：给定一个数组，求是否存在<b>先后次序</b>的三元组(i,j,k)，使得对应元素也是严格递增的？挑战是O(n)时间O(1)空间。

难度：medium

解法：想想<b>LIS问题的O(nlogn)解法</b>。总是保持一个<b>递增的数组</b>，并不断替换里的值，<b>越换越小</b>。这次你只需要保持一个<b>长度为2的</b>这样的数组。其实就是x1、x2两个变量。用相同的逻辑不断更新x1、x2，如果你发现当前的x大于x2那就成功了。如果始终小于等于x2，则失败。

<hr>

335 Self Crossing

题意：你从(0,0)出发，按照<b>上左下右</b>的顺序不断改变方向，在每个方向都<b>前进一段距离</b>。这样会画出一条<b>轨迹</b>，请判断这个轨迹里的<b>折线是否存在相交</b>。

难度：hard

解法：几何题，挺难想的。想了10分钟，毫无思路。看了下当年的代码，当年也毫无思路。<b>完败。</b>其实要说完全没思路也不至于。它这个轨迹是在转圈圈，要想<b>不相交</b>，这个圈圈就必须像螺旋一样<b>不断往小范围走</b>，在x和y方向都是如此。因此可以判断每次移动是否<b>导致x或者y的范围重新扩大了</b>，如果扩大了，肯定相交。这就是思路。有意思，你想相交的情况很复杂，想<b>不相交</b>的情况就<b>很简单</b>。

<hr>

336 Palindrome Pairs

题意：给定一个词表，其中单词各不相同。允许你选两个词拼接，使得结果是<b>回文串</b>，称为一个<b>回文对</b>。请返回给定词表的<b>所有回文对</b>，每一对用(i,j)下标表示。挑战是要求<b>线性时间</b>完成，线性指的是所有单词的总长度。

难度：hard

解法：怎么全是hard，服了。多年后重新看这题，想了一个<b>反转字符串</b>，然后<b>全放到一起排序</b>的方法。好像可以，又好像不行。当然这个已经不是O(n)了，放弃。之前用的还是<b>滚动哈希</b>，提升匹配效率的办法。另外还写了一个暴力解法，居然也过了。

<hr>

337 House Robber III

题意：198的变体。这次房屋不是线性排列，而是按二叉树结构组织了。这次小偷从<b>根节点</b>出发，不能在<b>相邻（父子）</b>房子偷东西。求最大获利。

难度：medium

解法：思路不变，就是形式变了。<b>线性DP</b>改成<b>树搜索</b>。用local、global来记录局部、全局最优结果，<b>交替更新</b>。

<hr>

338 Counting Bits

题意：给定自然数n，请求出`[0,n]`所有数的二进制表示中1的个数。要求O(n)时间完成。

难度：easy

解法：有点巧妙，但还在easy范围内。其实就是位运算<b>`x&x-1`</b>，这样可以O(1)代价计算出x的二进制1的个数。

<hr>

339 Nested List Weight Sum

题意：给定一个<b>嵌套数组</b>，元素可能是数，也可能是嵌套数组。求所有元素的和。

难度：easy

解法：付费题。<b>递归</b>定义，就递归求和。

<hr>

340 Longest Substring with At Most K Distinct Characters

题意：给定字符串，请求出<b>至多包含k种不同字符</b>的<b>最长子串</b>的长度。

难度：hard

解法：付费题。非常典型的<b>滑动窗口+统计个数</b>的题目。后面还有七八个类似题目。这种题目要么<b>判断true or false</b>，要么<b>求和</b>，要么求<b>最大最小值</b>。几乎都在这些范畴内。

<hr>

341 Flatten Nested List Iterator

题意：给定一个<b>嵌套数组</b>，元素可能是数，也可能是嵌套数组。请设计一个<b>迭代器</b>，用于<b>依次嵌套访问</b>这个数组，效果等同于将整个数组展开成一维。

难度：medium

解法：既然不是一次性访问完整个数组，那就<b>保持一个栈</b>，来处理嵌套的情况。每嵌套一层，就入栈；每完成了当前层访问，就出栈。

<hr>

342 Power of Four

题意：给定一个整数，判断是不是4的幂。

难度：easy

解法：水题。

<hr>

343 Integer Break

题意：给定正整数n，请将其拆分为<b>至少两个数的和</b>，使得<b>这些数的乘积最大</b>。返回最大乘积。

难度：medium

解法：这些数应该越均匀越好。因为乘积很快就爆了，所以数据规模只会<b>非常非常小</b>。因此，随便怎么做都行。思路就是<b>DP</b>。

<hr>

344 Reverse String

题意：反转字符串，<b>就地完成</b>。

难度：easy

解法：交换。

<hr>

345 Reverse Vowels of a String

题意：给定字符串，只反转所有元音aeiou。

难度：easy

解法：还是交换。

<hr>

346 Moving Average from Data Stream

题意：给定一个不断输入的数据源，请在每次添加元素时，求平均值。

难度：easy

解法：付费题。水题，<b>求和相除</b>即可。

<hr>

347 Top K Frequent Elements

题意：给定数组，请求出<b>出现频率前k大</b>的元素。

难度：medium

解法：直白解法，当然是统计、按频率排序、返回。这样的复杂度是`O(n)+O(nlogn)=O(nlogn)`。因此题目挑战是比这个要好才行。还有一种方法，就是用一个TreeMap保持有序，以频率数为键值，用`频率数->频率等于该值的元素列表`。这样能<b>快速找到前k大</b>。每次添加一个元素，都对应更新统计。这种反过来的映射方式，代码稍微麻烦点，效率也略高一点。但其实最坏情况，依然是O(nlogn)的，并不能算优秀。因此我最终放弃了，还是写了个<b>常规的统计+排序的解法</b>。

<hr>

348 Design Tic-Tac-Toe

题意：tic-tac-toe是一种<b>简化版的五子棋游戏</b>。3x3的棋盘上，两人轮流画xo。能首先连成长度为3的<b>横、竖或正反对角线</b>，就算赢。请设计数据结构，走这种棋，并在每一步返回当前赢家。

难度：medium

解法：付费题。纯<b>模拟题</b>，规则非常具体了，实现即可。

<hr>

349 Intersection of Two Arrays

题意：给定两个数组，求交集元素，要求去重。

难度：easy

解法：就是<b>集合求交</b>。用`return list(set(nums1) & set(nums2))`就搞定了。如果说不准用set之类的，那就另说吧。

<hr>

350 Intersection of Two Arrays II

题意：349的变体。数组求交，但这次要求在交集中保留共同元素的相应个数。

难度：easy

解法：这次不是一句话搞定了。当然，用类似python里的Counter类，其实也可以一句话搞定，`return list(Counter(nums1) & Counter(nums2))`。但这用到了较为复杂的工具类，有点取巧了。思路就是计数，取较小值，然后转回数组。

<hr>

351 Android Unlock Patterns

题意：安置的3x3手势解锁。给定一个用数字序列表示的手势，请判断是否合法。合法的规则包括：长度要介于m和n之间；数字不能重复使用；数字顺序不可调换；如果手势<b>越过了</b>某个数字，这个数字必须之前已经使用过。

难度：medium

解法：付费题。<b>挺费劲</b>的模拟题。没什么算法，就是按规则实现。

<hr>

352 Data Stream as Disjoint Intervals

题意：给定一个不断输入的数据源，设计一个数据结构，支持随时<b>添加数</b>和<b>统计区间</b>两个功能。统计区间是把所有已添加的数，统计成一个个<b>不相交的区间</b>，并返回区间列表。

难度：hard

解法：这种统计区间的操作，其实之前题目就做过。用哈希表，<b>两个哈希表</b>。<b>一个记头，一个记尾。</b>这样每个区间是否要扩张、合并之类的，都可以在O(1)时间找到，并进行处理。整个思路虽然不难，但<b>代码写出来还挺复杂的</b>，因此题目是hard。

<hr>

353 Design Snake Game

题意：<b>贪吃蛇</b>游戏玩过吧？从(0,0)位置，以长度1开始，执行移动并吃掉一个个的食物。食物的位置在初始化时给出。请设计数据结构，支持贪吃蛇的移动。如果蛇身发生碰撞，则游戏结束。在每次移动或者吃掉食物时，更新状态，并判断游戏是否结束。

难度：medium

解法：付费题。模拟题，经典的老游戏。按规则实现即可。贪吃蛇的身体用什么表示最合适？当然是<b>链表</b>了，而且要<b>像履带车一样，滚动前进</b>。还有一点，要保证每次判断蛇身是否碰撞，<b>检查效率必须是O(1)</b>。这个<b>用一个集合</b>判断很容易做到，不断更新不断检查。

<hr>

354 Russian Doll Envelopes

题意：俄罗斯套娃，大的套小的。给定一些信封，每个给出长w和宽h。如果一个信封的<b>长宽都大于另一个</b>，则可以<b>套进去</b>。请问最多能套多少层信封？

难度：hard

解法：很经典的一道题，练习<b>问题的规约转化能力</b>。按照(w,h)元组的顺序升序排列，这样w是升序的，h维度则进行LIS问题，求<b>最长递增子序列</b>。此处<b>有一个小技巧</b>，就是w升序，h则按降序。想想为什么？

<hr>

355 Design Twitter

题意：设计一个最简版的Twitter，可以发推，可以关注、取关用户，还可以看用户最近的10条推。

难度：medium

解法：模拟题，还挺费劲的。不过需求都很明确，用什么工具实现也不难想。最近的10条推，确保能<b>高效取到</b>。

<hr>

356 Line Reflection

题意：给定二维平面上的一些点，请问是否存在一条平行y轴的直线，使得这些点恰好关于这条线对称？

难度：medium

解法：付费题。一道<b>几何题</b>，需要一点图形思维。既然是竖线，要关于它对称，那这些点的<b>左右分布一定是成双成对</b>的。可以对y坐标进行统计，同y的归为一组。每一组找一下<b>对称点</b>。如果一组内就不对称，则返回false。如果每组都对称，但对称位置不同，也返回false。<b>只有全部对称，且对称位置都相同</b>，才算对称。

<hr>

357 Count Numbers with Unique Digits

题意：给定自然数n，请求出所有`[0,10^n]之前的数里，<b>数位不存在重复的数</b>的个数。

难度：medium

解法：n非常小，直接<b>暴力搜索</b>当然是可以的。不过，用位运算，比如一个`(1<<n)-1`以内的掩码，来表示哪些数字已经用过了，也可以。不过这样就是方法奇怪一点，本质还是搜。所以，<b>搜吧</b>。还有一种思路，因为数位各不重复，那为什么不做一下<b>排列组合</b>呢？这个应该是<b>排列</b>，类似`A(n,k)`这种。这样的话，效率就高多了。

<hr>

358 Rearrange String k Distance Apart

题意：给定一个字符串，请调整字符顺序，使得<b>相同字符之间的距离</b>至少是k。返回调整后的结果，如果无法满足，则返回空串。

难度：hard

解法：付费题。第一念头，还是判断<b>贪心还是DP</b>。DP倒是没想出思路，贪心的话，如果我总是取<b>当前存量最多的字符</b>，是不是结果一定有效？<b>如果这样都无效</b>，那就无法满足。那思路就是一个最大堆，每次都取当前库存最多的字符，<b>取一个</b>。问题是有个<b>间隔至少是k的要求</b>，那就加一个结构来记录cd，冷却时间到了再放入堆中。看了下当年的代码，总体思路是这样的。确实用了cd的思维，但没有用堆。那应该是<b>直接枚举26个字母了</b>。所以，这个题<b>可以贪心</b>。

<hr>

359 Logger Rate Limiter

题意：给定一个日志对象，有一些日志消息和对应时间戳。如果该消息在时间戳的前10秒内已经输出过了，则跳过。

难度：easy

解法：付费题。用一个哈希记录一下最近的时间记录即可。其实这个就是带<b>过期机制</b>的哈希表。缓存嘛，<b>不过期还叫缓存吗</b>？

<hr>

360 Sort Transformed Array

题意：给定一个有序数组，请对每个元素执行一个函数`f(x)=ax^2+bx+c`。返回<b>变换后且排好序</b>的数组，要求在O(n)时间完成。

难度：medium

解法：付费题。一道初中数学题，利用了<b>抛物线</b>的对称性和导数特点。找到中点`-b/2a`，那么函数值在此处最小。其他的函数值，肯定是<b>离它越远就越大（a为负的话就是越小）</b>。题目要求O(n)时间完成，那就从中点位置，左右两个指针分开走即可。

<hr>

361 Bomb Enemy

题意：炸弹人游戏。给定一个m x n矩阵表示当前地图，<b>W表示墙、E表示敌人、0表示空地</b>。你可以在空地放一个炸弹，炸弹会攻击所在的<b>整行和整列</b>，直到<b>被墙拦住</b>。请问一个炸弹最多能消灭几个敌人？

难度：medium

解法：付费题。直观思路是每个点，上下左右一直走，走到不能走为止，统计敌人个数。那么上下方向，左右方向，肯定可以<b>省去一些重复计算</b>。比如我往下走了一步，那我上面、下面统计的结果，<b>稍微变一下就可以了，这是O(1)代价</b>。因此可以在枚举每个空格的时候，省掉重复计算。此外，<b>行和列也是相互独立的</b>，统计时各做各的。

<hr>

362 Design Hit Counter

题意：设计一个访问计数器，返回以特定时间点为止的过去5分钟的访问次数。

难度：medium

解法：付费题。需求很明确，统计+窗口查询求和。窗口的大小是300秒。统计当然可以用一个TreeMap，既能增删，进行窗口查询时，也可以快速定位到窗口的边界。但<b>求和操作还是要做的</b>。题目还进行了扩展，问如果某些时间段访问非常高频，怎么办。那就设计冷热策略，冷的时候<b>延迟更新、批处理或者缓存结果</b>，热的时候对数据做一下<b>精度牺牲</b>，使得map里的<b>key个数不会疯狂增长</b>，让这些超级密集的访问记录<b>归到一起去</b>。所以这其实是个<b>系统设计题</b>。

<hr>

363 Max Sum of Rectangle No Larger Than K

题意：给定一个m x n矩阵，请找出<b>子矩阵和不超过k</b>的最大值。

难度：hard

解法：这个hard主要在于你可能<b>发散出各种想法</b>，有的行不通，有的很难搞。题目告诉你复杂度是O(n^3)，因此想想<b>怎么分配这三维</b>。可以用<b>两维来枚举上下边界</b>，剩下一维用<b>滑动窗口最大子数组和</b>搞定。如果考虑<b>子矩阵的前缀和计算</b>之类的，就搞不出来了。看了下当年的代码，求子数组和用的不是滑动窗口。不过<b>最终目的是一样的</b>，无所谓。

<hr>

364 Nested List Weight Sum II

题意：339的变体。还是嵌套数组，这次给嵌套层数定义一个<b>“深度”</b>概念。每嵌套一层，深度+1，从1开始。请求出<b>按深度加权</b>的元素和。

难度：medium

解法：付费题。本身做法就是递归，现在给递归时<b>传入深度作为参数</b>即可。

<hr>

365 Water and Jug Problem

题意：给定两个水瓶，容量为x和y。允许你<b>灌满、倒空、从一个倒入另一个</b>这三种操作，请问能否得到z量的水？

难度：medium

解法：著名的灌水问题，经典<b>智力题</b>之一。判断x和y的<b>最大公约数</b>g，如果z不是g的倍数，则不可能得到。比如3和5两个瓶子，你可以得到任何量的水。左右倒来倒去，倒满，倒空。想想怎么得到1？注意<b>特殊情况</b>，比如一个瓶子是0，还有两个瓶子一样大。如果`z>x+y`，也不行，因为你没有额外空间存水了。

<hr>

366 Find Leaves of Binary Tree

题意：给定二叉树，不断的去掉叶节点。<b>每一轮</b>去掉叶节点，保存在<b>一个数组中</b>。依次返回所有数组。

难度：medium

解法：付费题。<b>递归处理</b>，避免重复计算。难点是怎么确定<b>当前节点</b>是在<b>第几轮</b>被删掉的？需要知道这个，才能确定它应该放在最终结果的第几个数组里。其实很简单，并不是真的删，而是取`max(左孩子轮数, 右孩子轮数)+1`即可。递归的终点，是<b>真正的叶节点，轮数=1</b>。知道轮数了，放到结果里，对应的那个数组就行了。

<hr>

367 Valid Perfect Square

题意：给定整数，判断是不是完全平方数。不能用库函数。

难度：easy

解法：还是求平方根，那就手写一个二分来求平方根。

<hr>

368 Largest Divisible Subset

题意：给定一个整数集合，请返回一个长度最大的集合，使得集合中的任意两数都存在<b>倍数/约数关系</b>。

难度：medium

解法：首先<b>排序</b>。<b>倍数关系是传递的</b>，a是b倍数，b是c倍数，则a也是c倍数。有这个就可以找到<b>子问题</b>，做<b>DP</b>了。这个要返回具体结果，所有在<b>DP求最大长度</b>的同时，还要记录好<b>回溯位置</b>，用于拼装最后结果。

<hr>

369 Plus One Linked List

题意：给定一个单链表表示的大数，每个数位是一个节点。请对齐做“+1”操作。

难度：medium

解法：付费题。第一种思路，<b>反转，加一，处理进位，转回来</b>。这么做麻烦了。第二种思路，往前走找到<b>最后一个小于9的位置</b>，后面全是9。那么+1后，后面都是0，该位置进位+1。如果整个链表全是9，那就进位出一个新的表头，值为1。这种更高效。

<hr>

370 Range Addition

题意：给定一个长度为n初始全0的数组。每次允许你对某个区间`[i,j]`的所有元素+x。执行一系列操作后，请返回整个数组的值。

难度：medium

解法：付费题。这是树状数组的另一种功能，<b>批改单查</b>。但因为操作是一口气做完的，<b>没有边改边查的需求</b>，因此<b>不用树状数组</b>也可以。用普通数组，单个修改，然后<b>从后往前累加</b>即可。注意把每次`[i,j,x]`的修改，转化为`[0,i-1,-x]`和`[0,j,x]`两个操作。

<hr>

371 Sum of Two Integers

题意：给定两个整数a、b，求a+b，但是不准用+-运算。

难度：medium

解法：那就用位运算实现<b>加法器</b>，这题其实就考察这个。`s=a^b; c=(a&b)<<1;`，这是一步，不断执行这步，直到s和c没有交集为止。这题需要前置知识，<b>数字电路</b>的基础。没学过的话，凭想象力不可能想到这种点子。

<hr>

372 Super Pow

题意：给定整数a和b，求`pow(a,b)%1337`。已知b可能非常大。

难度：medium

解法：<b>快速幂</b>，二分即可。

<hr>

373 Find K Pairs with Smallest Sums

题意：给定两个升序排列的数组nums1、nums2，从两数组各选一个元素，组成<b>数对</b>。请找出<b>两元素和前k小</b>的数对。

难度：medium

解法：进行BFS，从(0,0)位置开始搜，每次取出<b>当前最小且未访问的数对</b>。所以用一个<b>最小堆</b>作为工具比较合适。当年用C++写的这些代码，长得都太奇怪了。用python写的话，真的十行就搞定了。

<hr>

374 Guess Number Higher or Lower

题意：猜数游戏，我心里有一个数，你猜，我告诉你“低了”或者“高了”。现在给定一个<b>guess()函数</b>，你可以调用来猜数，并得到高低的判断。请设计策略，用<b>最少的次数猜中</b>。最后返回<b>猜中的数</b>。

难度：easy

解法：二分。

<hr>

375 Guess Number Higher or Lower II

题意：374的变体。还是猜数游戏，我从1-n中选一个数。每次你<b>猜错，都要损失x的钱</b>，如果钱输光了，游戏失败。请问你需要带多少钱，才能<b>保证一定能赢</b>？

难度：medium

解法：第一念头还是二分。但仔细一样，不对，<b>没那么简单</b>。二分确实是<b>好策略，稳策略</b>，但不一定对任何情况都是最优。所以，考虑用DP思路解决。DP的解法不太好像，用`dp[i][j]`表示当前可能范围是`[i,j]`的<b>最大猜数次数的最小值</b>。注意，凡是这种“最大的最小”、“最小的最大”，都是很烧脑的，要格外小心。这种称为<b>minimax</b>问题。接下来就是一层循环，从i、j中间的某个k点，找最优解了。所以这个DP是O(n^3)规模的，<b>而且很难想</b>。我觉得这个足够hard难度了，不止medium。

<hr>

376 Wiggle Subsequence

题意：一个摇摆子序列的定义是，从数组中选出一个子序列，使得相邻元素之差在<b>正负来回变动</b>，且<b>都不为0</b>。请找出最长摇摆子序列。

难度：medium

解法：它既然是“正负正”或者“负正负”，总归是交替着来。那可以用<b>两个交叉进行的DP</b>来处理。用dp_pos、dp_neg表示两条线，dp_pos[i]表示以nums[i]结尾，最后一个差值为正的最优解。那么dp_pos[i]的计算，就要依赖dp_neg[k]，k从{0,1,...,i-1}里去枚举，反之亦然。这样就在正负之间不断交替计算，<b>总复杂度是O(n^2)</b>。结果我看了下当年的代码，<b>直接贪心O(n)搞定了</b>，看来并不用DP。贪心做法是，先做<b>连续元素的去重</b>，然后碰见<b>“小大小”、“大小大”</b>就结果+1，就这么简单。

<hr>

377 Combination Sum IV

题意：39的变体。给定无重复的数组和目标值target。请求出nums中元素加起来等于target的不同组合<b>个数</b>。每个元素可以<b>重复用任意次</b>。

难度：medium

解法：<b>背包问题，完全背包</b>。就用背包的标准解法即可。注意，01背包是<b>从后往前</b>加；完全背包是<b>从前往后加</b>；多重背包则是01背包的变体。

<hr>

378 Kth Smallest Element in a Sorted Matrix

题意：给定一个<b>Young tableau</b>，每行往右、每列往下都是升序。请找出所有元素排序后，第k小的元素。

难度：medium

解法：最直接的方法是排序，然后拿第k个，复杂度是O(n^2logn)。第一个思路，是用n个指针指向<b>n行的行首</b>，放入<b>最小堆</b>中。每取一个最小值，就把对应指针前进一步。这样直到取出第k个元素。总复杂度是O(klogn)，因为k最大也是n^2，所以<b>最坏复杂度和暴力算法一样</b>。所以这思路不能算优秀。第二个思路，是<b>写这个题解时刚想出来的</b>。反其道而行之，考虑给定一个值x，<b>矩阵中有多少元素小于等于x</b>。这就相当于它在矩阵中排多少位。这个判断的代价是O(nlogn)，每行一个logn总共n行。这样的一次试探，是为了从`[low,high]`范围，逐渐二分缩小，找到一个精确的值x，使得得到的<b>个数恰好是k-1</b>（那它就是第k个了）。这样总共要试探O(log(high-low))次，上下界是矩阵的最大值、最小值。所以总的复杂度是O(nlogn*log(max(nums)-min(nums)))。不想找最大最小值的话，你甚至可以用INT_MIN、INT_MAX来代替。看了下评论区，果然很多人也想到<b>二分</b>的方法了，和我描述的这个一模一样。

<hr>

379 Design Phone Directory

题意：设计一个号码分配器。支持分配号码、释放号码、查询号码是否占用。

难度：medium

解法：付费题。这个好像难点在于数据范围会非常大。用<b>位向量或者其他密集存储</b>的话，空间不够。所以还是用<b>区间存储</b>的办法。分配就是<b>添加</b>，释放就是<b>删除</b>。检查占用，则需要比较高效的<b>区间查询</b>。看了下以前的代码，我既用了<b>哈希表</b>记录每个号码，也用了<b>区间段</b>来记录连续的号码段。

<hr>

380 Insert Delete GetRandom O(1)

题意：设计一个特殊的<b>集合</b>，支持常规集合的增删操作，同时支持<b>等概率随机返回</b>一个元素的功能。要求所有基础操作做到<b>O(1)或者均摊O(1)</b>的效率。

难度：medium

解法：集合不能像数组一样<b>用下标位置访问</b>，所以不能用`rand()%n`的方法随便选一个位置。其实，稍微<b>耍个小聪明</b>就行了。数组可以随机访问，集合可以判重，那我就在两者之间建立映射。元素在<b>数组里</b>存一份，在<b>集合里</b>（此处实际用了哈希表）也存一份，两者做`值->下标`的映射就行了。因为是集合，值是不能重复的，因此<b>这个映射总是一对一</b>。增，简单。随机，简单。删，怎么办？其实也不难，把要删的元素<b>交换到数组末尾</b>，然后pop就行了。交换和pop都是O(1)操作，搞定。这是集合，<b>顺序无所谓，所以随便换</b>。

<hr>

381 Insert Delete GetRandom O(1) - Duplicates allowed

题意：380的变体。这次允许有重复元素了。还是实现和380相同的功能。

难度：hard

解法：在380的基础上，总体思路完全相同。如果有重复元素，那`值->下标`的映射就变成了`值->[下标列表]`的映射。随机操作仍然作用在数组上，完全不变。<b>删除操作</b>里的<b>“交换”</b>部分也一样，只是<b>更新映射</b>的操作变了一下，形式上的小变化，并不难。`vector`依然是`vector`，`unordered_map<int, int>`则变成了`unordered_map<int, unordered_set<int>>`。

<hr>

382 Linked List Random Node

题意：给定一个<b>不知道多长</b>的链表的表头，以均等概率随机返回一个节点。

难度：medium

解法：首先复杂度当然是O(n)的，链表没什么特点，你不可能不看一个元素就跳过它。题目提示了，不要计算<b>链表长度</b>，也不要用额外空间。这就是<b>水库采样</b>算法了。概率推导是严格的，<b>可证明</b>这样的抽样确实<b>机会均等</b>。水库采样，尤其<b>n取1情况</b>的思路，是在第i个元素时，以`1/i`的概率，用第i元素<b>替换当前样本</b>。这样想要第i元素一直<b>保持到最后</b>，需要的概率是`1/i*i/(i+1)*(i+1)/(i+2)*...*(n-1)n`，也就是`1/n`。因此所有元素被抽到的概率都是`1/n`，均等。<b>n取k的办法也类似</b>，想想怎么做，替换什么。

<hr>

383 Ransom Note

题意：给定字符串r和m。问r能否通过m中的字母构成。

难度：easy

解法：水题，计数比较一下即可。

<hr>

384 Shuffle an Array

题意：给定数组，设计一个算法进行随机乱序。要求所有可能的排列<b>机会均等</b>。

难度：medium

解法：做法很简单，而且是<b>严格O(n)</b>的。从n个元素开始，每次<b>随机选一个</b>，<b>交换到末尾</b>。这样末尾的元素<b>越来越多</b>，开头的元素<b>越来越少</b>。换n-1次就完成了。难点是数学证明，从概率上证明这n!个排列的概率是完全一样的。或者证明第i个元素落到每个位置的概率都是`1/n`。由于代码很容易实现，<b>数学比较难</b>，这个就不往下想了。有兴趣可以推一下。

<hr>

385 Mini Parser

题意：还是339的<b>嵌套数组</b>。这次输入一个字符串，表示这个嵌套数组的一种序列化格式。请解析并返回这个数组对象，也就是做<b>反序列化</b>。

难度：medium

解法：<b>解析器</b>嘛，那就用<b>栈</b>了，做分词、符号解析，处理一下就行了。

<hr>

386 Lexicographical Numbers

题意：给定正整数n，请将1-n按照字典序排序，并返回结果。但要求在O(n)时间完成。

难度：medium

解法：有意思，要求字典序，但不能<b>转成字符串再排序</b>。比如10xxx，不管后面是几，有多少位，都是小于11的。所以，可以按<b>“字典树”</b>的思维，在这个字典树上进行前序遍历。并不用真的建一棵字典树，走正常的<b>递归搜索</b>即可。另外，这个搜法<b>一定没有重复结果</b>。因为你在字典树上，<b>从根出发往下走</b>，不同路径必然到不了同一节点。它是树，对吧？因此<b>O(n)时间也是必然的</b>。看了下我当年的代码，用了同样思路。而且<b>没递归，迭代就搞定了</b>。不过，这个迭代解法不是严格O(n)的。

<hr>

387 First Unique Character in a String

题意：给定字符串，返回第一个<b>唯一字符</b>的位置。

难度：easy

解法：水题。

<hr>

388 Longest Absolute File Path

题意：给定一个格式化的，用“\n”换行、“\t”缩进的目录树，请求出文件、目录中的<b>最长绝对路径</b>，返回长度。

难度：medium

解法：题目巨长，其实主要要做的是<b>字符串解析和变换</b>。按规则执行即可。没有算法难度，就是<b>费点劲</b>。可以用<b>正则提取</b>来减少代码量。

<hr>

389 Find the Difference

题意：给定字符串s和t，t是通过乱序s，再加一个字母得到的。请找出添加的字符。

难度：easy

解法：水题。

<hr>

390 Elimination Game

题意：有个数组arr，最初其中元素为`[1,2,...,n]`。每次执行一个操作，将第0、2、4、6、...元素删除，收拢剩余元素组成新数组。不断执行这个删除操作，问<b>最后剩余的元素</b>是几？

难度：medium

解法：这题和<b>约瑟夫环</b>有点像，都是<b>数学脑洞题</b>。而且这种问题，你正着推，很可能晕掉。反着推，没准能想清楚。比如我用<b>记忆化搜索</b>的思路，搜索参数为`(序列长度,公差)`。因为不论怎么删，每次删完了依然是个<b>等差数列</b>。比如`[0,1,2,3,4,5]`删完了变成`[1,3,5]`，也就是说`(6,1)`经过一次转换变为`(3,2)+1`，+1是偏移量。因此你在搜的过程中，最关心的就是<b>转换关系</b>，和<b>偏移量</b>。最后必然会变成`(1,x)+y`。此时x我不关心，关心的是y。y就是那个答案。照这个思路，<b>搜吧</b>。看了下当年的代码，<b>大致思路确实如此</b>，但代码看不懂。<b>又看了两遍，大概懂了。</b>

<hr>

391 Perfect Rectangle

题意：二维平面，给定一些<b>和xy轴对齐的矩形</b>的位置。请问这些矩形是否恰好拼成了一个<b>大长方形</b>？要求矩形之间不能有重叠。

难度：hard

解法：如果<b>矩形个数小、坐标范围小</b>，怎么做都行。现在两个值都比较大，就有难度了。想了两个办法，<b>第一个是当年想的</b>。首先，画一个大框框，<b>大框的面积</b>必须等于<b>所有矩形面积之和</b>。其次，这些矩形都有四个点，<b>给这些点统计个数</b>。拼在一起的时候，除了4个角次数为1，其他的次数一定是偶数。<b>这两个判定</b>，足够了。<b>第二种思路是刚想的</b>。首先，总面积的条件不变。其次，可以判断这些矩形是否<b>互不重叠</b>。判定重叠的话，暴力算法是O(n^2)，会超时。可以用<b>先排序</b>，然后<b>x二分、y也二分</b>的方式进行快速检测。这样，排序的代价是O(nlogn)，检测重叠的代价是O(n(logn)^2)，总体还是可接受的。还是第一种好，更巧妙。

<hr>

392 Is Subsequence

题意：给定字符串s和t，判断s是否为t的子序列。

难度：easy

解法：水题，贪心即可。

<hr>

393 UTF-8 Validation

题意：按题目要求，校验一个<b>字节数组</b>是否为有效的UTF-8序列。

难度：medium

解法：<b>非常具体的模拟题</b>，照做吧。

<hr>

394 Decode String

题意：给定一个用<b>游程码</b>编码的字符串，请对其<b>解码</b>。

难度：medium

解法：字符串解析题。

<hr>

395 Longest Substring with At Least K Repeating Characters

题意：给定一个字符串s，请找出<b>最长子串ss</b>，使得ss中的字母的频率都不小于k。返回ss长度。

难度：medium

解法：这个类型的题目，很容易让人一眼觉得是<b>滑动窗口</b>。很遗憾，这个不是。想了10分钟没有好思路，看了下当年的代码，发现用了一种比较难懂的思路。做<b>分治法，递归搜索</b>。现在依然觉得很难懂。大致的思路，就是给定一段子串`s[i:j+1]`，先统计一下字符频率，然后把频率低于k的，视为<b>“无用字符”</b>。那么我<b>接下来递归</b>，总是找<b>首尾都是“有用字符”的子串</b>继续往里搜。如果<b>当前子串没有无用字符</b>，那这个串就符合要求了。这复杂度应该是<b>O(n^2)</b>，照理说是应该超时的。但考虑到判断条件比较苛刻，也<b>相当于剪枝了</b>，因此效率勉强可接受。<b>挺难的，这题。</b>

<hr>

396 Rotate Function

题意：给定数组a，定义一个旋转函数f。如果把a循环右移i位，得到a_i，那么a_0就是a本身。`f(i)=0*a_i[0]+1*a_i[1]+...+(n-1)*a_i[n-1]`。请求出f(0)、f(1)、...、f(n-1)的最大值。

难度：medium

解法：不知道这函数有没有什么<b>专有名称</b>。回到问题本身，先用O(n)代价算出f(0)，然后考虑f(i)和f(i+1)的</b>递推关系</b>即可。推一下，<b>后面的计算</b>都是O(1)完成，因此总时间还是O(n)。

<hr>

397 Integer Replacement

题意：给定一个正整数n，如果是偶数则除以2，如果是奇数则+1或者-1。请问最少经过多少次变换，能变为1？

难度：medium

解法：从n开始，<b>记忆化搜索</b>即可。在python里甚至只需要加个`@cache`装饰器就行了。

<hr>

398 Random Pick Index

题意：给定一个<b>可能有重复元素</b>的数组，请设计功能，使得传入数组中某个元素值target，随机返回一个值为target的<b>元素的位置</b>。

难度：medium

解法：把元素的<b>下标都统计好</b>就行了，做个`值->[下标列表]`的映射即可。数组并不会变化，所以逻辑很简单。看了下当年的代码，怎么写了个O(n)的解法，太慢了。应该做到O(1)才行。补了一个O(1)的，提交了。

<hr>

399 Evaluate Division

题意：给定一些符号，类似abcd这样。给定一些<b>除法关系</b>，比如a/b=3.0、b/c=1.5等等。现在请计算另一些除法的结果。

难度：medium

解法：在精度不是很严格的情况下，就把<b>某个符号的值设为1.0</b>，算其他所有符号的值就行了。既然<b>参考系可以任选</b>，那就选一个然后<b>锚定它</b>。看了下当年的代码，用到了并查集，看起来很复杂。应该是上面那句话有问题，“某个符号的值设为1.0”，不一定是一个。因为这些符号可能不构成一个连通分量，而是<b>存在多个</b>。因此需要锚定的个数，等于连同分量的个数。<b>难怪会用并查集。</b>

<hr>

400 Nth Digit

题意：给定一个无限序列，这个序列由1,2,3,...按数位全部拼接而成。请问这个序列的第k位是几？

难度：medium

解法：算起来有点费脑，但思路并不难的一题。数位动归，总之就是诸如<b>“i位数总共多少个xxx”、“i位数的第j位总共有多少xxx”</b>这样的计算。这确实是<b>DP思维</b>，所以叫它<b>“数位动归”</b>。细节不说了，说清楚比写代码还费劲。

## 0401 - 0500

401 Binary Watch

题意：给定一个h:mm格式的时钟，现在告诉你h和mm的二进制总共有多少个1，请返回所有可能的对应时间。

难度：easy

解法：水题，搜索或者<b>预计算结果</b>并打表都可以。

<hr>

402 Remove K Digits

题意：给定一个字符串表示的<b>大数</b>，请从中删除k位数字，使得剩余结果最小。

难度：medium

解法：首先，贪心还是DP？考虑删不删当前位，主要的比较依据，还是<b>它是否比下一位大</b>。如果前者比后者大，那删掉之后这个数就变小了。因此，思路上应该是<b>贪心</b>的。注意实现时处理两个特殊情况，一个是最后删除的<b>字符不够</b>，要<b>从尾部</b>补足k个；一个是结果开头<b>有多余的0</b>，要去掉。

<hr>

403 Frog Jump

题意：青蛙过河，给定一条河，中间分布着一些石头，距离<b>不尽相同</b>。石头距离按<b>升序排列</b>，最后一个石头表示<b>对岸</b>。青蛙如果上一步跳跃距离为k，则下一步必须是k-1或k+1。如果青蛙第一跳距离一定是1，请问是否能到达对岸。

难度：hard

解法：第一念头是搜，而且以<b>BFS</b>为主。从起步按`(距离,上一步步长)`的方式进行搜索。为减少重复计算，用哈希表<b>记录结果</b>即可。从思路上还是很直接的。数据规模支持O(n^2)复杂度，搜索方式也确实是平方级的。

<hr>

404 Sum of Left Leaves

题意：给定二叉树，求出所有<b>左叶节点</b>之和。

难度：easy

解法：水题。

<hr>

405 Convert a Number to Hexadecimal

题意：给定整数，转换为16进制。对于负数，则用<b>补码</b>。

难度：easy

解法：其实就是<b>位操作</b>，移位处理。

<hr>

406 Queue Reconstruction by Height

题意：有n个人排队。现在给定每个人的身高，以及他/她<b>前面</b>且身高<b>不低于</b>他/她的个数。请重建整个队列的顺序。

难度：medium

解法：这题有意思。如果一个身高是x，在x前面插入一个<b>更高的y</b>，那么x的计数就+1了。想了快10分钟没思路，看了下当年写的代码。好像暴力解法，在思路上也挺巧妙的。先按身高<b>升序排列</b>，每次把第i个人放入。因为是升序的，那么找<b>空位</b>，空位是什么？是还没放入的人，而当前的第i位是<b>所有还没放入的人</b>里最矮的。意思就是，如果第i人的<b>计数是k_i</b>，那么当找到<b>第k_i+1个空位</b>，就是第i人的位置了。虽然效率上是O(n^2)，但这思路也挺难想的。另一种解法，就是<b>树状数组</b>，做计数和统计用。代码看了两遍才懂，原来和暴力解法是<b>同一思路</b>，但用了一个<b>在区间求和上做二分查找</b>，求upper bound的办法。这个将O(n)时间降到了O((logn)^2)，因此总效率是<b>O(n(logn)^2)</b>。现在让我再做这题，估计是做不出来了。我觉得这比很多hard题都难想。

<hr>

407 Trapping Rain Water II

题意：著名的<b>二维接雨水</b>。给定一个高高低低的三维地形，其中x、y两维是地形，z维是高度。每个格子尺寸都是1x1x1，请问整个地形最多能存注多少雨水？

难度：hard

解法：首先，抛开这个题的难度以及极大的嘲讽效果。这题也有一定<b>欺骗性的</b>。一维的是DP，如果二维也尝试<b>用二维数组去DP</b>，那就掉坑了。行不通的。这题<b>得搜索</b>，反正我也掉坑里了。用<b>三维空间</b>在脑子里想一想，就是看每个格子的<b>四个方向</b>，是否把它<b>围住</b>了？围住的<b>最低高度</b>是多少？这个最低高度<b>比它自身高度</b>高了多少？把这些想清楚之后，做BFS。能把这些想清楚，已经淘汰90%以上的人了...到这儿还没完，因为怎么搜也有讲究，要<b>从边缘往中间搜</b>。那么问题来了，墙壁有高有低，高墙旁边存了水，还可以<b>从矮墙流走</b>。因此不用队列，而是<b>用最小堆来搜</b>。总是<b>最矮的墙</b>开始计算，它旁边的格子能存多少水。题目这么难想，动手还有这么多技巧，难怪这题能成为<b>神题&名梗</b>。拿这个考人，那就是<b>不招人</b>。

<hr>

408 Valid Word Abbreviation

题意：320的变体。给定一个单词和一个缩写，判断<b>缩写是否匹配单词</b>。缩写的规则是取其中的<b>子串</b>，替换为<b>子串长度</b>。

难度：easy

解法：付费题。水题。

<hr>

409 Longest Palindrome

题意：给定一个字符串s，允许你从中任选字母，请问<b>能拼出</b>的最长回文串的长度是多少？

难度：easy

解法：统计字母个数即可。

<hr>

410 Split Array Largest Sum

题意：给定一个数组，请将其<b>划分</b>为k个子数组，使得这些<b>子数组的和</b>的<b>最大值最小</b>。

难度：hard

解法：又是minimax问题。数据规模可以接受O(n^2)的复杂度，但问题不是如何DP，或者DP是不是两层循环。第一个问题是<b>DP还是二分</b>？如果二分，用这个<b>最小的最大值</b>作为二分的依据，那执行的操作就是用某个值x去划分数组，使得每个<b>子数组和不超过x</b>。为什么“不超过”，因为这个x是所有子数组和的<b>最大值</b>，我们希望这个x尽可能小。这个划分过程是<b>可以贪心的</b>，因为每次都<b>尽量多装</b>，装不下了，就开始划分下一个子数组。那么既然可以贪心，划分过程就可以在一次扫描，也就是O(n)时间完成。不过看了下当年的代码，没想出二分思路，使用DP做的。因此，答案是<b>二分、DP都可以</b>，但二分效率更高。

<hr>

411 Minimum Unique Word Abbreviation

题意：320的变体。还是单词缩写问题，给定一个单词w和一个词表dictionary。请找出w的一个缩写，使得缩写<b>长度尽量短</b>，且该缩写不和<b>词表中任何一个词</b>的缩写<b>冲突</b>。注意，“a32bc”中的“32”视为一个数，长度为1。

难度：hard

解法：付费题。首先，这些词如果长度不同，就不存在任何冲突的可能了。那就只考虑<b>长度都相同</b>的情况。然后，单词的长度不超过21，这就在位运算、整数可表示的范围内，因此想到了用<b>位掩码</b>来表示<b>字符串比较结果</b>的方法，效率比较高。比如“abcde”和“axydf”，比较结果就是<b>“10010”</b>，a和d两个字母相同，其他不同。这样的话，就可以进行搜索了。这些比较结果，就是搜索中<b>要排除的反例</b>。你只要找到<b>第一个正例</b>，就可以返回了。看了下当年的代码，<b>就是这个思路</b>。代码写得比较繁琐，但思路就是这样。用python写就超级简洁了。

<hr>

412 Fizz Buzz

题意：略。

难度：easy

解法：水题。

<hr>

413 Arithmetic Slices

题意：给定数组，求其中的等差子数组的个数。等差子数组就是<b>长度至少为3</b>、符合<b>等差数列</b>的子数组。

难度：medium

解法：直白解法是两层循环枚举。但可以稍微想想，如果abcd是等差数列，到了e发现不满足了。那bcde自然也不满足，不用判断，cde也不用判断。因此，像字符串匹配一样，你不会只把下标+1，而是要至少移到de的位置。因为cde不匹配，但def是可能等差的。借这个思路，可以得到<b>O(n)</b>的解法。注意计算结果时，长度为k的等差数列，总共有`1+2+...+(k-2)`个不小于3的子数列，别漏掉。

<hr>

414 Third Maximum Number

题意：给定数组，可能有重复。请找出所有<b>不重复值</b>的<b>第3大</b>。如果不够3个，就返回最大。

难度：easy

解法：要O(n)复杂度完成的话，我用个map，做一下记录就行了。总是保持map的大小不超过3个，而且map有序，可以返回第3大。

<hr>

415 Add Strings

题意：两个字符串表示的大数，做加法。

难度：easy

解法：水题。

<hr>

416 Partition Equal Subset Sum

题意：给定一个数组，请问能否将其分为两部分，使得<b>两部分和相等</b>。

难度：medium

解法：并不要求连续划分，因此是个<b>01背包</b>问题。背包的目标值，就是<b>总数组合的一半</b>。总和如果是奇数，直接false就行了。

<hr>

417 Pacific Atlantic Water Flow

题意：给定一个m x n的地形格子，<b>左上边被太平洋包围，右下边被大西洋包围</b>。给定每个格子的<b>高度</b>，现在假设<b>一直下雨</b>，水流可以从高地流向低洼，最终流入大海。请你求出哪些格子的水可以同时流向两个大洋。

难度：medium

解法：这个破题竟然是medium难度，这怎么看都像是<b>二维接雨水</b>的变形题。因为有了之前的经验，这次还是<b>从边界往中间搜</b>。虽然雨水向下流，但搜索却是让它<b>往高处爬</b>。这样的话，当一个格子能同时被太平洋、大西洋的水“爬”到，就说明它的水能同时流向两个大洋。从<b>难度和思路</b>上，这题都和二维接雨水非常接近。搜索方法上简单一点，以<b>所有边界格子</b>为起点，做<b>普通的BFS</b>即可。

<hr>

418 Sentence Screen Fitting

题意：给定屏幕的行列尺寸，和一个单词组成的英文句子。请问这个句子能在一个屏幕下打多少遍？

难度：medium

解法：付费题。枯燥的<b>模拟题</b>，可以算一下，也可以直接模拟排版。

<hr>

419 Battleships in a Board

题意：给定m x n棋盘，“x”表示战舰、“.”表示空地。已知一艘战舰只能横、竖方向，以<b>1xk、kx1</b>的尺寸摆放在棋盘上，k是任意正整数。且不同战舰之间<b>不能有格子相邻</b>。请统计出给定棋盘上的<b>战舰个数</b>。

难度：medium

解法：题目要求尽量在扫描棋盘一次就完成统计，<b>one-pass</b>。意思就是不要重复搜索，那可以按照向右、向下的方式去找。因为战舰不能相邻，你不用担心一个x格子的<b>右边、下边都是x</b>，只能二选一。而且，你选择向右、向下，那就意味着如果一个x格子的<b>左、上也是x</b>，这个格子刚才<b>必然被搜过了</b>，可以跳过。思路就这些了。

<hr>

420 Strong Password Checker

题意：<b>强密码</b>的要求是长度6-20、至少包含大小写和数字、没有三个连续相同字符。现在给定一个密码，请计算它<b>至少</b>需要几次编辑能变成强密码。一次编辑包括<b>增删改一个字符</b>。

难度：hard

解法：如果长了，就删。如果短了，就增。如果缺字符种类，就补一个。<b>如果3个连续一样的，就修改或者增删。</b>大致思路是这些，但这个策略怎么组合使用才能得到<b>严格的最小编辑次数</b>？让我现在想，估计想不清楚了。看了下以前的代码，果然写的很复杂。不细说了。

<hr>

421 Maximum XOR of Two Numbers in an Array

题意：给定一个数组，求两元素<b>异或</b>的最大值。

难度：medium

解法：要求在O(n)时间完成，显然不能直接两层循环。毫无思路，看了下当年的代码，<b>当年也毫无思路</b>。这份代码是某个神网友想到的。<b>看了三遍，才看懂。</b>这个解法的复杂度是O(nlog(int))，就算是O(nlogn)吧。比如想x^y=z，那么x^z=y，可以交换。现在我们希望<b>异或结果尽可能大</b>，那我就从<b>二进制最高位</b>开始，每一位我都<b>尝试置1</b>。为什么是“尝试”，因为置1之后，计算异或结果，<b>不一定</b>就能在数组里找到两元素，使得异或结果为1。因此，如果尝试失败，这位就是0；尝试成功就是1。如此不断<b>从高位往低位试</b>，试完32位，结果就出来了。我只能说这是个<b>神仙解法</b>，脑洞太大了。

<hr>

422 Valid Word Square

题意：给定一个二维字符数组，请判断是否组成一个词方阵。意思是<b>第i行和第i列</b>恰好是相同字符串。

难度：easy

解法：付费题。水题。

<hr>

423 Reconstruct Original Digits from English

题意：给定一个字符串s，s是由<b>数字的英文单词</b>连在一起，并经过<b>字母乱序</b>得到的。请找出这些数字，并升序排列。

难度：medium

解法：这题挺扯的，其实就是让你找出<b>0-9的英语单词的特点</b>，比如zero，有个z对吧？five有个v，诸如这种特点。然后统计整个s串的字符个数，去对应匹配这些单词。你按照某个顺序去统计，会发现答案就是唯一的。<b>不用搜索</b>。

<hr>

424 Longest Repeating Character Replacement

题意：给定一个字符串，你可以从其中<b>至多更改k个字符</b>。请问得到的结果里，最多能得到多少个<b>连续相同字符</b>？

难度：medium

解法：如果你考虑只有26种字符，这么遍历26次，也算个解法。比如你要统计“A”，那么当一个<b>窗口内</b>非“A”字符恰好达到k个，窗口就不能扩大了，<b>窗口长度</b>就是你要求的值。对所有字符都这么做，就是26次。但这样还没完，实际上你在任何窗口，都只需要统计窗口内<b>字符数最多的那个字母</b>。因为字符数最多，需要改的字符数就相应最少。所以，总体思路就是<b>滑动窗口</b>+窗口内<b>找数量最多的字母</b>。剩下不说了，这题有点难。

<hr>

425 Word Squares

题意：422的变体。给定一个非常短且长度相同的单词，请找出其中能形成的所有“词方阵”。词方阵的意思是，<b>第i行和第i列</b>恰好是同一字符串。

难度：hard

解法：付费题。单词数比较多，单词非常短。以第一个词作为起点，于是第一行第一列也定下来了。然后逐渐搜第i行第i列，<b>搜索+回溯</b>。毕竟单词长度很短，且检查条件比较严格，搜索回溯的效率不会太差。

<hr>

426 Convert Binary Search Tree to Sorted Doubly Linked List

题意：给定一个<b>二叉搜索树</b>，请将其转换为一个<b>循环双向链表</b>。链表的顺序正好为树的<b>中序遍历</b>，且用节点的left、right指针作为链表的指针。

难度：medium

解法：付费题。看起来挺复杂，其实每个要求<b>单独看都不难</b>。BST的中序遍历是有序的。那就<b>递归处理</b>，用<b>后序遍历</b>的方式，进行连接。递归的返回是当前子树的<b>最左、最右节点</b>。返回后，会得到左左、左右、根、右左、右右五个节点。<b>中间三个连起来，边缘两个继续向上返回</b>即可。最后把左右两个端点再连起来，就满足<b>循环双向链表</b>的要求了。

<hr>

427 Construct Quad Tree

题意：<b>四叉树</b>，用于进行二维空间划分的一种树。给定一个n x n的01方阵，n是2的整次幂。当一个方阵宽度为2^x，且所有元素均为b时，可用一个<b>叶节点`{isLeaf=True,val=b}`</b>表示，否则则用{isLeaf=False}表示，并在下方<b>继续划分4个节点</b>，表示2*2的4四个子方阵。请用四叉树来表示这个给定的方阵。

难度：medium

解法：题目描述很长，主要是<b>介绍四叉树的概念</b>。其实就是统计子矩阵和，看是0、2^x还是其他值，根据结果决定<b>是叶节点还是继续递归处理</b>。

<hr>

428 Serialize and Deserialize N-ary Tree

题意：请设计方案，支持对<b>N叉树</b>的序列化、反序列化。

难度：hard

解法：付费题。<b>系统设计题</b>，如同之前对二叉树的序列化、反序列化设计。在保证<b>正确、清晰</b>的前提下，让<b>效率</b>尽量高。创意嘛，我没想出什么创意，就写了个<b>括号、值、逗号</b>拼接的序列化方案。

<hr>

429 N-ary Tree Level Order Traversal

题意：N叉树，这次是层序遍历。

难度：medium

解法：和二叉树完全一样，用队列。考虑到<b>返回结果</b>的格式，用前序遍历或者其他<b>各种遍历</b>也都行。

<hr>

430 Flatten a Multilevel Doubly Linked List

题意：给定一个带有<b>child指针</b>的<b>嵌套双向链表</b>，请用前序遍历的方式将其打平成一维的双向链表。

难度：medium

解法：题目原文没说前序遍历，这是<b>我理解的思路</b>。这种<b>多层链表格式</b>，在实际里的应用例子就是<b>跳表</b>了。用<b>前序</b>的方式访问，一边访问，一边把节点添加到结果集里。

<hr>

431 Encode N-ary Tree to Binary Tree

题意：给定一个N叉树，请将其转换为二叉树，并设计相应的2转N方法。

难度：hard

解法：付费题。这题有点巧妙，因为N叉树确实可以和二叉树<b>在形状上建立一种对应关系</b>。比如你以<b>当前节点</b>为根，把<b>第一个子节点</b>作为left，后面每个子节点（都是上一个的<b>兄弟节点</b>）都作为上一个的right，那么就成了一条“左右右右右...”的链条。这个关系可以递归往下使用。这样的编码是<b>无歧义</b>的，因此<b>正确性没问题</b>，就是会导致这棵树很“右倾”。其他的方案，就看你的创意了。

<hr>

432 All O`one Data Structure

题意：请设计一个字符串统计的数据结构，能够对统计+1、-1，还能返回当前计数最多、最少的任意一个字符串。要求这些操作的代价都是<b>O(1)或均摊O(1)</b>。

难度：hard

解法：计数功能就是哈希表，没问题。要获取最大、最小的计数，这怎么看也是个TreeMap之类的树结构，那代价总是O(logn)的，做不到均摊O(1)。因为最大最小是对称问题，我们先只考虑<b>+1和求最大</b>。我用一个哈希表，同时做`字符串->计数值`和`计数值->[字符串列表]`这种<b>双向映射</b>，再记录一个<b>当前最大计数值</b>。这个方法可以保证我在+1、-1时，能以O(1)代价更新一切。因为我一次操作<b>只能+1或者-1</b>，而不是+10或者+100。所以这个<b>计数最大值</b>的<b>变动</b>，在连续调用的情况下，单次可能是O(n)，但均摊一定是O(1)的。这个思路已经挺复杂了，写出来就是<b>两个哈希表实现</b>。看了下我当年的代码，还难看的多，用了链表。重新写了一版用双哈希表实现的代码，依然<b>非常非常复杂</b>，但确实是O(1)了。不得不说这种题作为面试题的考察意义确实存在，就是考验你处理一件<b>看起来不难，实际非常麻烦的事</b>的能力。<b>都是细节</b>。

<hr>

433 Minimum Genetic Mutation

题意：每次基因突变，会改变其中一个<b>碱基</b>。给定一个表示有效基因的<b>基因库</b>，每次突变都需要发生在基因库的范围内，才算<b>有效突变</b>。给定<b>起始和目标</b>基因，请问至少需要几次有效突变？

难度：medium

解法：题目讲了一大堆，其实就是字符串每次变换一个字符，且变换过程都要在一个词典中。串长度和词典长度都不大，<b>建图</b>进行<b>BFS</b>即可。

<hr>

434 Number of Segments in a String

题意：给定字符串s，用空格分割，数一下个数。

难度：easy

解法：水题。

<hr>

435 Non-overlapping Intervals

题意：给定一些[x,y]形式的闭区间，请问最少需要删除多少个区间，使得剩下所以区间互不重叠。<b>端点邻接的情况</b>不算重叠，比如[x,y]和[y,z]不重叠。

难度：medium

解法：直白思路肯定是先按(x,y)的二维顺序进行<b>排序</b>，然后做一个O(n^2)的<b>DP</b>。数据规模提示，排序是可以做的，但应该在排序后线性或者O(nlogn)代价内完成。可以想到一种<b>二分</b>的思路。对每个位置`[x_i,y_i]`，二分找到最小的元素`[x_j,y_j]`，使得`x_j>=y_i`。这样就给每个位置找到了它的后继位置。然后从<b>每个起始点</b>，不断跳到后继位置。这个过程并不会重复访问元素，因此总代价是O(nlogn + n)，还是O(nlogn)。其实这个思路依然想复杂了，直接<b>贪心O(n)</b>就可以了。<b>从末尾反着扫</b>就行了。

<hr>

436 Find Right Interval

题意：给定一些`[x_i,y_i]`形式的区间，请给每个元素找到“右区间”。右区间的意思是，`[x_j,y_j]`也在数组中，且是符合`x_j>=y_i`的最小元素。

难度：medium

解法：在435里已经提到这种做法了。先对区间按(x,y)排序，然后对每个元素做<b>bisect_left</b>查找即可。查找条件是<b>x值不小于y_i</b>。注意结果要取<b>排序前的下标</b>，要保留之前的值。

<hr>

437 Path Sum III

题意：112的变体。给定一棵二叉树，和一个目标值target。请求出从任意点出发，<b>往下的路径和</b>等于target的<b>路径个数</b>。

难度：medium

解法：也没什么难度，就是<b>注意递归写法</b>即可。因为可以从<b>任意点</b>出发，你在每个地方都要<b>检查路径和</b>，也都要<b>发起新的递归</b>。递归结果是可以缓存的，<b>避免重复计算</b>。

<hr>

438 Find All Anagrams in a String

题意：给定字符串s和p，请求出s中所有和p互为anagram的子串的个数。

难度：medium

解法：固定大小的窗口，不断滑动，同时做<b>字符统计</b>即可。最好用<b>做diff的方式</b>统计，这样方便在diff计数为0时进行判断。比如p是“abc”，那就在初始时把计数设为`{a:-1,b:-1,c:-1}`，这样，当计数恰好全变为0，就是匹配了。

<hr>

439 Ternary Expression Parser

题意：<b>三元表达式</b> `condition ? do something : otherwise`，也叫<b>条件表达式</b>。请设计算法，处理一个可能嵌套多层的三元表达式。其中<b>条件</b>总是以T或F出现，不会出现嵌套。<b>值</b>表达式可能存在嵌套。

难度：medium

解法：付费题。<b>parser题</b>。其实哪个嵌套不嵌套都无所谓。就是一种<b>固定语法</b>，对符号做解析处理就行了。注意符号优先级，比如`F?1:T?4:5`这种，以这个例子来看，条件表达式的<b>优先级</b>是要高于“:”的，因此才先计算右边。同理，这个例子`T?T?F:5:3`，优先级也高于“?”。

<hr>

440 K-th Smallest in Lexicographical Order

题意：给定正整数n和k，请给出按字典序排列，1-n中第k小的数。

难度：hard

解法：<b>字典序</b>，但是不能真的排序，因此应该是个<b>搜索或者DP</b>题。想了下没什么很好的<b>搜索思路</b>，即使有，代码也有点复杂。看了下当年的代码，应该是没做出来。网友的版本<b>非常简短</b>，而且几乎看不懂。<b>又仔细看了三遍，还是没懂。</b>罢了。如果现在让我重做的话，我会从<b>数位角度</b>考虑。1之后是10，10之后是100，直到这个值超过n。因此总是应该<b>尽量*10，不能乘了就+1</b>。剩下没完全想清楚，先不写了。

<hr>

441 Arranging Coins

题意：你有n个硬币，想用这些硬币堆楼梯。第i层正好有i个硬币，允许最后一层的个数不完整。请问能堆多少<b>完整的层</b>？

难度：easy

解法：水题。

<hr>

442 Find All Duplicates in an Array

题意：给定长度为n，且元素值都在[1,n]范围的数组。每个值<b>至多出现两次</b>。请用O(n)时间O(1)空间找出出现两次的值。

难度：medium

解法：之前做过类似题目了，在数据范围有限的情况下，可以用<b>叠罗汉</b>的方式“叠”出一个数组。<b>用i*n+j表示(i,j)</b>，这样就可以对各个值做统计。找到<b>统计为2</b>的值即可。最后<b>记得把数组的值还原</b>。

<hr>

443 String Compression

题意：给定字符串，做游程码压缩。对单字符不做处理，对连续多字符，则变为“<字符><连续个数>”。请在原字符串上进行修改，并返回压缩后的长度。

难度：medium

解法：就是<b>游程码</b>，按规则实现即可。

<hr>

444 Sequence Reconstruction

题意：给定一个<b>1-n的排列</b>org，和一个<b>子序列数组</b>seqs。现在请你判断，seqs中所有元素是否都是<b>org的子序列</b>，且org是符合这个条件的<b>唯一排列</b>。

难度：medium

解法：付费题。题目说的非常深奥，看了两遍才懂。其实仔细想想，子序列是什么？先后顺序。1-n的排列是什么，就是n个点。<b>n个点，先后顺序</b>，这就是拓扑排序。所以，可以拿seqs里面的顺序去建图，然后判断<b>拓扑排序的结果是否唯一</b>。怎么才唯一呢？第一，有0度且无环；第二，0度自始至终都只有一个。这样算出来的拓扑序列才是<b>唯一</b>的。如果你存在`a->b`、`a->c->d`这样的岔路，那就不唯一了。

<hr>

445 Add Two Numbers II

题意：两个单链表表示的大数，做加法。用同样的形式返回结果，并尽量<b>不要反转链表</b>。

难度：medium

解法：还专门提示不要反转链表，这就是那种<b>为考而考</b>的迂腐题目。我直接转数组做了，符合“不反转链表”的要求，完美。

<hr>

446 Arithmetic Slices II - Subsequence

题意：413的变体。给定无序数组，请找出其中长度至少为3的<b>等差子序列的个数</b>。

难度：hard

解法：之前是<b>子数组</b>，可以直接O(n)扫描，很好理解。这次子序列，就不用连续了。从数据规模看，当然暗示你是O(n^2)，<b>两层循环DP</b>解决，但DP关系是什么？既然是等差数列，以`dp<当前值,公差>`为递推关系比较好。比如当前元素y,可以枚举y之前的元素x，并找`dp<x,y-x>`，看看<b>用这个公差y-x</b>能<b>往前延伸几步</b>。形式上是二维数组，但实际可以用list[dict]来搞定，dict的映射是`公差->向左的子序列长度`。<b>两层循环，DP搞定。</b>

<hr>

447 Number of Boomerangs

题意：给定二维平面上n个点，不存在重合。如果点i<b>分别</b>和点j、点k的<b>距离相等</b>，称为一个<b>(i,j,k)回旋镖</b>。请统计回旋镖的个数。

难度：medium

解法：首先，距离计算<b>不用开根号</b>，毕竟你只关心是否相等。以O(n^2)的时间，思路很简单。<b>对于每个点</b>，计算其他n-1个点的距离，用哈希表统计个数，并做一下`k*(k-1)/2`的求和即可。
<hr>

448 Find All Numbers Disappeared in an Array

题意：给定长度为n，且值都在[1,n]范围的数组。请返回范围内没出现的值。并尽量用<b>O(1)额外空间</b>完成。

难度：easy

解法：和442一样，<b>叠罗汉</b>，计数。这种小聪明做法，还出了这么多题。这做法本身就是<b>不工程化</b>的，不值得提倡。

<hr>

449 Serialize and Deserialize BST

题意：请设计方法，序列化一个二叉搜索树。

难度：medium

解法：BST的中序遍历有序，因此可以认为<b>已经包含中序</b>了。那你只需要选前序遍历或者后序遍历即可。<b>前序更直观</b>，多数人都会选前序。

<hr>

450 Delete Node in a BST

题意：给定一个二叉搜索树，请删除值为val的对应节点，并返回根节点。

难度：medium

解法：这是个经典面试题，经典之处，在于<b>需求就一句话，你也知道要做什么</b>，但就是很坑。要考虑的<b>情况非常多</b>，且边界case<b>极容易出错</b>。这题没有技巧，只能仔细考虑。

<hr>

451 Sort Characters By Frequency

题意：给定字符串，将字符按照<b>字符频率</b>降序排列。如果频率相同，则顺序任意均可。

难度：medium

解法：这应该算easy，统计并排序即可。

<hr>

452 Minimum Number of Arrows to Burst Balloons

题意：给定一些大小气球，分布在xy二维平面上。每个气球的左右x坐标你知道，但是y坐标不知道（也无所谓）。允许你从<b>x轴任意点向+y方向射箭</b>，箭穿过的气球都会爆掉。请问要爆掉所有气球，最少需要多少支箭？

难度：medium

解法：去掉几何部分的理解后，其实每个气球也就是视为一个区间。那么对于区间`[xs_i,xe_i]`，任何在这区间内射出的箭，都会打爆它。因此当一个点被尽可能多的区间包含，也就打爆了尽可能多的气球。那么这个解法就从<b>区间求交集</b>入手，给定一个区间，不断和下一个区间求交集，如果交集不为空，表示还有共同部分；如果为空，则代表<b>刚才的所有气球</b>，消耗<b>一支箭</b>可以爆掉。这样的话，这个思路就是<b>贪心</b>的，O(n)完成。因此总代价是<b>先排序O(nlogn)，然后扫描O(n)</b>。搞定。

<hr>

453 Minimum Moves to Equal Array Elements

题意：给定一个n元素数组，每次你可以选n-1个元素减1。请问至少多少次操作，能把所有元素变相等？

难度：medium

解法：这题太扯了。不就等效于<b>选1个元素加1</b>吗？加就行了。

<hr>

454 4Sum II

题意：18的变体。给定数组，求出4元素相加等于0的不同个数。

难度：medium

解法：思路还是先枚举，再动脑子。用前两维枚举，第三第四维做two sum，这个two sum的做法是<b>以O(n)代价</b>求出两元素之和等于target的<b>个数</b>。这样复杂度就是`O(n^2 * n) = O(n^3)`。

<hr>

455 Assign Cookies

题意：有n个小朋友和m个饼干。每个小朋友有个贪心值g[i]。如果得到饼干的尺寸大于g[i]，则第i个小朋友会满意。请问最多有多少个小朋友会满意？

难度：easy

解法：<b>排序</b>之后扫一下就行了。

<hr>

456 132 Pattern

题意：给定数组nums，请找出是否存在(i,j,k)，使得`nums[i]<nums[j]>nums[k]`。

难度：medium

解法：对每个元素，看左右是否都有元素小于它就行了。

<hr>

457 Circular Array Loop

题意：给定一个<b>循环数组</b>nums，如果你在i位置，则下一步移动nums[i]距离。正值表示循环右移，负值表示循环左移。问从0位置出发，是否会经过某个循环回到0？

难度：medium

解法：首先，在有限格子执行无限的移动，这一定是个循环。因此问题问的是从0开始能否回到0，因为<b>循环部分不一定包括0</b>。那就从0开始，一边走一边记录就行了。代价至多是<b>O(n)</b>，因为你<b>不会重复访问格子</b>，找到循环就结束了。题目还说了能否在<b>O(1)空间</b>完成，这个不展开了，又是无聊的<b>小聪明</b>。

<hr>

459 Repeated Substring Pattern

题意：给定一个字符串s，能否找出一个子串ss，使得s恰好是ss连续重复几次的结果。

难度：easy

解法：这题几乎<b>只有一个好解法</b>，就是<b>KMP算法</b>。因为这种重复子串的模式，就是KMP的<b>next数组</b>的<b>完美应用</b>。比如ababab，你看得出来ab重复了3次，那么把ababab作为<b>模式串</b>，它的next数组长什么样？`[0,0,1,2,3,4]`。next的原理就不细讲了，大致就是next[i]的值表示p[0:i+1]这个子串的前后缀相同的最大长度。比如next[5]=4,因为“ababab”的开头“abab”和结尾“abab”相同。如果一个长度n的串s可以被长度m的串ss重复k次，那么n=m*k。且这个s的next数组一定是`[0,0,...,1,2,3,...,m*(k-1)]`这种形式。最后，这题定为easy只是因为数据范围可以直接暴力匹配。

<hr>

460 LFU Cache

题意：和LRU cache一样，实现一个缓存。LFU基于<b>最低频率</b>原则淘汰数据。

难度：hard

解法：其实<b>LFU比LRU简单</b>，毕竟“访问+置顶”这个操作，如果用双向链表+哈希表实现，就是很麻烦。维持计数并记录最大值，这个操作如果不要求严格O(1)，而是允许O(logn)的话，整件事情就清晰多了，也容易多了。总之，写任何工程代码，最大的目的是跑通+读懂+可维护可扩展。没有必要<b>自己坑自己</b>。

<hr>

461 Hamming Distance

题意：两个整数的Hamming距离，定义为二进制位不同的个数。求x和y的Hamming距离。

难度：easy

解法：其实就是<b>异或</b>之后，求1的个数。

<hr>

462 Minimum Moves to Equal Array Elements II

题意：453的变体。每次操作允许你任选一个元素+1或者-1，请问至少多少次操作可以把所有元素变得相等？

难度：medium

解法：两个数如果相差2，你+1-1和+1两次，都是两次操作。那比如选定一个值x，所有元素变为x的代价就是`|nums[i]-x|`的和。这个x肯定是选在中间比较好，那是平均数、中位数还是什么呢？<b>我猜是中位数</b>，猜对了。仔细想想也<b>可以证明</b>。

<hr>

463 Island Perimeter

题意：给定一个m x n的01矩阵，0表示水，1表示陆地。所有陆地连成了一个小岛。每个格子的边长为1，请计算小岛的周长。

难度：easy

解法：这题有点意思。周长，一个不规则的形状，周长怎么算？对这个题，用<b>每个方块暴露了几条边</b>这种思路去算，更容易。<b>和边界邻接或者和水邻接</b>，就算暴露在外了。这么做的话，连搜索都不用，直接每个<b>陆地方块</b>判断四周就行了。

<hr>

464 Can I Win

题意：给定一个值n，有1-n共n个数。初始和为0，两人轮流从中选一个数，加入和中。首先让和达到上限total的人，赢得游戏。如果每个数<b>只能用一次</b>，请判断<b>先手</b>是否有<b>必胜策略</b>？

难度：medium

解法：博弈论。但是这次的表达方式不同，因为数只能用一次。这个和比较典型的博弈论算法题不同，形式上只适合<b>带状态的搜索</b>，而不能简单用线性的数组递推。<b>数据规模</b>也暗示了这点，可选数最多20个，那说明可以用`(1<<n)-1`表示所有可能的状态。按这个思路，搜吧。搜索的递推关系有两条：<b>对手存在一种输，则我赢；对手总是赢，则我输。</b>这点想明白很重要。为什么，因为“play optimally”，最优策略就是这么玩的。这题挺难的，比一般的博弈论题还难。

<hr>

465 Optimal Account Balancing

题意：一些朋友相互借钱。现在给定借钱情况，请问最少需要几次交易，才能把所有借账还清？

难度：hard

解法：付费题。首先把所有交易处理一下，算出每个人的<b>净值</b>，肯定有正有负。我的思路是把<b>正值放入最大堆，负值放入最小堆</b>。每次取最大、最小值，进行一次<b>抵消</b>，把剩余结果再放回堆里。直到全部清空。但是，这个思路是错的，<b>不能贪心</b>。因为如果<b>存在其中的某个子集的和为0</b>，那个这个<b>子集内部</b>就可以解决问题，你<b>额外引入一条边</b>就会导致<b>次优解</b>。我想了10分钟才想明白这点。网上都说这题很难，难点就在于<b>不断寻找和为0的子集</b>。基于这个思路，去<b>搜吧</b>。每搜到一个大小为k的最小子集（不能继续划分），<b>答案就加上k-1</b>。

<hr>

466 Count The Repetitions

题意：给定字符串s，`[s,n]`表示s串重复n次。现在给定`str1=[s1,n1]`和`str2=[s2,n2]`，请求出最大值m，使得`[str2,m]`是str1的<b>子序列</b>。

难度：hard

解法：思路有点卡住了。想找类似<b>循环节、最小公倍数</b>之类的，但想不清楚。看了下当年的代码，确实是最小公倍数的思路，除此之外，没有想得太复杂。就是暴力匹配，然后<b>除一下</b>。

<hr>

467 Unique Substrings in Wraparound String

题意：有一个由a-z无限重复的字符串base。给定字符串s，请求出s中的不同子串个数，要求这些子串在base中出现过。

难度：medium

解法：s的长度暗示这是O(n)的问题。那么既然base里的字符串是a-z循环，那就有一个连续+1的关系。这样的话，可以在s中判断这样的一个最长子串，而且是<b>贪心策略直接扫</b>。比如找到一个长度为5的串，那其中总共有`1+2+3+4+5=15`个子串。就这么一直扫到结束，但要注意得去重，而且这个去重方式有讲究，不必真的存abcdefg这样的字符串，只要记录`<首字母,长度>`即可。这样的话，一个哈希表就够了。时间是O(n)，空间也是O(n)。看了下当年写的代码，好像用了两层循环，竟然也过了？思路类似，不过用了一些<b>位操作</b>提高效率。

<hr>

468 Validate IP Address

题意：给定一个字符串，根据规则判断是否为有效的IPv4、IPv6地址，或者无效。

难度：medium

解法：细节题，各种边界case。

<hr>

469 Convex Polygon

题意：给定n个二维平面的点，按顺序依次连起来组成一个n边型。请判断是不是<b>凸多边形</b>。

难度：medium

解法：付费题。这可真是正经几何题了，凸多边形的判定法，<b>没学过的话根本猜不出来</b>。如果你用判断角度的办法，看每个角是不是小于180度，那就很麻烦。实际上有个容易的办法，算<b>叉积</b>。每相邻两条边的向量，做一下叉乘。得到结果当然不能是0，0的话表示<b>共线</b>了。那它要么正要么负。判定凸多边形的依据，就是这个<b>叉乘的符号一直不变</b>。始终正，或者始终负。二维向量的叉乘是(a,b)和(c,d)，结果是ad-bc。除非<b>相关工种</b>，否则不可能问这种问题的。这需要专业知识。

<hr>

470 Implement Rand10() Using Rand7()

题意：给定一个rand7()函数，可以等概率输出1-7。请设计一个函数rand10()，等概率输出1-10。

难度：medium

解法：数学题。首先，两个rand7()相加是错的，相加的<b>概率分布不均匀</b>。应该叠罗汉，用`x=rand7()-1,y=rand7()-1,z=x*7+y`，这样z就是0-48等概率了。我们<b>取其中40-48丢弃</b>，只要0-39。将0-39均匀映射到1-10就行了。你可以浪费算力，但你<b>不能有概率偏差</b>。

<hr>

471 Encode String with Shortest Length

题意：给定一个字符串s，将其压缩为最短形式。如果无法变得更短，则返不做处理。压缩的具体规则为，取其中由相同字符串重复而成的片段，改写了`次数[重复串]`的形式。比如`abcdabcdxyxyxyz`可以压缩为`2[abcd]3[xy]z`。此外，还可以在压缩基础上继续<b>嵌套压缩</b>。<b>计算长度</b>时，数字、括号等正常计入。

难度：hard

解法：付费题。之前已经有<b>判断字符串循环节</b>的题目了，这题则更复杂，在循环的基础上，要判定<b>循环边界</b>，还要做相应的压缩。<b>嵌套压缩</b>还加了一层复杂性。因此，这题除了<b>递归搜索</b>的方式，其他方式应该都很复杂。我忘了这题的数据规模，应该是很小，否则难度就hold不住了。看了下当年的代码，确实是<b>搜</b>。

<hr>

472 Concatenated Words

题意：给定一个词表，判断其中某些词是否可以由<b>至少两个别的词</b>拼接而成。拼接使用的词可以任意顺序，可以<b>重复使用</b>。请返回所有的拼接词。

难度：hard

解法：词的长度比较短，词个数比较多。因此对单个词的拆分，O(n^2)代价是可以接受的。对每个词都执行word break（之前的一道题）操作即可。为提高效率，先把所有词<b>按长度升序排列</b>，<b>短的在前</b>。

<hr>

473 Matchsticks to Square

题意：给定一些长长短短的火柴，请问是否能首尾相连，拼成一个<b>正方形</b>？每根火柴不能重复使用。

难度：medium

解法：把火柴分为四组，<b>每组之和相等</b>。除了<b>搜</b>，没别的办法了。这个递归的写法要注意，相当于一个<b>双层参数</b>，第一层是4次，第二层是每次的长度之和。这样大的搜索空间，<b>剪枝余地是很大的</b>。如果完全不优化，肯定超时。

<hr>

474 Ones and Zeroes

题意：给定一个<b>01字符串数组</b>。请从中选出一个<b>子集</b>，使得子集的所有0个数不超过m、1个数不超过n。请问子集最多能有多少个元素？

难度：medium

解法：这题的关键是，看出它是一个<b>二维的01背包问题</b>。看不出来的话，就一点思路也没有。看出背包之后，剩下就不用说了。讲道理，还真不是一眼能看出来。

<hr>

475 Heaters

题意：给定n个房子和m个暖气的位置。如果位置x有个暖气，它的取暖范围是r，则`[x-r,x+r]`范围都能<b>得到供暖</b>。现在请问<b>取暖范围r</b>最小取多少，才能保证所有房子都有供暖？

难度：medium

解法：给定某个值r，检验<b>所有房子</b>是否覆盖暖气的代价是O(n+m)的，线性。那么，就对r值<b>二分搜索</b>吧，搞定。

<hr>

476 Number Complement

题意：给定正整数，求反数。

难度：easy

解法：这个反数，只反到这个数的<b>二进制最高位</b>为止。

<hr>

477 Total Hamming Distance

题意：Hamming距离之前已经遇到过了。现在给定一个数组nums，请返回所有<b>元素对</b>的Hamming距离之和。

难度：medium

解法：Hamming距离是两数的<b>异或的1的个数</b>。要做这个求和，肯定有什么技巧。因为这件事对于每个二进制位是<b>相互独立</b>的，我们先<b>考虑一位</b>。比如有n个元素，其中有k个1，n-k个0，那么总共有<b>n^2个对</b>。对每个0，结果中有k看个1，共`(n-k)*k`；对每个1，结果中有n-k个1，共`k*(n-k)`。发现了吗？加起来的Hamming距离之和就是`2*k*(n-k)`。对32个位都做这种统计，加起来就行了。

<hr>

478 Generate Random Point in a Circle

题意：给定一个圆的半径和圆心位置，请实现一个函数，随机返回<b>圆内</b>的一个点，要求概率均匀。

难度：medium

解法：简单的几何题，极坐标的r和th很好处理，随机一下，然后转为(x,y)返回即可。

<hr>

479 Largest Palindrome Product

题意：给定整数n，请找出能由两个<b>n位数</b>相乘得到的<b>最大回文数</b>。结果模1337返回。

难度：hard

解法：神奇。这题难度是hard，有种<b>数论且毫无头绪</b>的感觉。都不知道要干嘛。两个n位数，相乘，回文数？n最大是8，结果是回文数。这么算的话，暴力搜索的空间就是10^8，这也够大了。OK，我放弃了。除了<b>预计算+打表</b>之外，有什么真正有效的<b>数学思路</b>吗？看了下当年的代码，我也是打表。

<hr>

480 Sliding Window Median

题意：给定长度为n的数组，设定一个大小为k的窗口，不断往前滑动。请返回每个<b>窗口内的中位数</b>。

难度：hard

解法：把k对半分，<b>小的一半放进一个map，大的一半放进一个map</b>。这样，<b>最中间的部分</b>总是暴露在<b>交界处</b>，方便计算<b>中位数</b>。注意在滑动时，处理好<b>添加元素、调整两个map</b>的操作。为什么<b>不能用堆</b>呢？因为你不能删除<b>某个特定元素</b>。既要有序，又要能精准增删元素，因此需要用map。

<hr>

481 Magical String

题意：给定一个由12组成的字符串s，如果把s中1、2的<b>连续出现的个数</b>连接起来，正好能得到<b>s本身</b>，则称s为<b>魔法串</b>。比如`122112...`，出现次数是`1 2 2 1...`，连起来恰好也是它本身。现在请求出这个魔法串的前n位里，总共有多少个1？

难度：medium

解法：<b>描述非常难懂</b>，不过题目本身应该没那么难。按照这个要求，以及n的范围，是可以求出这个s串的前n位，直接统计有多少个1的。那么怎么求呢？比如你<b>从1开始</b>，说明有一个1，那么下一位一定是2。2，说明有两个2，这就是122了。第三位是2，说明有两个1。<b>就这么一步步往下推就行了</b>，直到位数满足n位位置。是个挺巧妙的题，也确实不是很难。据说这个叫<b>Kolakoski序列</b>，果然是有人研究的东西。

<hr>

482 License Key Formatting

题意：给定一个序列号，按某种格式变一下。

难度：easy

解法：水题。

<hr>

483 Smallest Good Base

题意：给定一个用字符串表示的大数n，请找出最小的k进制，使得n在k进制下，所有位都是1。

难度：hard

解法：又是<b>数学题</b>。既然`n=(1111...111)_k`，那么n*(k-1)的每位都是k-1，<b>n*(k-1)+1就是k的整次幂了</b>。所以，`nk-n+1=k^p`，其中k、p都未知。有一个解很容易得到，p和k都取1，这没意义。还有一个朴素解，`p=2,k=n-1`。再往下，就没思路了。因此，只能在这个基础上，<b>开始搜索</b>。所幸这个搜索过程是有上下界，且在每轮搜索内是可以二分的。里面还有一些<b>数学细节</b>，不讲了，这题让我再做一次，<b>肯定做不出来</b>。

<hr>

484 Find Permutation

题意：给定一个1-n的<b>未知排列</b>。你能得到一个长度为n-1的DI序列，D表示降、I表示升。这些是相邻元素的升降关系。请给出符合这个要求的，字典序最小的排列。

难度：medium

解法：付费题。只知道升降，但是不知道<b>任何一个元素</b>，乍一看好像<b>没有入手的地方</b>。有点难。想了10分钟，想不出来。看了下，当年也没想出来。代码是@StefanPochmann大神的，思路竟简单的出奇。首先从1-n这个升序开始，遇到<b>连续的D序列</b>，就把对应长度的序列<b>反转一下</b>，这些D就都满足了。这么做得到的结果，一定是<b>字典序最小</b>的一个。没办法，就是想不出来。

<hr>

485 Max Consecutive Ones

题意：给定一个01数组，求出最长的连续1的个数。

难度：easy

解法：水题。

<hr>

486 Predict the Winner

题意：给定长度为n的数组，两人轮流从中取数。每次可以从<b>左右两端</b>选一个元素拿走，加入自己的<b>分数</b>。全部选完时，分数多的获胜。请问<b>先手是否必胜</b>？

难度：medium

解法：博弈论题。因为只能<b>从两端取</b>，那dp[i][j]就取决于dp[i][j-1]和dp[i+1][j]了。如果两种都是输，那就是输；如果存在一种是赢，那就赢。O(n^2)代价完成。虽然题目规模暗示你，可以暴力搜。但这个<b>DP思路</b>也很容易想到。

<hr>

487 Max Consecutive Ones II

题意：485的变体。给定01数组，如果允许你<b>至多把一个0变成1</b>，请找出最长的连续1的个数。

难度：medium

解法：付费题。能改变一个0，那比较关键的情况，就是两串1之间<b>恰好有一个0</b>。这也挺直白的，统计一下连续个数，判断是否有这种情况即可。题目还提出一个挑战，如果数据是<b>不断流入的</b>，又该怎么处理？其实这样也差不多，因为你只关心<b>最近的</b>连续1的个数，至多保留上一次统计就够了，空间依然是O(1)。

<hr>

488 Zuma Game

题意：祖玛玩过吗？一个青蛙，嘴里吐球。一串球往前滚动，打中了同颜色的，<b>三个一消</b>。消除后，可以继续<b>嵌套消除</b>。现在改一下规则，你手里的球是确定的，但你可以用<b>任意顺序</b>发球，插入<b>任意位置</b>。请问<b>最少</b>需要多少个球，能把上面的球<b>都消掉</b>？如果做不到，则返回-1。

难度：hard

解法：祖玛的消除逻辑倒是不难，难点在于要选<b>一个合适的策略</b>，使得球消除得最快。比如有个序列是RBGWGBR，那这个白球肯定是最应该消的，因为它左右的<b>对称颜色</b>是最多的，更有利于<b>嵌套消除</b>。以数据规模看，是<b>允许直接搜索</b>的，不用想很高效的存储和查找方式。那就<b>搜吧</b>。实际上，这个问题是可以扩到<b>更大规模</b>的，也确实有<b>更优策略</b>去解决。

<hr>

489 Robot Room Cleaner

题意：给定一个扫地机器人，你有机器人的前进、左右转、扫地API。请利用这些API，实现一个房间的清洁。注意，房间的<b>总体形状</b>你并不知道。

难度：hard

解法：付费题。这题很好，很工程化。算法题几乎都是上帝视角+完整细节，你往往<b>全知全能，操控一切</b>。这次你作为一个<b>个体agent</b>，在<b>环境env</b>里做有限的事情。这倒是很像<b>强化学习</b>的基础思路了。这题的考点在于，你如何避免在扫不完整个屋子时，就进入了死循环。如何判断<b>扫过了，以及扫完了</b>？我的思路是以初始点作为(0,0)建立相对坐标系。这样我不管上下左右（通过转向实现），总是有位置记录的。记录好<b>已扫过的位置</b>和当前位置。再一个就是寻路算法，我用的比较简单的<b>向右转</b>。碰到<b>障碍物和边界</b>，就向右转。

<hr>

490 The Maze

题意：给定一个m x n迷宫，1表示墙，0表示空地。球从某起点出发，目标是到达终点。每次球滚动时，只有<b>撞到墙才能停止</b>，并选择新的方向。请问球能否到达终点？迷宫的<b>边界外都是墙</b>。

难度：medium

解法：付费题。如果球可以随意停下来，那就是单纯的<b>搜索遍历</b>了。因为球不能中途改变方向，那就在搜索时，把下一步的转移方式改一改就行了。比如你用BFS，从(x,y)向右，那就找到<b>右边撞墙之前</b>的最后一个格子(x,y+d)作为下一步，而不是(x,y+1)。除此之外，没什么区别。<b>搜吧</b>。

<hr>

491 Non-decreasing Subsequences

题意：给定数组nums，返回所有长度至少为2的<b>递增子序列</b>。递增的标准是>=，<b>不降</b>。

难度：medium

解法：搜索即可。

<hr>

492 Construct the Rectangle

题意：给定一个矩形面积a，请求长宽w和h，使得a=wh，且w和h尽量接近。

难度：easy

解法：水题。

<hr>

493 Reverse Pairs

题意：给定数组nums，定义一个反数对（随便怎么叫吧）为(i,j)，且`nums[i]>nums[j]*2`。请问nums有多少个反数对？

难度：hard

解法：<b>从j的视角看</b>，在j之前，有多个i满足这个条件？问题就转化成了，对于前k个元素，有多少个元素大于x？所以，这种<b>动态统计求和</b>的需求，很适合<b>树状数组</b>。看了下当年的代码，还真是树状数组做的。

<hr>

494 Target Sum

题意：给定一个数组和target值。允许你在每个数前面添加+-号，使得总和是target。请问有多少种方法？

难度：medium

解法：以规模和难度看，<b>直接搜就可以了</b>。但配合一些<b>适当的剪枝</b>，效果会更好。剪枝的策略就是，如果当前求和太大了，后面就不要用+了；如果当前求和太小了，后面就不要用-了。

<hr>

495 Teemo Attacking

题意：给定一个时间序列times，和一个时长duration。如果魔法效果持续时间为duration，施法的时刻是times。已知魔法不叠加，重复施法只保留最新的一个，请问魔法有效的总时间是多少？

难度：easy

解法：水题，就是题目本身讲太多了。

<hr>

496 Next Greater Element I

题意：给定数组nums1和nums2，nums1是nums2的子集。请求出nums1中每个值，对应在nums2位置的<b>右边的第一个大于它的元素</b>。如果不存在，则返回-1。

难度：easy

解法：题目很拗口。直白解法当然是O(n^2)的，对每个元素逐个找结果。优化思路也不难，用一个map、heap之类的有序结构，以元素值为key。这样，每访问到一个元素，总是可以和<b>当前最小值</b>比较一下。如果比最小值大。那这个值的next greater就找到了。最后留在其中的，都是没找到结果的，都置为-1。这样的复杂度大概是O(nlogn)。题目要求O(n1+n2)的优化思路，可以基于我刚说的这个思路继续想。既然有个结构，保存了当前<b>还没找到next greater</b>的元素，那这个结构一定是<b>依次降序</b>的。为什么，因为如果有升序，那前者的next greater不就是后者？矛盾了。因此，必须是降序的。所以，每次得到的新值，只要不断和当前最靠前的元素比较。这样，就可以用<b>栈</b>解决。因此每次操作都是均摊O(1)的，总体时间是O(n)。这题定为easy不合适。毕竟有一点难想，而且有技巧。

<hr>

497 Random Point in Non-overlapping Rectangles

题意：给定一些互不重叠的、和xy轴对齐的矩形，请设计一个算法，随机返回一个点，要求这个点在某个矩形内，<b>边界也算内部</b>。<b>所有矩形的所有内部点</b>，必须具有相同的概率。

难度：medium

解法：随机一个1-n的数，当然是公平的，这是标准库提供的。因此我们要做的就是做好<b>比例分配</b>。一个长宽为w、h的矩形，总共包含了`(w+1)*(h+1)`个点。题目说的不重叠，是包括<b>边界也不会重叠</b>。这个省去了很多麻烦。通过计算面积，做面积累加和，来做<b>第一层随机</b>。这个随机值用来<b>选矩形</b>。再对矩形内的`[x1,x2]`和`[y1,y2]`做<b>第二层随机</b>，就得到具体的点了。

<hr>

498 Diagonal Traverse

题意：给定一个m x n矩阵，按反对角线方向，上下上下交替遍历。

难度：medium

解法：要求很具体了，实现即可。注意处理好<b>边界的下标</b>。

<hr>

499 The Maze III

题意：490的变体。球还是不能在中途改变方向。这次你需要求出到达终点的最短路径，并且返回路径的<b>方向序列</b>。如果存在多种答案，返回字典序最小的。

难度：hard

解法：付费题。这既然不能中途转向，怎么找最小的呢？数据范围不大，可以进行<b>搜索</b>。<b>字典序</b>容易，把方向按照“dlru”排列，搜出来的结果就是字典序最小的。想了5分钟没什么好思路，还是搜吧。要使距离最短，那就用BFS，且<b>用最小堆来做队列</b>。

<hr>

500 Keyboard Row

题意：给定一个标准美式键盘。有一些单词words，请找出其中能在<b>一行按键内</b>打出来的词。

难度：easy

解法：水题，判断字符构成即可。
