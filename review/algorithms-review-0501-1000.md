# LeetCode 一句话题解 - 0501-1000

[返回目录](./README.md)

- [LeetCode 一句话题解 - 0501-1000](#leetcode-一句话题解---0501-1000)
  - [0501 - 0600](#0501---0600)
  - [0601 - 0700](#0601---0700)
  - [0701 - 0800](#0701---0800)
  - [0801 - 0900](#0801---0900)
  - [0901 - 1000](#0901---1000)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000)

## 0501 - 0600

501 Find Mode in Binary Search Tree

题意：给定二叉树，返回其中的<b>众数</b>。如果有多个众数，则按任意顺序返回全部值。

难度：easy

解法：统计并返回即可。众数的意思是，出现频率最大。

<hr>

502 IPO

题意：给定n个项目，你最多可以做k个。如果每个项目需要一定的投资capital，完成后得到一定净利润profit。初始你有启动资本w，请问完成这些项目后，最大的累积资本是多少？

难度：hard

解法：数据规模暗示你，不能O(n^2)枚举。既然每次做项目需要足够资本，那思路就是，在<b>当前资本支持</b>的情况下，总是选<b>净利润最多</b>的项目。因此可以以w为起点，把资本要求低于w的，都放入一个最大堆中。因为我的资本是越来越多的。不存在之后<b>资本反而不够</b>的情况。之后资本更多了，就<b>继续</b>把capital值达到要求的项目放入堆中。每次<b>都取堆顶</b>，也就是净利润最大的项目做。注意，先对所有项目<b>按capital升序排列</b>。总代价是O(nlogn+klogn)，总计<b>O(nlogn)</b>。这个标位hard有点过了，属于比较标准的medium。

<hr>

503 Next Greater Element II

题意：496的变体。和496唯一的区别，就是这次是<b>循环数组</b>

难度：medium

解法：可以用<b>a+a</b>的方式处理循环数组问题，也可以给数组下标<b>取个模</b>。其余思路完全一样。

<hr>

504 Base 7

题意：给定整数，转为7进制。

难度：easy

解法：水题。

<hr>

505 The Maze II

题意：490的变体。和499是同一问题，求<b>最短路径</b>，这次要求输出<b>最短距离</b>，不用给出完整路径。

难度：medium

解法：付费题。既然和499是完全相同的问题，改一下<b>返回参数</b>就行了。

<hr>

506 Relative Ranks

题意：给定n个分数score各不相同。请输出名次，前三名用金银铜牌代替。

难度：easy

解法：水题。

<hr>

507 Perfect Number

题意：给定正整数n，如果n等于它的所有小于自身的约数之和，则n称为<b>完数</b>。请判断n是否为完数。

难度：easy

解法：水题。从2遍历到根号n即可。更高效的话，用<b>素数筛法</b>。但并没有这个必要。

<hr>

508 Most Frequent Subtree Sum

题意：给定二叉树，请求出所有出现频率最高的<b>子树和</b>。如果有多个结果，顺序可以任意。

难度：medium

解法：统计所有子树和，然后找出众数即可。

<hr>

509 Fibonacci Number

题意：斐波那契数，求第n个。已知`F(0)=0,F(1)=1`。

难度：easy

解法：水题。

<hr>

510 Inorder Successor in BST II

题意：285的变体。还是BST的<b>中序后继结点</b>，但这次你<b>没有根节点</b>的位置。但是你有每个节点的<b>parent指针</b>。

难度：medium

解法：付费题。有parent指针，那问题就更简单了。比如当<b>前节点是cur</b>。如果有right孩子，那就right然后一直left；如果没有，那就parent。parent也分两种情况，如果<b>没有parent或者parent的right是cur</b>，那结果就是null；否则，结果就是parent。

<hr>

513 Find Bottom Left Tree Value

题意：给定二叉树，请返回<b>最下一行的最左节点</b>的值。

难度：medium

解法：遍历方式很多，前序比较直观。总之，递归时<b>记录好深度</b>，前序只要找到第一个节点，就是<b>最靠左</b>的。

<hr>

514 Freedom Trail

题意：给定一个字符串<b>圆环</b>ring和一个密码key。你需要正反旋转圆环，把字符<b>对准输入位置</b>，并按键。已知旋转1格算1步，按键也算1步。请问输入密码最少要多少步。

难度：hard

解法：难绷，辐射4是真玩过，这个Freedom Trail就是引你加入Railroad组织的一个秘密任务。这个方式其实就和几十年前的<b>老式旋转拨号的电话</b>一样。<b>第一念头是贪心</b>，第二念头是<b>贪心不对</b>。可以设想一些反例来证明。因为你必须<b>按key中字符的顺序</b>逐个完成，这个问题就可以转化为很规则的DP，那种<b>“只依赖上一步”的DP</b>。剩下不多讲了。

<hr>

515 Find Largest Value in Each Tree Row

题意：给定二叉树，返回每一行的最大值。

难度：medium

解法：还是遍历，<b>按深度</b>记录好每行最大值即可。

<hr>

516 Longest Palindromic Subsequence

题意：给定字符串s，求出最长回文子序列长度。

难度：medium

解法：给定n的规模，<b>O(n^2)的DP解法</b>非常容易想，不详细讲了。那么<b>O(n)的做法有吗</b>？想了五分钟，没什么好思路。罢了。

<hr>

517 Super Washing Machines

题意：给定n元素的数组，在每次操作，你可以选任意多个元素，并<b>同时</b>从每个元素-1，并给它的<b>某个相邻元素</b>+1。这些在一次操作内，同时完成。请问至少多少次操作，能让<b>所有元素相等</b>？如果做不到，返回-1。

难度：hard

解法：首先是求和，除以n。如果有余数，当然返回-1。然后就是考虑<b>高于平均值ave</b>的元素，这些元素需要进行-1，并把+1给那些低于平均值ave的元素。如果你<b>具体去想</b>应该怎么移动，那就想不出来了，因为<b>太复杂</b>。有一定思维比较简单，考虑<b>对称性</b>。你把(a,b)变成(a+d,b-d)，要耗费d次操作。但你选择变a还是变b，则无所谓，因为最终结果相同。因此，从第一个开始，每个元素都必须变成ave，不论大还是小。因此，考虑`abs(nums[i]-ave)`。然后，当你连续遇到几个大于ave的元素，那么这些差值是要<b>累加</b>的；但如果你恰好遇到一大一小，这两个差值则可以<b>抵消</b>。因此，这时的计算则不能用abs()了。总体思路和代码非常简洁。<b>我当年没想出来</b>，现在读了代码，尝试再理解一遍。这种hard题，难度全在于灵机一动，<b>想不到就是0分</b>。没意思。

<hr>

518 Coin Change II

题意：322的变体。给定n种硬币和对应面值。如果每种硬币有无限枚，请问组成amount金额有多少种方法？

难度：medium

解法：硬币数量无限，标准的<b>完全背包问题</b>。循环时，从前往后扫即可。

<hr>

519 Random Flip Matrix

题意：有一个m x n的01矩阵。请设计数据结构，实现reset()，重置所有元素为0；实现flip()，随机反转一个<b>值为0的元素</b>。尽可能减少对随机函数的调用，并保证机会均等。

难度：medium

解法：既然要求找到值为0的元素，并以<b>等概率</b>反转。那就需要把所有值为0的元素位置记下来。用`i*m+j`这种形式记，然后均匀抽样即可。之前有过类似的随机取数的题目，用一个list，<b>随机取样并交换到末尾</b>，然后pop的方式进行删除。看了下我当年的代码，完全不知道在讲什么。又看了下题目的<b>数据规模</b>，明白了。用O(n^2)的空间直接记录位置，是不允许的，会<b>爆内存</b>。难怪当年查资料用了一个叫<b>线性同余生成器</b>，LCG。这个是一种经典的伪随机数生成算法，因为是<b>生成器</b>，结果自然是<b>不断迭代产生</b>的。这也就避免了全量计算+存储的开销。所以这题的考点就是这个，这有点<b>过于刁钻+专业</b>了。当然，其实基于我上面给的乱序+交换做法，也可以做。还是用<b>生成器思路</b>，先把<b>行顺序随机</b>，再把每行之内的<b>列顺序随机</b>这样也是可以的。这个做法也有学名，叫<b>Fisher-Yates乱序</b>。

<hr>

520 Detect Capital

题意：给定英文单词，检验大写字母用得是否正确。

难度：easy

解法：水题，英语语法。

<hr>

521 Longest Uncommon Subsequence I

题意：给定两个字符串，返回<b>最长不公共子序列</b>的长度。意思是，只是其中一个字符串的子序列。

难度：easy

解法：<b>脑筋急转弯</b>。两者之中<b>更长的</b>一个就是，如果两者完全相同，那就-1。

<hr>

522 Longest Uncommon Subsequence II

题意：521的变体。

难度：medium

解法：521是闹着玩，这题是认真的。对于两个串，只要<b>不完全相同</b>，就有答案。现在有n个串，则条件是某串ss是<b>其中1个</b>的子序列，对<b>其他n-1个</b>，则均不是子序列。首先考虑特殊情况，如果存在两个串s和t完全相同，即s==t，那么s的任何子序列，都是t的子序列。因此这时<b>把s和t都排除</b>。所以数组中，只剩下互不重复的元素，从中选一个最长的就行了。它的长度就是答案。因此，这题还是超级简单，只不过要<b>多想一点点</b>。

<hr>

523 Continuous Subarray Sum

题意：给定一个数组nums和整数k，<b>好数组</b>的定义是，长度至少为2且和为k的倍数。请判断nums是否存在一个<b>好子数组</b>。

难度：medium

解法：思路很容易。因为要确定子数组和为k的倍数，因此在记录子数组和的时候，只用<b>模k记录</b>即可。还是用前缀和的方式，如果前缀和%k=r，那只用判断r是否为0，或者r是否已存在于记录中。为0则为k的倍数；已存在记录中，则表示<b>之前某个前缀和</b>与当前前缀<b>同余</b>，两者相减是k的倍数。这两种情况都是true。如果始终不满足，则false。

<hr>

524 Longest Word in Dictionary through Deleting

题意：给定字符串s和一个词典dictionary。请判断s删去一些字符后，能否得到dictionary中的词，并找出<b>最长的的一个</b>。如果存在多个答案，返回<b>字典序最小</b>的。

难度：medium

解法：以数据规模来看，似乎能很快得到<b>直白解法</b>，但又想不出更高效的。对词典按(-长度,+字典序)二维进行排序，这样<b>最长且字典序最小</b>的就在前面。然后逐个匹配，匹配的就是子序列。判断每个单词是否为s的<b>子序列</b>即可。找到了就返回。这样总体代价是<b>O(nw*ns)</b>，nw和ns分别为单词个数和字符串长度。暂时想不出能优于这个复杂度的解法。

<hr>

525 Contiguous Array

题意：给定一个01数组，请求出<b>0个数等于1个数</b>的最长子数组的长度。

难度：medium

解法：这种题目大多是<b>前缀和统计</b>或者<b>滑动窗口</b>。如果是前缀和统计，那个比如前i位总共p个1，前j位总共q个1。要求`i==2*p`，或者`i-j=2*(p-q)`。这个好像不太方便确定j的位置。其实<b>稍微变一下</b>，这方法就行得通了。<b>遇到1就+1，遇到0就-1</b>即可。这样，我们要找的情况，其实<b>“子数组和”恰好是0</b>。还是用<b>前缀和统计</b>，搞定了。如果你是从滑动窗口入手的话，会发现很难走通。这题看似有点<b>取巧</b>，其实也用到了一个物理思维，就是<b>坐标系变换</b>。如果坐标系没用对，那<b>所有东西都在变</b>，你找不到锚定位置。但如果设对了，你有一个<b>不动点</b>作为参照，问题就简单了。本来是统计(0,1)，却改成了统计(-1,+1)对吧？

<hr>

526 Beautiful Arrangement

题意：给定一个1-n的排列。我们以1为下标起点，定义<b>漂亮排列</b>。如果第i位元素是a[i]，每个位置i都满足<b>i整除a[i]或者a[i]整除i</b>，则称这个排列a是漂亮排列。给定整数n，请返回长度1-n组成的漂亮排列个数。

难度：medium

解法：<b>n很小</b>，只到15。不过15!也不小了。这就是明示你，直接搜。考虑一下漂亮排列的定义，涉及到<b>a|b或者b|a这种约数、倍数关系</b>，这个是很<b>苛刻</b>的，因此满足条件的排列个数<b>肯定不多</b>。这也给你做暴力搜索提供了保障。<b>做好剪枝</b>即可。

<hr>

527 Word Abbreviation

题意：320的变体。还是单词缩写问题，缩写规则就不重复了。给定一个词表，给每个单词生成一个<b>不会和其他单词冲突</b>的缩写。要求缩写长度最短，如果缩写长度<b>不短于</b>原单词长度，则<b>不做处理</b>。做缩写时，以<b>保留最短的唯一前缀</b>为原则。

难度：hard

解法：付费题。以数据范围来看，单词个数在几百，<b>单词长度也可以达到几百</b>。因此<b>单词比较长</b>是主要的难点。题目中最重要的条件是，<b>保留前缀</b>。比如<b>abcde和abcdx</b>，如果缩写为4e、4x显然更短。但按题目要求，你<b>不能直接在开头用缩写</b>，所以结果应该是保留abcde和abcdx，不缩写。有这个条件就简单多了。先按`(长度,字典序)`二维进行排序。<b>同长度之间</b>才可能产生冲突。然后，对相邻两个词做前缀判断即可。

<hr>

528 Random Pick with Weight

题意：给定一个带权重的数组，权重为w[i]。请随机返回下标[0,n-1]，返回概率<b>按照权重的比例分配</b>。

难度：medium

解法：权重的所有元素总和为<b>sum</b>。首先这些权重是非负的（如果是负数就有点离谱），求前缀和。从0开始，依次是w[0]、w[0]+w[1]、...、w[0]+...+w[n-1]，<b>总共n+1个值</b>。每次取[0,sum)的一个<b>随机数</b>，按照这个随机数落在<b>n个区间中的哪一个</b>，来确定下标应该取几。这个确定区间的代价是O(logn)，用<b>二分查找</b>得到。

<hr>

529 Minesweeper

题意：扫雷游戏，规则就不细讲了。现在给定一个游戏状态，并给出点击的位置。请计算点击后的游戏状态。

难度：medium

解法：如果点开了雷，游戏结束。如果点开空地且<b>周围没有雷</b>，则进行搜索并打开附近的格子。如果点开了雷且<b>周围有雷</b>，则只打开当前格子。很纯粹的<b>搜索+模拟题</b>，按要求完成即可。

<hr>

530 Minimum Absolute Difference in BST

题意：给定一个二叉搜索树，返回两个节点的最大差值。

难度：easy

解法：既然是BST，那<b>最大值-最小值</b>就是答案了。一个最左一个最右。

<hr>

531 Lonely Pixel I

题意：给定一个黑白矩阵，B黑W白。如果一个黑点所在的<b>行和列</b>没有其他黑点，则称这个黑点是<b>孤独黑点</b>。请求出孤独黑点的个数。

难度：medium

解法：付费题。对<b>所有行、所有列</b>都统计黑点个数。然后再扫一遍所有点，如果是黑点，就看看<b>本行本列</b>的黑点个数即可。复杂度O(nm)。

<hr>

532 K-diff Pairs in an Array

题意：给定数组nums，求出所有<b>`i!=j`</b>且<b>`nums[j]-nums[i]=k`</b>的(nums[i],nums[j])对的个数。结果要求对值去重，只统计<b>唯一值</b>的个数。

难度：medium

解法：用哈希表统计值的个数。对于当前值x，在哈希表中寻找x+k<b>是否存在</b>（因为只统计唯一值个数）。如果你同时找x+k和x-k，结果就要除以2。对于k=0的情况，可以特殊处理一下。

<hr>

533 Lonely Pixel II

题意：531的变体。请找出<b>n行</b>，使得这n行恰好每行<b>长得完全一样</b>，且都有<b>n列</b>是<b>黑点</b>。返回<b>n的最大值</b>。

难度：medium

解法：付费题。题目神一般的拗口，<b>看不懂</b>。带着例子又看了好几遍，终于明白了。关键在于n行n列，且<b>这n行完全一样</b>。行列数的返回都在200内，因此可以勉强接受O(n^3)的解法。看了下，我当年确实写了个<b>三层循环</b>的做法，不过稍微优化了一下。对一整行，采取8元素一个byte，用byte表示字符，存为字符串的方式。这样就方便比较两行是不是完全相同了。如此的话，复杂度其实还是O(n^3)，但形式上优化到O(n^2)了。<b>最终效率可接受。</b>

<hr>

535 Encode and Decode TinyURL

题意：短网址设计，请实现编码、解码算法。

难度：medium

解法：这题是<b>最经典的系统设计题</b>之一。我之前还在某次没准备好的面试上，因为这题挂过。如果你去搜技术博客，会发现有人为这题写了<b>万字长文</b>，那个篇幅和图文并茂程度，堪称<b>卷中卷</b>。其中<b>可以涉及</b>字符串编码、压缩率、哈希冲突、签名算法的安全性、微服务的性能调优、数据库的分库分表设计、KV存储vs关系数据库等等各种话题。也是因为这个，这题也从一道经典的面试题，逐渐成了一种<b>魔怔八股文</b>的代表。现在面试的话，这题已经是<b>必背八股文</b>了，讲不出个几百上千字，面试官就断定你没背过。当然你也可以三五句话就完事，无非是<b>当场淘汰</b>而已。当年我没做这题，直接return完事了。现在想想，我觉得面对这种题的<b>正确心态</b>，应该是“我应该多学，而且要<b>学明白</b>。然后保持一个好心态，把<b>想说的说清楚</b>。”而不是玩儿命地<b>背</b>，或者刻意<b>说一大堆</b>，显得自己准备过很多。话说回来，也不能因为它是八股，就反感。要是<b>连八股都不会</b>，那只能叫<b>懒</b>。

<hr>

536 Construct Binary Tree from String

题意：给定一种特定格式的<b>二叉树前序遍历结果</b>，请重建这个二叉树。

难度：medium

解法：付费题。这个格式，其实不做说明，你也看得出是<b>前序遍历</b>。“根(左子树)(右子树)”，<b>递归解析</b>，并建立整棵树即可。

<hr>

537 Complex Number Multiplication

题意：给定两个用字符串表示的<b>复数</b>，请做乘法。

难度：medium

解法：<b>复数</b>的应用非常广泛，尤其是<b>物理和一些工程领域</b>（当然也源于物理）。因此很多编程语言直接在<b>基础库</b>里就支持复数运算了。按运算规则，解析、相乘即可。`(a+bi)*(c+di)=(ac-bd)+(ad+bc)i`。

<hr>

538 Convert BST to Greater Tree

题意：给定一个二叉搜索树，请将其转换为<b>“较大树”</b>。意思是，每个节点的值，都额外加上<b>所有大于它的节点的值之和</b>。

难度：medium

解法：这个可以用<b>后序遍历</b>来处理。递归时，返回当前子树的总和，但在返回后，<b>只使用右子树之和</b>。让<b>当前根节点</b>加上右子树总和</b>。看了下以前的代码，<b>思路</b>和这个一样，<b>写法</b>稍有不同。这个不重要。

<hr>

539 Minimum Time Difference

题意：给定一些HH:MM格式的时间，请找出其中两个时间差的最小值。

难度：medium

解法：都转换为整数，<b>排序、找最小差值</b>即可。注意，<b>第一个和最后一个</b>也要算，考虑23:59到00:00的情况。

<hr>

540 Single Element in a Sorted Array

题意：一个<b>有序</b>数组，所有其他元素都出现2次，只有1个元素出现1次。请找出这个单独元素，要求O(logn)时间O(1)空间完成。

难度：medium

解法：之前用<b>异或</b>的做法已经处理过了，时间是O(n)。这次要求<b>O(logn)</b>？关键在于有序。因为是有序的，那比如112234455。你看某个位置i，如果`a[i]==a[i+1]`，<b>这是前半</b>；如果`a[i]==a[i-1]`，<b>这是后半</b>。两半的中间那个值，就是单独的值。所以<b>用二分来夹这个范围</b>，直到定为到它为止。注意<b>边界case</b>，比如答案在最左或者最右的情况。

<hr>

541 Reverse String II

题意：344的变体。给定字符串s，对<b>每2k个字符</b>，反转<b>前k个</b>。如果尾部不足k个，则反转剩余的。如果尾部够k个，则照例反转。

难度：easy

解法：水题。

<hr>

542 01 Matrix

题意：给定一个01矩阵，请求出每个位置到<b>最近的0</b>的距离。距离计算按照<b>行+列</b>（即曼哈顿距离）为准。

难度：medium

解法：把所有0位置作为起点，进行<b>一次BFS</b>即可。奇怪的是，我以前写的BFS代码怎么没用队列？

<hr>

543 Diameter of Binary Tree

题意：给定一个二叉树，定义它的直径为树中<b>任意两点</b>能得到的<b>最长路径</b>的长度。

难度：easy

解法：既然是选任意两点，也就<b>不一定经过根节点</b>了。所以<b>在每层都递归</b>，然后拼出<b>左右最长路径之和</b>。注意，<b>单边的情况</b>也适用这种解法，另一边路径为0就是单边的。这题接近medium了，不太easy。

<hr>

544 Output Contest Matches

题意：给定n支队伍，你需要进行n//2组配对。给定1-n的排名，按照<b>强对弱</b>的原则匹配n//2组。并

难度：medium

解法：付费题。读了两遍才明白题目<b>到底在问什么</b>。名次1-n，按照(1,n)、(2,n-1)...之类进行<b>强弱配对</b>。然后按照一种递归嵌套的形式输出。实际的难点在于<b>拼凑这个字符串</b>，递归做吧。仔细观察<b>“(((1,8),(4,5)),((2,7),(3,6)))”</b>这个例子，找出规律。

<hr>

545 Boundary of Binary Tree

题意：给定二叉树，请按逆时针方向，返回所有<b>边界节点</b>。边界包括根节点、最左、最下、最右所有节点，注意去重。

难度：medium

解法：付费题。题目给的示例有点奇怪，为什么是`[1,3,4,2]`而不是`[1,2,3,4]`？这题的麻烦之处在于理解，有的情况就很迷惑。比如<b>“最下”</b>，是不是只有<b>深度最大的叶节点</b>才算最下？考虑到这几种情况的处理逻辑都不太一样，还是<b>各自写代码处理</b>好了。最后<b>统一做去重</b>，并拼装出完整结果。看了下以前的代码，看来我当年<b>没写出来</b>，或者说写得太难看了。这题可以说很考验<b>写递归的技巧</b>了，有难度。
<hr>

546 Remove Boxes

题意：有n个盒子，每个都有颜色，用一个整数表示。每次你可以选一些连续的同色盒子并拿走。如果总共有k个，则得分k*k。请问拿走所有箱子，你能得到的<b>最大分数</b>是多少？

难度：hard

解法：这题和之前的<b>312爆气球</b>非常像，也是<b>从中间消除</b>，然后<b>让两边拼到一起</b>。既然如此，那DP的思路也可以类似了。做DP之前，先要想清楚一个原则。如果有连续10个同色盒子，那我必然要消除10个，而不会选9个。因为10*10得到100分，做任何拆分都只会得到更少分数。所以对连续的同色盒子，是<b>不能做拆分的</b>。把数组按连续同色的方式进行<b>统计</b>，得到<b>统计数组a</b>。比如`[3,3,3,2,2,4,4,4,4,3,3]`，对应统计数组就是[(3,3),(2,2),(4,3),(3,2)]再对统计数组做<b>DP</b>。以本题的数据规模，O(n^3)的解法不难想到。用dp[i][j]表示第i-j断的最大得分。如果`a[i][0]==a[j][0]`，<b>两端颜色相同</b>，可以拼起来，则考察`dp[i+1][j-1]+(a[i][1]+a[j][1])^2`是否是更优解。除此之外，枚举ij之间的每个k，看看<b>两段拆分</b>的结果，也就是`dp[i][k]+dp[k+1][j]`。看了下当年写的代码，我开了个三维数组，这是没必要的。二维足够了。

<hr>

547 Number of Provinces

题意：给定一个<b>邻接矩阵</b>表示的<b>无向图</b>，求<b>连通分量</b>个数。

难度：medium

解法：把题目原话<b>翻译过来</b>就是这个。<b>并查集</b>解决。

<hr>

548 Split Array with Equal Sum

题意：给定一个n元素数组，请问是否存在下标`i<j<k`，使得<b>去掉对应三个元素</b>后，得到的<b>四个子数组的和都相等</b>。

难度：medium

解法：付费题。注意，要<b>去掉</b>ijk三个位置的元素。以n的规模，暗示你解法应该是<b>O(n^2)代价</b>的。那就这么做。<b>第一维i</b>，枚举。<b>第三维k</b>，枚举，但是要做检查。第二维j，需要夹在ik中间，而且我<b>只判断是否存在</b>，而不用找出它。怎么找j呢？用哈希表记录前缀和，看看你要找的某个前缀和是否存在即可。比如nums[0:i]这个前缀和是sm，那么我要找的值，就是`sm+nums[i]+sm`。j前面有<b>两段子数组+一个nums[i]</b>。看了下我以前的代码，不是这么做的。而是<b>从j开始枚举</b>，然后两边查找<b>ik</b>。确实<b>以前的做法更好</b>，因为思路是<b>对称的</b>。

<hr>

549 Binary Tree Longest Consecutive Sequence II

题意：298的变体。给定一个二叉树，你可以选任意两点作为端点，得到一个节点序列。请返回能得到的节点序列是连续序列的最大长度。连续序列指<b>公差为1的等差数列</b>。

难度：medium

解法：付费题。公差是+1或者-1其实无所谓，因为你总是<b>可以反着走的</b>。就用+1为准吧。那么对于二叉树，你毕竟<b>不能向上走</b>，所以还是采取<b>左右搜，然后拼接起来</b>的思路。比如，当前根节点的值为3，那我向左向右，都搜以3为起点，<b>能延伸多少步</b>等差数列。然后<b>用左+1拼右-1，或者左-1拼右+1</b>。比如左边是1-2-3，右边是3-4-5-6，那拼起来就是<b>1-2-3-4-5-6</b>。方向反过来，道理还是相同。对于<b>单边</b>的情况，这种解法也适用，相当于另一边的路径为0。

<hr>

551 Student Attendance Record I

题意：给定一个学生的出勤记录，P到A缺L迟。如果学生没有<b>2天以上缺席</b>，没有<b>连续3天迟到</b>，则可以得<b>出勤奖</b>。请判断是否能得奖。

难度：easy

解法：水题。

<hr>

552 Student Attendance Record II

题意：551的变体。规则就不重复了。现在给定长度n，请求出所有<b>可以得奖的</b>长度为n的记录个数。结果<b>模1e9+7</b>。

难度：hard

解法：很显然，这是个DP题。但怎么设计递推关系呢？<b>缺席</b>是个数，<b>迟到</b>是连续个数。缺席只能是0或1，迟到最多是连续2个，那么一天内的状态记录应该是2*3的，2表示A取值{0,1}，3表示L取值{0,1,2}。因为每天的记录只依赖<b>前一天</b>，则O(n)空间可以优化为O(1)。总体实现，还是老老实实用一个`dp[2][2][3]`的数组，把所有递推式子都写下来，这样<b>不容易出错</b>。我当年的代码很奇怪，现在<b>无论如何看不懂了</b>。这就是<b>关键思路不写注释</b>的恶果。现在让我重做这题，我会选择开个`dp[2][2][3]`数组。

<hr>

553 Optimal Division

题意：给定一个数组nums，表示一个除法式子`nums[0]/nums[1]/.../nums[n-1]`。你可以在其中任意添加括号来改变运算顺序。请求出能得到的<b>最大结果</b>。

难度：medium

解法：当然是<b>DP</b>了。按照被`除数/除数`考虑，那么为了结果最大，被除数应该大，除数应该小。所以问题就转化成了<b>同时求</b>某个子问题的<b>最大值和最小值</b>。对于dp_max[i][j]，枚举dp_max[i][k]/dp_min[k+1][j]的最大值。<b>反之亦然。</b>

<hr>

554 Brick Wall

题意：给定一面砖墙，由很多行组成，每行都有一些<b>长长短短</b>的砖头，每行的<b>总长度加起来相同</b>。现在从上到下画一条线，请找到一条线，使其<b>穿过最少的砖头数</b>。如果从砖头<b>边界</b>经过，则不算穿过。

难度：medium

解法：首先，你当然不会真的去划线，比如找个2.5、3.7之类的中间位置。而是会考虑一段区间被<b>几个叠起来的砖头</b>覆盖了。没错，<b>区间覆盖</b>。所以，其实可以所有值做一下统计，然后用区间覆盖的方式，统计一下哪个区间的覆盖次数最少，这个最少的次数就是答案。题目还告诉你，墙的总长度不超过20000，那就可以直接开这个数组来做<b>覆盖统计</b>了。因为是批处理，可以直接用<b>后缀和</b>的方式。当然，熟练的话，用<b>树状数组</b>完成也可以。还有一种<b>更简洁</b>的思路，一条线从上往下，总是要穿过一些砖头边界的。那么，不是穿过边界的，就一定是<b>穿过砖头中间</b>了。所以，对每个边界值，数一下<b>个数</b>，用<b>`高度-个数`</b>就是穿过的砖头数了。

<hr>

555 Split Concatenated Strings

题意：给定一组字符串，允许你<b>反转</b>其中的任意串。把处理完之后的串，<b>连成一个环</b>，再从环的任意一个字符处切开，变成一个长字符串。请返回能得到的<b>字典序最大</b>的字符串。

难度：medium

解法：付费题。首先反转好理解，如果反了之后<b>字典序更大</b>，那就反。连接好之后，对长字符串的移位比较，好像也没什么特别高效（其实肯定有的）的做法。直接逐个比较好了。题目限定的<b>字符串长度之和是1000</b>，就是告诉你，就算是<b>暴力比较</b>也让你过了吧。

<hr>

556 Next Greater Element III

题意：496的变体。给定一个整数n，请返回大于n，且数位组成和n相同（但顺序不同）的最小整数。且这个数必须在int32范围内，如果不存在或者超出范围，则返回-1。

难度：medium

解法：这个题目要求<b>有点呆板</b>了。int32毕竟是某些语言限制的，并非所有。有的语言<b>int是64位</b>，有的甚至可以自动转为<b>大数</b>的。回到问题本身，这个其实就是next permutation，<b>把n转成一个字符串</b>，找出这些数位的<b>下一个排列</b>，再转回整数。对结果检验一下，是否<b>>n且<INT_MAX</b>。比如132，之后是231、312、321，再之后就没了。

<hr>

557 Reverse Words in a String III

题意：151的变体。给定英文句子，只反转单词内的字母，不反转单词顺序。

难度：easy

解法：水题。

<hr>

558 Logical OR of Two Binary Grids Represented as Quad-Trees

题意：<b>四叉树</b>，定义就不讲了。现在给定两个四叉树q1和q2，都代表n*n的01矩阵。请求出它们的<b>逻辑或</b>，并用四叉树表示。

难度：medium

解法：`0|x=x,1|x=1`，按这两条规则就行了。递归时，在每一层对<b>2*2四个子问题</b>进行处理。对于整整、整分、分分三种情况，各自处理好就行了。<b>整</b>表示到达了<b>叶节点</b>，<b>分</b>表示下面<b>还有分叉</b>。这题的代码，其实比用嘴说还简单。看了下我以前的代码，明显<b>写复杂了</b>。用python的话，应该能在20行左右写完。

<hr>

559 Maximum Depth of N-ary Tree

题意：求N叉树的最大深度。

难度：easy

解法：和二叉树没什么不同的，递归即可。

<hr>

560 Subarray Sum Equals K

题意：给定数组nums和整数k，请返回其中子数组和为k的个数。

难度：medium

解法：子数组题，用哈希表统计<b>前缀和</b>即可。比如当前前缀和是x，那就找x-k的个数。

<hr>

561 Array Partition

题意：给定一个2n长度的数组nums，请分出n个数对`(a_i,b_i)`，使得这n对的最小值之和`sum(min(a_i,b_i))`最大。请返回这个<b>最大和</b>。

难度：easy

解法：easy？？？这肯定是脑筋急转弯，坑人的。既然条件讲的这么拗口，那我们仔细理解一下。要<b>最小值，求和，最大</b>。比如`[1,2,3,4,5,6]`，那应该取`1+3+5=9`，分组应该是`(1,2),(3,4),(5,6)`。可以用反证法论证，如果你做任何交换，要么<b>不影响结果</b>，要么<b>会让小值更小</b>，而大值不影响结果，从而得到<b>更小的和</b>。因此，这种选法是<b>最优的</b>，所得之和最大。所以，思路就是<b>排好序</b>，按<b>13579</b>这样选。具体证明过程就不写了，脑子里跑一下就行了。

<hr>

562 Longest Line of Consecutive One in Matrix

题意：给定一个01矩阵，请找出<b>连续1</b>的最大长度。方向可以是横、竖、正反对角线。

难度：medium

解法：付费题。没什么技巧，就是从这四个方向<b>都扫一下</b>就行了。注意<b>对角线</b>方向处理好下标边界，别弄错了。

<hr>

563 Binary Tree Tilt

题意：给定二叉树，返回每个节点的<b>倾斜值</b>之和。倾斜值的定义是<b>左右子树节点和</b>的<b>差值的绝对值</b>。

难度：easy

解法：虽然描述的挺复杂，不过还是递归处理就好了。<b>求子树和，算差值，向上返回，再求和</b>。对于easy难度，这个要求确实挺麻烦的。不过代码确实很短，用python如果写得极简的话，3-5行代码应该足够了。

<hr>

564 Find the Closest Palindrome

题意：给定一个字符串表示的整数n，请找出<b>不等于它</b>，且<b>和它最接近</b>的回文数。

难度：hard

解法：限定了n的长度不超过18位，这其实是在64位整数范围内，因此可以用长整型来表示数据。当然，用字符串也可以。因为是回文数，那么我考虑<b>从中间位开始变</b>，这个变化是<b>最小的</b>。因为两边必须对称，变动<b>最低位</b>也等于变动<b>最高位</b>。举例子，比如<b>13579</b>。让它变小，那就是13531，中间的5不动，下面变小即可。让它变大，那就是13631。对于偶数位的情况，123456。变小，就是123321。变大，就是124421。那么129934呢？变小，是129921。变大，是130031。所以你可以只考虑一半，让这一半“+1”。思路不算很复杂，不过代码写得挺复杂。还是<b>实现得不太好</b>。注意一些<b>边界case</b>，比如99999，下一个是100001，上一个是99899。

<hr>

565 Array Nesting

题意：给定数组nums，nums是`0~n-1`的一个排列。选定一个起始下标k，依次生成<b>有限集合</b>`s(k)={nums[k],nums[nums[k]],...}`。给定k的所有取值，请求出s(k)的<b>最大大小</b>。

难度：medium

解法：这个就是非常经典的<b>置换群</b>（permutation group）。<b>群论</b>并不在基础的工科课表里，没学过很正常。但置换群属于其中一种挺有意思的组合数学结构。回到问题本身，这样不断取nums[]运算，总会形成一个环。比如排列`[1,3,2,0]`，用置换群可以写作`(0,1,3)(2)`，表示013构成一个循环，2构成一个循环。<b>计算置换群的总代价是O(n)</b>，因为你在算出所有循环时，每个值<b>只访问一次</b>，不会重复的。

<hr>

566 Reshape the Matrix

题意：实现类似MATLAB（或者numpy）里的reshape功能，将<b>二维矩阵</b>打成<b>一维数组</b>。

难度：easy

解法：多维数据的存储方式，默认是<b>行优先（row-major）</b>的。或者对于n维数据，总是<b>第i维优先于第i+1维</b>。n行m列，`i*m+j`。在做矩阵运算、缓存命中等<b>特定场景</b>下，<b>列优先（column-major）</b>也是有应用的。

<hr>

567 Permutation in String

题意：给定字符串s1和s2，判断s2的某个子串是否是s1的排列。

难度：medium

解法：s2的子串，是，s1的排列。所以，不能把s1、s2直接排个序。得用字符统计的办法。s1、s2都比较长，O(n^2)的匹配也不可接受。还是滑动窗口吧。所幸，这题的滑动窗口很简单，因为<b>窗口大小是固定的</b>。这样就非常简单了，每次<b>移动一位，调整窗口</b>，<b>判断字符统计</b>是否相同。搞定了。

<hr>

568 Maximum Vacation Days

题意：给定n个城市的有向图，标号`0~n-1`。你<b>从0点出发</b>，每周可以<b>在一个城市度假</b>或者<b>在周一</b>飞去<b>另一个城市度假</b>。第j周在第i城市的假期数是days[i][j]。请安排行程，以获得最长的假期天数。

难度：hard

解法：付费题。题目又长又复杂，读完都费老劲。图论题，可又像是DP题。应该是<b>图论+DP题</b>。所以，可以采取dp[i][j]表示<b>第j周在第i城</b>能得到的<b>最大假期之和</b>，然后以此进行<b>BFS</b>。BFS起点当然是从0城出发。讲道理，这个hard也不能说思维特别难，但<b>图论+DP</b>这个组合也<b>够麻烦了</b>，hard确实合理。看了下我的老代码，没用队列，<b>换了种方式做BFS</b>。思维是一样的。

<hr>

572 Subtree of Another Tree

题意：给定两个二叉树t1和t2，判断t2是否和t1的某个子树（包括自身）完全一样。

难度：easy

解法：递归暴力匹配的解法就不说了。重点说一下问题转化的思维。如果用什么奇怪的办法，直接做到<b>线性匹配两棵树</b>，肯定很难想。但<b>字符串匹配</b>的O(n+m)解法，你知道。<b>二叉树序列化为字符串</b>的O(n)解法，你也知道。两者结合起来，不就是线性的解法了？<b>问题转化</b>，这个思维非常重要。不只是做这些应试题，是整个人生的思维。

<hr>

573 Squirrel Simulation

题意：在一个二维n x m矩阵上，给定<b>松鼠、树、一些松子</b>的位置。松鼠每次能<b>拿一个松子放到树下</b>，直到拿完。请求出松鼠移动的<b>最小总距离</b>。

难度：medium

解法：付费题。除了一开始松鼠拿松子之外，之后每次松鼠都是<b>从树的位置出发</b>，所以对于这些松子，顺序都无所谓了。因此，我要找一个<b>松鼠相对于树</b>离得最近的松子作为<b>第一颗</b>。后面的每颗，就<b>无所谓顺序</b>了。

<hr>

575 Distribute Candies

题意：给定n个糖果，每个的种类用一个整数表示。如果n是偶数，从中选出一半糖果，最多能得到多少不同种类？

难度：easy

解法：用哈希表对数组的值进行<b>计数</b>。然后<b>按key不断轮询</b>，每轮询一个，计数-1。减到0了，则删除对应key。这样能保证每次取的元素都<b>尽量不相同</b>。取到了n/2个元素时，结束轮询。取到的元素都放入<b>集合</b>中，<b>统计个数</b>即可。当然，这题其实是<b>脑筋急转弯</b>。直接`min(len(nums)//2,len(set(nums)))`就搞定了，想想为什么？很无聊，对吧。

<hr>

576 Out of Boundary Paths

题意：给定一个m x n矩阵，有个球，每次可以上下左右移动一格。给定<b>初始位置、最多移动步数</b>。请问有多少种办法可以<b>让球出界</b>？对结果<b>模1e9+7</b>。

难度：medium

解法：数据规模并不大，<b>不用想得太复杂</b>。从起点开始，执行BFS。对于BFS到边界时，如果还有步数，就可以让球出界。这个BFS最好<b>不用队列</b>，而是用<b>两个交替的哈希表</b>来做。看了下我以前的代码，比想象中的复杂。现在让我写，应该比这个短得多了。

<hr>

581 Shortest Unsorted Continuous Subarray

题意：给定一个数组nums，如果存在一个子数组nums[i:j+1]，对应这个子数组排序，就能使整个数组都有序。请找出符合条件的<b>最短子数组</b>的长度。

难度：medium

解法：题目是真拗口，但要问的东西其实不难。如果中间某段nums[i:j+1]有序了，能让整个数组都有序，那说明两点：`nums[i-1]<=min(nums[i:j+1])`，`nums[j+1]>=max(nums[i:j+1])`。因此，你可以从两边逐渐确定这个边界。比如<b>左边</b>，从0开始，看看nums[i]是否<=右边nums[i+1:n]的最小值，是的话就右移，<b>直到不满足为止</b>。右边的情况，<b>反之亦然</b>。因为<b>后缀最小</b>和<b>前缀最大</b>都是O(n)代价可以得到的。因此这个边界可以在<b>O(n)代价</b>确定下来。如果最后发现边界是`i=0,j=n-1`，说明要<b>排序整个数组</b>；如果发现边界是`i>j`，则说明数组已经有序了，<b>不用排序</b>。

<hr>

582 Kill Process

题意：给定一些id用整数表示的进程，除了<b>根进程</b>外，其他进程都有1个父进程，0-多个子进程。整个结构是<b>一棵进程树</b>。给定一个你<b>要终止的进程id</b>，返回所有被终止的<b>进程id列表</b>。

难度：medium

解法：付费题。既然是树，那就<b>建立这棵树</b>，然后<b>遍历并删除</b>对应的终止进程<b>所在的子树</b>。只为了完成这题的话，用<b>并查集</b>处理也很方便。直接把kill的根节点指向自己，这样<b>这棵子树就孤立了</b>。再遍历进行<b>find操作</b>，就能得到<b>所有属于这个子树</b>的进程。

<hr>

583 Delete Operation for Two Strings

题意：给定字符串s1和s2，每次允许你从其中一个串删除1个字符。请问至少多少次操作，可以让两串相同？

难度：medium

解法：按<b>子序列</b>的逻辑判断。为什么是子序列？因为<b>删字符</b>，子序列就是这么得到的。比如s1和s2目前的最长公共子序列是ss。那么子序列是对称的。s2和s1，子序列也是ss。我能不能得到比ss这个更长的结果？肯定不能啊。所以，转化为<b>LCS问题</b>了。教科书级的<b>DP问题</b>，O(n^2)时间O(n)空间解决。

<hr>

587 Erect the Fence

题意：给定二维平面上，一些树的坐标。请用一个篱笆把所有树围起来。为了尽可能省材料，篱笆要<b>贴着一些树</b>。请返回所有篱笆贴着的树的坐标。

难度：hard

解法：这下好了，<b>凸包</b>都出来了。除了搞竞赛的人必须会，一般人不一定学过。<b>没学过，肯定写不出这算法。</b>凸包是什么呢？凸包就是一个<b>最小的凸多边形</b>，能把点集都围进去。凸多边形是什么呢？就是每个角都<b>不超过180度</b>的多边形。这个算法是<b>用叉积的符号</b>来判断一个点是否应该被包含在<b>凸包的点集</b>里。脑子里想象一下，<b>左转右转</b>。之前已经有一题<b>469</b>，用叉积来判断<b>凸多边形</b>了，是同一个原理。具体实现凸包计算，还有<b>好几个细节</b>，代码也不短。搜两个关键词<b>“convex hull”和“Graham scan”</b>。凸包还有很多种算法，当然每个的<b>核心思想</b>都差不多。

<hr>

588 Design In-Memory File System

题意：设计一个<b>简单的文件系统</b>，能查看、创建目录，能读写文件。

难度：hard

解法：付费题。做的事情很具体，算是一个<b>系统设计题</b>了。既然有目录，有文件，你会如何组织？最直接的方式，是直接<b>一层哈希表映射</b>。稍微好点的方式，是建立目录树，并提供目录、文件两种类型。对文件，则提供读写API。这样的话，起码从功能上，它有<b>文件系统</b>最基本的样子了。看了下我的代码，写了两百多行，也算是<b>没偷懒</b>了。除了对基本功能的实现，<b>OOP</b>的一些知识也是应该体现的。

<hr>

589 N-ary Tree Preorder Traversal

题意：N叉树前序遍历。

难度：easy

解法：和二叉树没有什么不同。

<hr>

590 N-ary Tree Postorder Traversal

题意：N叉树后序遍历。

难度：easy

解法：同589。

<hr>

591 Tag Validator

题意：给定一段HTML代码，请检查其中的所有`<xxx></xxx>`<b>标签开闭是否匹配</b>。另有`<![CDATA[xxx]]>`作为特殊标签，其中的内容即使包含了标签，也要<b>解释为普通字符</b>。

难度：hard

解法：这题作为这么早的题，<b>点赞数低得出奇</b>，显然是<b>恶评如潮</b>。原因无非是<b>过多的边界case</b>，冗长而无聊的解法，基本不用动脑，只需要<b>无限的耐心</b>。因此，作者出这个题就是用来<b>折磨人</b>的。

<hr>

592 Fraction Addition and Subtraction

题意：给定一个字符串表示的<b>分数加减法算式</b>，请求出结果。用<b>最简分数</b>形式返回。

难度：medium

解法：分数本身的运算就不说了，<b>通分</b>之后加减即可，结果要<b>约分</b>。除此之外，要做的就是<b>字符串解析</b>了，这个小心处理即可。

<hr>

593 Valid Square

题意：给定二维平面4个点，判断能否构成一个正方形。

难度：medium

解法：正方形的条件很严格，计算<b>6对距离的平方</b>。如果满足`1:1:1:1:2:2`，就是正方形。对这个判定，我想不出反例。

<hr>

594 Longest Harmonious Subsequence

题意：定义<b>最大值最小值相差1</b>的数组为<b>和谐数组</b>。给定一个数组nums，请求出<b>最长和谐子序列</b>的长度。

难度：easy

解法：毕竟元素时整数，两个不同值最小差也是1。因此要满足<b>和谐子序列</b>的话，你<b>必须选</b>两个相邻的不同值。对数组的元素<b>计数</b>，并对key排序。找<b>key相邻且值相差为1</b>的情况，答案就在这里面。

<hr>

598 Range Addition II

题意：370的变体。给定m x n矩阵，初始全为0。每次执行一个操作(x,y)，表示把<b>[0,x)行、[0,y)列</b>所有元素都+1。执行完所有操作后，返回矩阵中<b>值为最大值的个数</b>。

难度：easy

解法：矩阵前缀和，这种都有一个通用技巧。<b>用后缀方式，反着来。</b>比如在(x,y)执行操作，那就只给a[x][y]加1。等所有操作完了之后，<b>统一进行累加</b>。累加的时候，按后缀方式，<b>从下往上加，从右往左加</b>。不知道<b>这个技巧</b>的话，这题可就不easy了。

<hr>

599 Minimum Index Sum of Two Lists

题意：给定两个字符串数组l1和l2。找出所有<b>下标和最小的公共串</b>。如果存在多个，返回顺序任意。

难度：easy

解法：描述的挺复杂，不过，<b>一步步来就行了</b>。判断交集，检查下标位置，求和，判断和是否最小。<b>作为easy题，这题倒是挺麻烦的。</b>

## 0601 - 0700

600 Non-negative Integers without Consecutive Ones

题意：给定正整数n，请返回[0,n]中，二进制表示里<b>没有连续的1</b>的整数个数。

难度：hard

解法：<b>数位DP题</b>。比如我们考虑<b>可以有前置0的k位的二进制数</b>，如果最高位是1，则下一位必须是0，变成dp[k-2]；如果最高位是0，变成dp[k-1]，所以`dp[k]=dp[k-1]+dp[k-2]`，就是<b>斐波那契数</b>。<b>再往下就讲不清楚了</b>，主要是我当年写的代码，现在看不明白了。

<hr>

604 Design Compressed String Iterator

题意：请设计一个以<b>游程码</b>压缩的字符串<b>作为输入</b>的迭代器。访问时，逐个返回字符。比如`aaacbb`，压缩后的形式为`a3c1b2`。

难度：easy

解法：付费题。水题。

<hr>

605 Can Place Flowers

题意：给定一个长条形的花圃，用一个01数组表示。1表示有花，0表示空位。如果不允许<b>相邻两个位置</b>都种花，请判断能不能<b>再种n朵花</b>？

难度：easy

解法：从左往右扫。按<b>间隔位置</b>，直接种就行了，<b>贪心策略</b>。

<hr>

606 Construct String from Binary Tree

题意：用`root(left)(right)`的形式，<b>递归序列化</b>一棵二叉树，但是对于空的子树，则直接<b>略去空括号</b>。如果左子树空，但<b>右子树非空</b>，则需要保留<b>左边的空括号</b>。

难度：medium

解法：规则定义得很清楚了。<b>递归处理</b>，注意<b>左空右不空</b>的特殊情况即可。

<hr>

609 Find Duplicate File in System

题意：给定一些<b>目录</b>，以及目录中<b>所有文件和对应内容</b>。请输出所有<b>内容重复的文件</b>路径。按<b>重复内容进行分组</b>，相同内容的在一组。

难度：medium

解法：算法上没有难度，所有工作量都在<b>路径解析</b>上。解析好了，按文件内容<b>做一下哈希，归类即可</b>。当然，实际的文件系统，则是计算<b>内容签名</b>，然后<b>对签名做哈希</b>了。

<hr>

611 Valid Triangle Number

题意：给定一个数组nums，请返回其中三元组`(nums[i],nums[j],nums[k])`的个数，使得三个值可以<b>构成三角形的三边</b>。

难度：medium

解法：首先对nums<b>排序</b>，用三指针ijk，<b>ij二维枚举</b>。第三维k从j+1开始。不断往前移动，直到<b>出界或者不满足要求</b>为止。因为已经有序了，要求就是一条：`nums[i]+nums[j]>nums[k]`。前两维的复杂度是O(n^2)，<b>k指针的移动</b>则是<b>均摊O(1)，总代价O(n)</b>的。为什么？因为k虽然要持续进行判断，但它的移动是<b>从不回头</b>的，至多走到出界，就不再变了。解法的总代价来自<b>ij的枚举</b>，复杂度<b>O(n^2)</b>。

<hr>

616 Add Bold Tag in String

题意：给定一个字符串s和一个词表dict。请将s中所有出现在dict里的子串，用`<b></b>`<b>加粗标签</b>括起来。如果多个词表中的词存在<b>重叠情况</b>，则对<b>整个重叠部分</b>用一个`<b></b>`标签括起来。比如`dict={aab,bbc}，s=xyaabbczz`，则加粗结果为`s'=xy<b>aabbc</b>zz`。

难度：medium

解法：付费题。按照单词长度1000，长串s长度1000的范围，似乎暴力匹配也可接受。但这样效率还是太低了。既然是带重叠的多模式匹配，用<b>类似KMP思路</b>，在一个有向图上建立fail指针跳转的的<b>AC自动机</b>最合适。但这个<b>太高端了</b>，我还是怂了吧。最后选择了折中办法，<b>建个字典树，方便匹配</b>就行了。

<hr>

617 Merge Two Binary Trees

题意：给定两个二叉树t1和t2，请按对应位置进行合并。如果该位置两节点都存在，则值进行相加；如果只存在一点，则取值以该节点为准。

难度：easy

解法：<b>递归解决</b>，注意递归写法。

<hr>

621 Task Scheduler

题意：有一个字符数组，每个字符A-Z，表示<b>一种任务</b>。给定这些任务，要求同一类任务两次执行必须间隔n个CPU时间段（叫时钟周期好像不合适）。如果允许你<b>重排任务顺序</b>，请问完成这所有任务，至少需要多少个时间段？

难度：medium

解法：乍一看有点难，仔细想想和之前<b>358题</b>很像。也是同字符必须<b>间隔多少位</b>。这样的话，用<b>队列</b>来处理比较好，并加上一个<b>cd冷却机制</b>。没有<b>冷却足够</b>的，就不能入队。还有一种思路，就是借鉴<b>575题</b>的贪心思路，将数组重排一下，<b>让相邻元素尽可能不相同</b>。具体做法就不说了。还是要检查cd，如果cd不够，就要加上<b>等待时间</b>。

<hr>

622 Design Circular Queue

题意：设计一个<b>循环单向队列</b>，首尾相连的那种。

难度：medium

解法：现在大家都<b>用惯了双向队列deque</b>，所以都不太考虑这些问题了。这题算是复习一下<b>基础数据结构</b>。普通的<b>单向队列</b>，最基本的设计方式是<b>单链表</b>，头尾移动的那种。如果要循环队列，那<b>肯定是个圈圈</b>。这个圈圈还是有头尾，只不过头向前了，尾也向前，中间的部分是数据。都在一个圈圈里绕，但<b>整个环的容量是不能扩大</b>的，不论头尾目前在哪个位置。对于头尾边界，你可以<b>单独留出一个空位</b>，避免<b>头尾碰到一起</b>。也可以用一些下标处理来做到这点，方法不止一种。（其实你要扩容也行，用<b>环形链表，插入节点</b>就可以了。）

<hr>

623 Add One Row to Tree

题意：给定二叉树，请在第n行所有<b>合适位置</b>，插入值为val的节点。对于下移的节点，按照<b>左子树向左，右子树向右</b>的原则进行移动。

难度：medium

解法：这个题主要是得把题目读懂。对于第n-1层，在它下面所有对应位置，也就是<b>每个n-1层节点的左右位置</b>插入。对于之前的第n层已有节点，则按照<b>左的往左，右的往右，下降一层</b>。按这个原则递归往下找就行了。

<hr>

624 Maximum Distance in Arrays

题意：给定m个有序数组，你可以从<b>2个数组</b>各选<b>1一个元素</b>。请找出能得到的<b>差值的最大值</b>。

难度：medium

解法：既然要差值最大，肯定是<b>一个尽量大，一个尽量小</b>。那就首先找出每个数组的最大最小值。然后求出每个数组<b>除自己之外</b>，<b>其他数组</b>的最大最小值。对每个数组，用`自身最大-其他最小`、`其他最大-自身最小`两种情况，对m个数组都判断一遍，可以得到最终结果。总代是`O(sum(len(arrays[i])))`，也就是<b>遍历所有数组所有元素一次</b>。

<hr>

625 Minimum Factorization

题意：给定一个正整数a，请找出最小的正整数b，使得b的<b>各位数相乘</b>恰好等于a。如果不存在答案或者答案超出了int32范围，则返回0。

难度：medium

解法：付费题。标题叫最小因数分解，其实是暗示你，肯定要做一下<b>因数分解</b>。如果一个数的<b>质因数都超过了10</b>，比如13，那你不可能用数位相乘得到了。如果分解得到的，只有<b>2、3、5、7</b>，那就<b>进行组合</b>。33得9、222得8、23得6，这样能拼出尽可能小的数位。再把这些数位按升序排列，就是最小的b了。检查b是否在<b>int32范围内</b>。每一步都不难，不过加起来还是挺麻烦的。

<hr>

628 Maximum Product of Three Numbers

题意：给定一个数组，元素可以是<b>任意整数</b>。请找出三个元素，使得<b>乘积最大</b>。返回最大乘积。

难度：easy

解法：先排个序。如果存在<b>3个最大的正数</b>，则取<b>后3个</b>。如果存在1个最大正数和两个最小负数，则取<b>后1和前2</b>。如此继续写几个<b>if else elif</b>。方法比较笨，所幸情况也没有那么多种。对于easy难度，这个题算比较麻烦了。

<hr>

629 K Inverse Pairs Array

题意：对于数组nums，如果`i<j,nums[i]>nums[j]`，则称为一个<b>逆序对</b>。给定整数n，请返回1~n的排列中，逆序数总和为k的排列的个数。结果可能非常大，模1e9+7返回。

难度：hard

解法：之前有个经典题目，是用O(nlogn)时间，求一个数组的<b>逆序数总和</b>。做法是在<b>归并排序</b>的同时进行统计。这个，则是要算1~n的排列里，逆序为k的有多少个。想了10分钟毫无思路，<b>g了</b>。写了600多题的题解，这是第一道<b>完全没思路</b>的题。看了下当年的代码，用dp[i][j]表示<b>前i个元素，逆序数为j</b>的个数，<b>DP解法</b>。奇怪...怎么如今就一点想不起来了？

<hr>

630 Course Schedule III

题意：207的变体。有标号1-n的课程，每门课有一个<b>时长duration</b>、一个<b>最晚完成时间lastDay</b>。你从<b>第1天</b>开始，不能同时学两门课，请问最多能完成多少门课？

难度：hard

解法：首先，注意理解题目的边界。比如<b>lastDay=10</b>，表示要在第10天结束前，也就是<b>第11天开始前</b>，把课学完。这个题目处理的是区间，有一些区间，你不能让区间重叠。给定一个总区间[0,max(lastDays)]，请问这个区间里<b>最多包含</b>多少个<b>互不重叠的区间</b>？注意，如果你<b>第x天</b>完成了课，必须<b>第x+1天</b>才能学新课。有一种直白的解法，就是O(n^2)的DP，针对每个区间，往前比较是否存在重叠。具体不多讲了，因为<b>数据规模</b>不接受这种效率。用一种更<b>有序</b>的办法。首先对所有区间排序，按照lastDay升序排列，然后用一个<b>最大堆</b>。从<b>now=0开始计时</b>，只要上课时间来得及，就<b>不断往堆里加课</b>，同时更新now。关键在于，如果时间<b>来不及了</b>，就从堆里取出duration最长的课，给它<b>替换掉</b>。因此，才用<b>最大堆</b>。<b>替换完成后</b>，剩下的就是可以上完的课。想不到这个“替换”思路的话，这题就很难搞定了。我当年想出来了，这次没想出。

<hr>

632 Smallest Range Covering Elements from K Lists

题意：你有k个有序数组。请求出最小的区间[a,b]，使得区间包括了至少每个数组的一个元素。

难度：hard

解法：怎么连续几题都是hard...这题乍一看没什么思路，仔细想想，有点像之前<b>k个有序数组做归并</b>的思路。之前是<b>用一个堆</b>，把k个表头放进去，不断拿到最小元素。这次你还是需要把k个表头放进去，并不断前进。但这次你需要找的，是任一时刻，这个结构里的<b>最大值和最小值</b>。因为这个结构总是包含了<b>k个数组的各1个元素</b>。让这个<b>max和min之差尽可能小</b>就是最终目的。所以可以用map来代替heap做同样的事情，因为<b>map</b>可以随时找到<b>最大最小key</b>。让k个指针往前移动，直到某个指针走到头了，就停止。因为这时你<b>凑不够k个元素了</b>。在这个过程中，不断更新结果，最后返回。看了下当年的代码，我没有用map，而是直接每次以<b>O(k)代价</b>找出最大最小值了。看来这种<b>暴力解法</b>，也过了。如果现在重做一次，我肯定用<b>OrderedDict</b>了。

<hr>

633 Sum of Square Numbers

题意：给定整数c，判断是否存在整数a、b，使得`a^2+b^2=c`。

难度：medium

解法：平方嘛，int32范围内的<b>完全平方数</b>，个数自然就是int16这个量级，大概几万个。可以预先计算好，然后<b>a进行遍历，b用O(1)代价查找</b>。总代价是O(sqrt(c))。

<hr>

634 Find the Derangement of An Array

题意：给定1-n的排列，如果每个i位置的元素都不是i，称为一个<b>“错排”</b>。请返回n位错排的个数，结果模1e9+7返回。

难度：medium

解法：付费题。看到这种题就觉得有点难，总是容易晕。比如我们考虑第1位，不能是1，那么可以是2-n。那么2-n的情况是<b>对称</b>的吗？比如我第一位取k，则后面要由`{1,2,3,...,k-1,k+1,...,n}`组成。把所有所有元素都-1，变成了`{0,1,2,...,k-2,k,...,n-1}`。<b>推了十分钟，没推清楚。</b>查了资料，发现竟然有专门的<b>错排公式</b>，`!n=(n-1)(!(n-1)+!(n-2))`。注意这个感叹号在左边，<b>不是阶乘</b>。不知道这个，怎么做得出来？又查了下，这个公式的<b>证明也不简单</b>，有点循环论证的味道。可以用<b>归纳法</b>，对公式进行展开来证明。但显然，我不认为一个普通水平的<b>软件工程师</b>，可以凭一些推导来<b>发现这个公式</b>。网上的推导过程我也看了，没有讲解的话，实在想不出来。有这个公式的话，直接<b>O(n)代价</b>递推就行了。这明显是<b>不讲道理</b>。

<hr>

635 Design Log Storage System

题意：设计一个<b>日志存储和检索</b>系统。日志时间戳格式为`YYYY:MM:DD:hh:mm:ss`，存储的每条日志<b>有一个id、一个时间戳</b>。对于检索，给出一个起始start、终止end时间戳，和一个检索粒度。<b>粒度</b>可以是任意一层。请根据<b>粒度要求</b>，返回`[start,end]`之内的结果，返回结果没有顺序要求。

难度：medium

解法：付费题。不用想得太复杂，首先，做好字符串解析，一律把结果按<b>长整数</b>的<b>时间戳</b>保存，而且插入时始终<b>保持升序</b>。关于粒度，其实可以这么想。与其处理`[start,end]`，不如变为<b>`[start,end+1)`</b>。这样，对于不同的granularity，这个<b>+1操作</b>就加的不同值。比如<b>小时</b>，那我就<b>+3600</b>；比如<b>天</b>，我就<b>+86400</b>。然后，进行<b>二分搜索</b>，确定上下界就行了。

<hr>

636 Exclusive Time of Functions

题意：在一个<b>单线程CPU</b>上执行程序。给定<b>函数调用</b>的时间日志，格式为`函数id:起始或终止:时间戳`，比如`2:start:3`表示<b>函数2在时刻3启动</b>。定义<b>独占时间</b>为一个函数在CPU上执行，且<b>没有递归调用其他函数时</b>的时间。请统计所有函数的独占时间，返回统计结果。

难度：medium

解法：题目讲的很复杂，<b>科普和教育意义</b>为主。函数调用栈，<b>确实是个栈</b>。所以，对logs中的记录先做好解析，按<b>(时间戳,起始终止)</b>优先级进行<b>排序</b>，然后逐条<b>处理日志</b>。函数开始了，就<b>入栈</b>；函数结束了，就<b>出栈</b>。每次出入的时候，记录一下<b>对应函数的独占时间</b>。函数调用，出入平安。

<hr>

637 Average of Levels in Binary Tree

题意：给定一个二叉树，请按行统计<b>每行节点值</b>的<b>平均数</b>。

难度：easy

解法：随便怎么遍历，按行<b>求和+统计个数</b>，然后除一下。

<hr>

638 Shopping Offers

题意：店里有n件商品，各自价格为price[i]。你需要买的各种商品个数为needs[i]。<b>特价组合</b>可以提供打包特价，比如一个n+1元素的数组special，前n个表示商品个数，第n+1个为总价格。给定一些不同的特价组合，请求出你买到所需商品，花的<b>最少价格</b>。要求不能为了凑满减而<b>多买东西</b>。

难度：medium

解法：看着很复杂，但难度不是hard。是在暗示你，<b>别想太多</b>。n很小，special稍大一点。那么，就用<b>比较暴力的DP</b>？或者<b>直接暴力搜索</b>？DP想了下，没想出很好的思路。还是暴力搜吧。看了下之前的代码，用了个稍微取巧的小优化。因为各个值都不超过10，直接当做数位处理，叠成一个十进制数了。这也算是<b>“位压缩”</b>吧，十进制位。然后用背包问题的思路解决。那么这题就是个<b>多维背包</b>问题了。对于<b>单买一件商品</b>，则相当于一个`[0,...,0,1,0,...,price[i]]`的<b>“特价组合”</b>。这么一看，这题确实很复杂，<b>还得想很多</b>。

<hr>

639 Decode Ways II

题意：91的变体。按照`A->1,B->2,...,Z->26`的一一对应，对一个字符序列编码，得到一个数字串。现在给定一个<b>数字串</b>，但其中可能包含<b>代表任何数字的“*”</b>，请问有多少种<b>解码方式</b>？

难度：hard

解法：O(n)代价，<b>DP思路</b>解决。对于当前第i位，我总是考虑<b>当前1位</b>或者<b>当前2位</b>。比如当前位是7，那就只能考虑1位；比如当前位是1，就可以考虑<b>1或2位</b>；比如当前是0，<b>那就不可能</b>。因为在上一位时，就应该把这个0考虑进去了，<b>开头是不可能是0的</b>。把这些情况考虑清楚后，写出<b>线性的递推关系</b>。对于“*”，则枚举0-9的各种可能性，都处理一下。看了下当年的代码，居然这么长...我以为没那么复杂呢。

<hr>

640 Solve the Equation

题意：给定一个包含<b>未知数x、整数、加减法</b>的<b>一元一次方程</b>。请解出x。

难度：medium

解法：有意思。主要工作是<b>字符串解析</b>，把加减法都归拢一下，x也归拢。最后要处理三种情况：<b>唯一解、无解、无数解</b>。这些规则在初中数学课都讲了，就不细说了。

<hr>

641 Design Circular Deque

题意：设计一个循环双向队列。各种功能就不细说了，有<b>容量上限</b>。

难度：medium

解法：622题是循环队列，这题是循环双向队列了。其实双向队列，用双向链表是最直观的（如果你不用下标访问的话）。如果要支持下标访问，那还是用一个<b>循环数组</b>，<b>头尾位置</b>都可以<b>向前向后</b>。这个算法本身不难，但都是<b>下标挪来挪去</b>，很容易出错。因此，这题<b>极其考验耐心和仔细</b>。看了下我之前的代码，用python都写了很长，<b>果然很麻烦</b>，是道难题。

<hr>

642 Design Search Autocomplete System

题意：用过搜索引擎吧？设计一个类似的<b>搜索补全系统</b>。给定用户输入的搜索内容，以“#”结尾。对于每个前缀串，都输出<b>前缀匹配</b>的<b>热度前3</b>的词条。每次用户<b>输入一个字符</b>，执行一次匹配。当用户输入“#”时，搜索完成，<b>输入的词条也加入词条库</b>。

难度：hard

解法：付费题。这题目太长了，描述得超级具体。算是个费劲的<b>系统设计题</b>吧。从算法角度，对已有词条的记录，肯定是用<b>字典树</b>最好，因为做的都是<b>前缀匹配</b>。除此之外，要注意用户输入的新句子，<b>也要入库，参与统计</b>的。在字典树的基础上，对于<b>热度排序</b>，用了一个SortedSet作为优化。因为题目要求是按照`(热度,字典序)`排序，插入set的元素自然也是一个元组。整个实现还是很麻烦的，包括字典树的查找、插入、更新操作。<b>确实是难题。</b>

<hr>

643 Maximum Average Subarray I

题意：给定一个数组nums和整数k，请求出长度为k且平均值最大的子数组。返回平均值。

难度：easy

解法：因为窗口大小是固定的，直接滑动，判断每个k长度子数组的平均值就行了。总代价是<b>O(n)</b>。

<hr>

644 Maximum Average Subarray II

题意：643的变体。给定数组nums和整数k，请求出长度不小于k，且平均值最大的子数组。返回平均值。

难度：hard

解法：付费题。这次难度是hard了，说明不一定用简单的<b>滑动窗口思维</b>能搞定。数据范围也暗示你，不能用O(n^2)暴力解法。用<b>滑动窗口</b>想了10分钟，毫无思路，放弃。碰到这种找最大、最小，但又让你束手无策的题目，就想想，能直接对这个值<b>二分搜索</b>吗？想了下，<b>好像可以</b>。为什么可以？因为这个<b>单调性</b>是存在的。比如min(nums)和max(nums)作为边界，取一个值x在这中间，看能不能使某个<b>长度不小于k</b>的子数组，其<b>平均值大于等于x</b>。能想到这儿，就快做出来了。虽然能想出这个，就挺费劲了。比如每次检查的平均值是x，那就把所有nums[i]-x，然后<b>以0作为判断位置</b>，这样就不用操心<b>平均数、除法</b>之类的问题了。具体做法还是看代码吧。<b>有点难写，且很难想</b>的一题。

<hr>

645 Set Mismatch

题意：给定1-n共n个数，其中某个数x被替换成了y，且x、y都在1-n范围内。请找出<b>缺失的x和重复的y</b>。

难度：easy

解法：既然是easy，用最朴素的<b>哈希表计数</b>就可以了。如果要玩一些杂技的话，就用那个<b>在原数组上叠罗汉</b>做计数的办法。

<hr>

646 Maximum Length of Pair Chain

题意：给定一些区间`[x,y]`，如果`p1=[x1,y1],p2=[x2,y2]`，且`y1<x2`，则两区间可以连起来。请找出能连起来的区间的<b>最大个数</b>。

难度：medium

解法：这个问题，如果视为(x,y)的二维<b>最长递增子序列</b>，也可以。这样你可以很轻易想出<b>O(n^2)的DP解法</b>。但是<b>O(nlogn)的LIS解法</b>，就很难想了。实际上这题和LIS<b>不完全一样</b>，就因为它是<b>(x,y)区间</b>，而不是一个值。这题的聪明之处在于<b>贪心策略</b>，贪心就可以搞定。首先，<b>区间排序</b>是必做的。排序之后，每次你其实只关心当前的<b>最右端</b>在哪儿，也就是max_y。对于下一个区间(x,y)，如果`x>max_y`，则可以<b>扩一个区间</b>，且更新max_y为y。想想为什么我们<b>不关心之前的x</b>？因为那已经过去了，<b>和扩区间没有关系了</b>。还有一点补充，关于排序的方式。你用`(x,y)、(y)`这两种排序方式，其实都可以做。最终关心的，还是y维度。x维就算是<b>乱序也不影响结果</b>。

<hr>

647 Palindromic Substrings

题意：给定字符串s，返回s的回文子串的个数。

难度：medium

解法：这题容易。以<b>每个位置为中心</b>，往两边检查<b>对称性</b>即可。对<b>奇偶情况</b>，要分开处理。总代价O(n^2)。

<hr>

648 Replace Words

题意：英语里有<b>词根</b>，词根加上一些<b>词缀</b>，可以变成<b>派生词</b>。给定一个<b>词根表dictionary</b>，请将一个句子sentence中的单词替换成<b>词表中存在的词根</b>。如果多个词根符合，使用<b>最短</b>的一个。

难度：medium

解法：这个例子倒不是真正的<b>英语语法、词根</b>之类的，而是<b>前缀匹配</b>。句子长度、词表长度都还有点大，因此<b>不能暴力</b>解决。建立<b>字典树</b>比较合理。对sentence进行分词，查找<b>字典树</b>，如果有词根匹配，按<b>最短匹配</b>的原则，找到要替换的词根。最后用空格拼装成句子。看了下我当年的代码，没用字典树，而是搞了个<b>字符串滚动哈希</b>（其实就是BM匹配算法），用于做<b>前缀匹配</b>。思路差不多，方法不同而已。

<hr>

649 Dota2 Senate

题意：给定两个阵营<b>R和D</b>。一个长度为n的RD字符串，表示两个阵营<b>攻击的顺序</b>。从左往右，每个玩家攻击时，可以<b>选一位</b>场上剩余的<b>对方阵营玩家</b>，并将其<b>ban掉</b>。被ban的玩家在自己的轮次无法再攻击。如果一方玩家全被ban，则输掉比赛。如果两方都使用最佳策略，请问R和D谁获胜？

难度：medium

解法：就不说什么<b>近卫天灾</b>之类的话了。考虑这个题，贪心策略可行吗？比如RRDDR。我作为R方，肯定优先ban<b>排在前面的D玩家</b>。因为他攻击时间更早，威胁就更大。那比如<b>有连续x个R，y个D</b>，如果x>=y，那么这y个D都被ban了，没得玩了。照这个思路，<b>双方都应该贪心</b>。就按这个逻辑，看看最后谁赢。我当年代码写得太长了，这题用python的话，应该在10-20行内解决战斗。

<hr>

650 2 Keys Keyboard

题意：给定一个特殊键盘，只有三个键：<b>“A”键、全选复制、粘贴</b>。如果你要打出n个“A”，请问至少要按几次键？<b>开始时</b>，屏幕已有一个字母“A”。

难度：medium

解法：<b>搜索还是DP</b>？还是用搜索吧，<b>定义状态</b>为`(当前字符数,剪贴板字符数,步数)`。“打A”的转移为`(+1,+0,+1)`；“全选复制”的转移为`(+0,=当前字符数,+1)`；“粘贴”的转移为`(+剪贴板字符数,+0,+1)`。执行BFS，直到<b>搜出目标值n</b>为止。看了下当年代码，是用<b>O(n^2)的DP解法</b>。

<hr>

651 4 Keys Keyboard

题意：650的变体。和刚才的2键键盘类似，这次是4个键：<b>按“A”、全选、复制、粘贴</b>。这次你至多可以按键N次，请问最多能输出多少字符“A”？

难度：medium

解法：付费题。和刚才的思路完全一样，只不过按键稍有变化，把<b>全选和复制</b>分开了。依然<b>用BFS</b>，按照每个按键的<b>状态转移</b>做搜索。搜到N步为止。

<hr>

652 Find Duplicate Subtrees

题意：给定一个二叉树，请找出其中所有<b>重复的子树</b>。两个子树如果从根节点开始，所有位置完全相同，则视为重复。

难度：medium

解法：首先，对于n节点二叉树，如果递归进行暴力匹配，时间是O(n^2)。太慢了，得优化。就用`节点->子树序列化`的方式做一下映射。因为一棵树的<b>序列化</b>，和自身肯定是<b>一一对应</b>的。判断字符串重复，就很容易了，用<b>哈希表记录</b>即可。

<hr>

653 Two Sum IV - Input is a BST

题意：1的变体。给定一个二叉搜索树，请判断是否存在两个元素，相加为k。

难度：easy

解法：我没想出什么巧办法，就是用一个<b>哈希表</b>。在<b>中序遍历</b>时，不断添加<b>已访问元素</b>到表中。对于当前元素x，如果<b>k-x在哈希表</b>中，就算找到了。

<hr>

654 Maximum Binary Tree

题意：给定一个<b>无重复值</b>的数组nums。以一种递归方式构建一棵<b>最大二叉树</b>。每次取<b>最大值</b>为根节点。其左侧子数组，为<b>左子树</b>；右侧子数组，为<b>右子树</b>。<b>递归构建</b>整个二叉树，

难度：medium

解法：在每一步，都需要找出当前范围内的<b>最大值</b>，然后分出<b>左右段</b>。第一种思路，<b>比较朴素</b>，就是每次用<b>O(n)代价遍历</b>找出最大值，然后<b>左右分别递归</b>。这样的<b>分治策略</b>，总代价是O(nlogn)，可以接受。第二种思路，是先按`(值,下标)`的方式，降序排列。第一个就是根节点，随后的节点，依次按值的范围进行插入。比如数组`[1,5,7,3]`，排序后是`[(7,2),(5,1),(4,3),(1,0)]`，那么7是根节点，5在7左，4在7右，1在5左。每插入一个节点，平均代价是O(h)，也就是树的高度。这样，其实总代价也是O(nlogn)。第二种思路麻烦一点，因此还是倾向<b>第一种解法</b>。

<hr>

655 Print Binary Tree

题意：给定一棵二叉树，用一种<b>特殊的排版</b>将其打印出来。

难度：medium

解法：不细说了，比较<b>繁琐枯燥</b>的一道模拟题。

<hr>

657 Robot Return to Origin

题意：给定一个机器人，从(0,0)出发。按照一个<b>上下左右</b>的序列移动，请判断最终是否<b>回到了原点</b>。

难度：easy

解法：按序列移动即可，检查终点。

<hr>

658 Find K Closest Elements

题意：给定有序数组arr，整数k和x。请找出arr中，和x最接近的k个数。

难度：medium

解法：因为是有序数组，那么定位<b>最接近位置</b>，可以直接<b>二分搜索</b>。从这个位置为起点，<b>双指针往两边延伸</b>。每次都选较为接近的点，延伸一步。这样，总代价是O(logn+k)，就是<b>O(k)</b>。我当年估计没注意到，<b>数组是有序的</b>，因此用了<b>两个堆</b>的解法。

<hr>

659 Split Array into Consecutive Subsequences

题意：给定一个升序数组，请问能否将其<b>划分</b>为几个<b>子序列</b>，使得每个长度至少为3，且都是<b>公差为1的等差数列</b>。

难度：medium

解法：其实这个题目只有一种情况难想，就是类似<b>`[1,2,3,3,4,4,5]`</b>，你知道<b>应该取1234和345，而不能取12345</b>。怎么用代码表达呢？我想了十分钟，总算想出来了。注意看4的位置，<b>两个4，一个5</b>。这代表什么，<b>在边界处，个数是一定会减少的</b>。判断边界，就用这个办法。除此之外，没有难点了。

<hr>

661 Image Smoother

题意：给定一个m x n矩阵表示的<b>灰度图</b>。对每个像素，求<b>3 x 3的均值</b>。如果在边界，则只考虑3 x 3<b>界内部分</b>的均值。结果按<b>整除</b>计算。

难度：easy

解法：按要求计算即可。

<hr>

662 Maximum Width of Binary Tree

题意：给定二叉树，求<b>最大宽度</b>。最大宽度是<b>一层节点数</b>的最大值。

难度：medium

解法：用任意方式遍历，<b>记录深度</b>并按深度<b>统计个数</b>即可。

<hr>

663 Equal Tree Partition

题意：给定一个二叉树，请问是否能<b>去掉其中一条边</b>，将二叉树分为两个，且<b>两棵树的节点和</b>相等。

难度：medium

解法：付费题。其实等效于<b>找一个子树</b>，使得子树和是<b>总和的一半</b>。递归遍历，<b>记录所有子树和</b>，看是否存在等于总和一半的即可。

<hr>

665 Non-decreasing Array

题意：给定数组nums，请判断是否可以通过</b>至多修改一个元素</b>，使得数组变为<b>升序</b>。

难度：medium

解法：仔细想一下，其实非常简单。升序数组，<b>相邻元素都是<=关系</b>。那么如果都满足，或者<b>仅有一个不满足</b>，就符合题意。否则，就不符合。只检查相邻元素，因此代价是<b>O(n)</b>。

<hr>

666 Path Sum IV

题意：112的变体。给定一种<b>奇怪的编码方式</b>，表示一棵<b>二叉树</b>，请求出这棵二叉树的所有<b>根到叶的路径和</b>。

难度：medium

解法：付费题。比较<b>无聊且怪异</b>的一题。两件<b>完全独立</b>的事。第一件是按照题意<b>建立这个二叉树</b>；第二件是<b>求路径和</b>。如果你不建二叉树，直接求和，其实也行。

<hr>

667 Beautiful Arrangement II

题意：526的变体。给定n，请构造一个1-n的<b>排列</b>，使得相邻元素之差`d_i=|a_i-a_{i+1}|`的序列`[d_1,d_2,...,d_{n-1}]`恰好包含k个不同值。返回<b>任意一种</b>有效排列即可。

难度：medium

解法：这和526的条件好像完全不相干。感觉有点难，<b>没什么想法</b>。k和n都比较大，不可能<b>直接搜</b>。比如我希望d_i的取值，恰好就是`{1,2,...,k}`，应该怎么做？考虑这样的排列`[1,k+1,2,k,3,k-1,...]`，前面会消耗掉1~k+1，用掉的差值则是1~k。那么如果我<b>消耗完剩余的数</b>，但<b>不增加新的差值</b>，就完成目标了。<b>能做到吗</b>？可以，而且很容易，后面直接跟上`[k+2,k+3,...,n]`就行了。这题有点小聪明，<b>考的是灵感</b>，而不是技术。

<hr>

669 Trim a Binary Search Tree

题意：给定一个二叉搜索树。请按照<b>[low,high]</b>的范围，修剪这棵树。请返回得到的新BST的根节点。

难度：medium

解法：递归处理，但要<b>注意递归的写法</b>。因为任何节点都可能被删，包括<b>根节点</b>，所以<b>返回新的根节点</b>是比较灵活的做法。这样就不用担心这棵树会变成什么样了，因为不论怎么变，你都会<b>一层层往上返回</b>。根据[low,high]<b>控制递归的走向</b>。

<hr>

670 Maximum Swap

题意：给定一个非负数num，你至多可以交换两个数位<b>一次</b>。请返回能得到的最大数。

难度：medium

解法：思路非常简单，不过<b>各种边界case</b>要考虑到位。把<b>第一个非最大位</b>，和<b>在它右边的</b>，<b>最后一个最大位</b>交换。如果找不到这两者，就不用换了。

<hr>

671 Second Minimum Node In a Binary Tree

题意：给定一个二叉树，求其中的<b>第二小值</b>。

难度：easy

解法：没什么技巧，<b>统计值</b>然后找第二小就行了。当然，你用一个最大堆处理，也可以。用min、second_min两个变量，也可以。

<hr>

672 Bulb Switcher II

题意：319的变体。有n栈灯，编号1-n，开始都是<b>亮的</b>。有四种按钮：按钮1，全flip；按钮2，偶数flip；按钮3，奇数flip；3k+1的flip。如果<b>总共按k次</b>按钮，但<b>种类和顺序</b>你可以选择。请问最终可能有<b>多少种不同结果</b>？

难度：medium

解法：乍一看很复杂，2^1000这么多。实际上，从这四个按钮去考虑。因为按钮只有开和关，那么其实总共2^4=16种按钮状态，每个按钮两次就还原了。还有一个技巧，因为<b>2和3的公倍数是6</b>，因此<b>用6个就足够观察了</b>。6的倍数，情况都是一样，没区别。那你可以用6位二进制111111，去编码状态。然后看看这16种按钮方式，能得到几个结果。讨论区里还有更简洁的做法，直接O(1)分情况讨论。所以，这题其实是<b>智力题</b>。一星差评。

<hr>

673 Number of Longest Increasing Subsequence

题意：给定数组nums，求出不同的<b>最长递增子序列</b>的个数。要求严格递增。

难度：medium

解法：LIS问题，标准形式是<b>求长度</b>。现在要求统计个数，那还是先求这个长度。然后要考虑一个问题，一个具体的最长递增子序列，怎么求？答案是<b>回溯</b>。在每个位置，找出上一个位置，一步步<b>往回跳</b>。比如`[2,4,1,3,6]`，可以是`[2,4,6]`或者`[1,3,6]`。那么我们考虑6的前一个元素，可以是4或3；4的前一个只有2；3的前一个只有1。按这种<b>回溯关系</b>，进行<b>DP</b>。用dp[i]表示<b>i位置结尾</b>的<b>递增子序列</b>，<b>有多少种</b>组成方式。如果i的前驱是`[j_1,j_2,...]`，则dp[i]=sum(dp[j])。最后，只考虑递增子序列长度为<b>LIS值</b>的那些位置。看了下我以前的代码，确实是这么做的，思路完全一样。总代价为O(n^2)，不过<b>实际的平均复杂度会远好于n^2</b>，这个就不细说了。

<hr>

674 Longest Continuous Increasing Subsequence

题意：给定数组nums，求出其中的<b>最长递增等差子数组</b>的长度。

难度：easy

解法：这题的标题<b>实在不恰当</b>。这叫<b>“subarray”</b>，不叫“subsequence”。问题本身很简单，如果发生<b>错配</b>，就从倒数两个元素重新开始匹配。检查是否<b>等差数列</b>，且<b>公差是否为正</b>。

<hr>

675 Cut Off Trees for Golf Event

题意：给定一个m x n地图，0是墙、1是空地、<b>h>1是高度为h的树</b>。你需要从(0,0)出发，上下左右移动，砍倒所有的树。已知所有树的<b>高度都不同</b>，且你必须按<b>从低到高</b>的顺序砍树。请返回砍完所有树的<b>最小步数</b>，如无法完成则返回-1。

难度：hard

解法：mn的最大值都是50，因此<b>单轮的搜索代价</b>是很小的，这给<b>从头搜到尾</b>的方案提供了可能。既然规定了必须从低到高砍树，那你的<b>执行顺序是固定的</b>。因为<b>有墙</b>，你就<b>只能搜索</b>，而不能用两点的坐标直接得到路径。这么看来，好像你的<b>选择不多</b>，要做的事也<b>很明确</b>。那就按要求，一个个地搜吧，每搜一棵，就砍一棵。中途如果路径<b>无法到达，就返回-1</b>。事实证明，<b>确实没什么技巧</b>，按要求实现就行了。

<hr>

676 Implement Magic Dictionary

题意：给定一个词表dictionary和一个词word。请判断能否改变word的一个字母，使结果匹配词表中的某个词。注意，<b>word本身匹配</b>dictionary是不算的。

难度：medium

解法：显然，要么<b>对word改</b>一个字符，要么<b>对dictionary的所有词</b>改一个字符。如果search函数调用非常多，且dictionary不算大，则改dictionary比较好。否则，改word比较好。我选择<b>改word</b>，逐个改字符，然后尝试匹配就行了。匹配就用一个<b>哈希表保存dictionary</b>即可。对这个题其实还有很多<b>可探讨的地方</b>，比如字符串哈希、位压缩、冷词热词之类的。总之，可以弄成一个<b>综合的讨论题</b>。不仅仅是个算法题。

<hr>

677 Map Sum Pairs

题意：设计一个map，key是字符串类型，value是整数。且支持给定一个<b>key前缀</b>，求匹配这个前缀的<b>value之和</b>。

难度：medium

解法：有两种解法，第一种是<b>构建字典树</b>，并在字典树上对值做好累加。这样当你查询时，就可以直接得到求和了。这种方式，<b>插入比较麻烦</b>，但求和方便。第二种是用OrderedDict，因为OrderedDict的key是有序的，对key用bisect_left，判断是否前缀匹配。从找到的位置，逐个进行累加。这种方式，插入方便，求和稍麻烦。总体上，<b>第二种方法更简单的多</b>。不过我当年选的是字典树，当年用C++写的。

<hr>

678 Valid Parenthesis String

题意：给定一个“(”、“)”组成的括号序列，其中也可能包含“\*”。<b>单个“\*”字符</b>可以表示“（”、“）”、“”中的一种。请判断给定括号序列能否完整匹配。

难度：medium

解法：<b>单纯的括号匹配</b>，用一个计数，模拟栈顶就行了。现在给了“\*”，比如我们用cc表示这个计数。如果到末尾时，cc>0，表示“(”多了；如果cc<0，表示“)”多了。你都可以通过星号来补全。是不是在<b>任何时候都可以</b>？不是。比如<b>cc=-3</b>，右括号多3个，但你<b>目前</b>只有2个星号，那就g了。因为你用完“((”，前面序列也没法匹配，即使后面匹配，前面已经错了。但如果是<b>cc=3，你有2个星号</b>，可以吗？这种可以。因为<b>左括号多余</b>，要到了<b>最后才检查</b>。按这个原则，进行<b>计数和检查</b>。看了下当年的代码，第一种O(n^3)暴力解法，第二种高效解法，就是我现在说的这个。看来<b>当年我没想出来，但这次想到了</b>。

<hr>

679 24 Game

题意：扑克牌，<b>算24点</b>。注意，除法不是整除，而是<b>实数除法</b>。

难度：hard

解法：就是标准的，算24点。规则不说了，<b>暴力搜索</b>就行。代码的写法，可以把<b>四则运算</b>用一个dict存起来。<b>函数也是变量，可以保存的</b>，这样代码写起来简洁点。固定4张牌，所以搜索空间很小，不存在效率问题。

<hr>

680 Valid Palindrome II

题意：125的变体。给定字符串，能否通过<b>删除至多一个字符</b>，得到<b>回文串</b>？

难度：easy

解法：<b>从两端往中间匹配</b>，如果错配只有一处，判断应该删哪个字符；如果没有错配，则本身就是回文串。

<hr>

681 Next Closest Time

题意：给定一个`HH:MM`格式的时间，请用时间里<b>出现的数字</b>，拼出下一个<b>最近的时间</b>。

难度：medium

解法：付费题。毕竟就这么几个数字，<b>暴力搜</b>，然后检查<b>下一个最近的值</b>也是可以的。注意23:59这种要<b>延到第二天</b>的情况。

<hr>

682 Baseball Game

题意：太繁琐，不写了。

难度：easy

解法：水题，但题目很繁琐。

<hr>

684 Redundant Connection

题意：给定一个<b>无向图</b>。已知这个无向图是在<b>树的基础上</b>，添加一条边形成的。请找出一条边，使得删去这条边能让这个图变成树。

难度：medium

解法：用<b>并查集</b>可以完美解决。针对每条边，做union操作。如果发现轮到某条边的时候，两点的<b>find结果相同</b>，则表示已经连通了。那么，这条边就是<b>多余的边</b>，可以删去。

<hr>

686 Repeated String Match

题意：给定字符串a和b。允许你重复字符串a任意次，请问至少重复多少次，才能让b称为这个`{aaa...aaa}`串的子串？如果不可能，则返回-1。

难度：medium

解法：这个问题不要想复杂了，其实就是<b>把a重复到恰好长于b</b>，记这个重复串为a1。如果b是a1子串，则返回个数；如果不是子串，则返回-1。就这么简单。想明白了，就会发现这是个<b>坑爹智力题</b>。总不能说让人<b>手写KMP算法</b>，是这题的考察点吧？我直接a1.find(b)，用库函数里的<b>Sunday算法</b>，效率就足够好了。看了下当年的代码，好像当年我没看出智力题，现在能一眼看出了。

<hr>

687 Longest Univalue Path

题意：给定二叉树，请找出以<b>任意两点</b>为端点的<b>单值路径</b>。单值路径是指整个路径上所有点的值相同。

难度：medium

解法：在二叉树上，凡是<b>不要求从根节点出发</b>的递归，都可以写成<b>双层递归函数</b>。fun1()递归调用自己，同时还调用fun2()；fun2()只递归调用自己。

<hr>

688 Knight Probability in Chessboard

题意：给定n x n国际象棋棋盘，如果一个马，从(r,c)位置出发，马走“日”。每次按照8个日的方向，等概率选一个，包括走出界。只要<b>马还没有出界</b>，就不断随机移动，<b>至多k步</b>。请问最终马落在棋盘内的的概率是多少？

难度：medium

解法：先不考虑浮点数的<b>精度问题</b>，想想这个概率该怎么算。其实很简单，连搜索都不需要。<b>直接/8</b>就行了。比如当前<b>在(i,j)位置的概率是p</b>，那么下一步，你只需要算出<b>马走日</b>得到的8个位置中，<b>界内的有哪些</b>。给这些界内的值，都<b>+p/8</b>就行了。界外的情况很复杂，所幸<b>你不需要管界外</b>。只把界内的值<b>累加出来</b>就行了。

<hr>

690 Employee Importance

题意：给定一个员工列表，每个员工有id、重要值、下属id列表。给定某个员工id，返回他和他所有的下属的重要值之和。

难度：medium

解法：<b>树形结构，递归求和</b>。奇怪的是，为什么我以前的代码用的是并查集？这不应该是<b>自顶向下</b>的递归吗？仔细看了下，<b>怀疑是不是题目改了</b>？老的代码并不完全符合这个题意。

<hr>

692 Top K Frequent Words

题意：给定一个字符串数组，求出出现频率前k大的值。如果频率相同，优先返回字典序小的。

难度：medium

解法：直白的方法就是统计、排序、取前k个。排序按`(-频率,+字典序)`即可，总代价是O(nlogn)。除此之外，没想出<b>更简便</b>且效率明显高的办法。如果要搞一些<b>复杂而奇奇怪怪的算法</b>来达到要求，那还是算了。

<hr>

693 Binary Number with Alternating Bits

题意：给定整数，判断它的所有<b>相邻二进制位</b>是否都不同。

难度：easy

解法：如果奇数，则`(x|(x<<1))+1`是2的幂；如果偶数，则`(x|(x>>1))+1`是2的幂。想想例子，比如101010，比如10101。

<hr>

694 Number of Distinct Islands

题意：给定m x n的矩阵表示一个地形。0是水，1是陆地。陆地可以按4方向连成小岛。如果两个小岛可以通过<b>平移</b>（但不能旋转、反转）达到重合，则算作<b>相同小岛</b>。请判断地形中有多少个不同小岛。

难度：medium

解法：付费题。首先，判断小岛个数，是很基础的搜索操作了。这题的特点是<b>如何判重</b>。我想了个笨办法，但也管用。对于小岛的形状，比如它所在的<b>矩形框</b>是p x q的（注意，不是m x n），我把这p x q框框里面的<b>01内容</b>，都<b>连成一个字符串（或者位向量也行）</b>，然后把字符串记录下来。这样判重就可以用<b>哈希表</b>做了，解决了。说白了，就是<b>序列化</b>。不过要注意，<b>框框里</b>如果有<b>别的小岛</b>，不要混进去了。序列化还有其他方式，比如所有点都<b>平移到同一个相对位置</b>，让参考系对齐，这样也行。

<hr>

695 Max Area of Island

题意：给定m x n的矩阵表示一个地形。0是水，1是陆地。陆地可以按4方向连成小岛。请求出<b>最大小岛的面积</b>。

难度：medium

解法：flooding算法，搜索求和即可。返回最大值。

<hr>

696 Count Binary Substrings

题意：给定一个01串s，请返回s中<b>0和1个数相等</b>，且<b>0在一起、1在一起</b>的子串个数。

难度：easy

解法：这个要求太严格了，因此只能发生在<b>连续0和连续1的交界处</b>。统计每一段连续0、连续1的个数，比如x个0、y个1，那就是`min(x,y)`个。<b>继续下个边界</b>，继续统计。<b>结果累加</b>。总代价<b>O(n)</b>。

<hr>

697 Degree of an Array

题意：给定数组nums，它的<b>“度”</b>定义为其中<b>最大的频率值</b>。请求出nums的<b>最短子数组</b>，使得子数组的度等于nums的度。返回长度。

难度：easy

解法：首先对nums做统计，求出<b>最大频率</b>，以及最大频率对应的值。统计的同时，也把每个值出现的<b>第一次i1、最后一次i2</b>位置记下来。把<b>最大频率对应的值</b>，扫一下。对每个值，找出<b>`i2-i1+1`</b>的最小值，就是答案。

<hr>

698 Partition to K Equal Sum Subsets

题意：给定数组nums，请问能否<b>划分为4个子序列</b>，使得4个部分的和相等？

难度：medium

解法：不要求连续，因此可以视为<b>子序列划分</b>。如果是划分为2组，可以作为一个<b>01背包问题</b>处理。划分为4组的话，则可以理解为<b>背包^3</b>。这么做太麻烦了，还是直接<b>搜索+回溯</b>吧。虽然数据规模已经很小了，还是注意<b>剪枝优化</b>。

<hr>

700 Search in a Binary Search Tree

题意：给定二叉搜索树和目标值val，如果存在，请返回节点。否则返回null。

难度：easy

解法：这就是原封不动的<b>BST的基本用法</b>。小了向左，大了向右，相等返回。

## 0701 - 0800

701 Insert into a Binary Search Tree

题意：给定二叉搜索树，请插入一个新值。

难度：medium

解法：如果只插入节点的话，<b>方法是唯一的</b>。但如果你要对树结构进行调整，比如<b>平衡</b>的话，那就有很多种。

<hr>

702 Search in a Sorted Array of Unknown Size

题意：给定一个不知道大小的有序数组，你可以通过一个reader类进行访问。如果下标越界，则返回2^31-1。请设计算法查找一个值target。

难度：medium

解法：付费题。这题虽然不知道大小，但越界返回的值也<b>相当于无穷大</b>。这样的话，<b>照常进行二分搜索</b>就行了。

<hr>

703 Kth Largest Element in a Stream

题意：给定一个数据流，你需要支持<b>添加数据、查找当前第k大</b>，这两个功能。

难度：easy

解法：用一个<b>最小堆</b>，保持当前最大的k个元素，堆顶就是第k大。在<b>插入数据</b>时，注意更新这个堆。如果<b>堆顶元素小于新值</b>，那就pop()然后插入新值。

<hr>

704 Binary Search

题意：有序数组，二分搜索。

难度：easy

解法：就是最标准的二分搜索。

<hr>

705 Design HashSet

题意：不用标准库自带的<b>哈希表</b>，自己手写一个哈希表<b>集合</b>。

难度：easy

解法：很奇怪，附近这几个题<b>都像教科书一样标准</b>。自己实现哈希表，那就是学习<b>散列机制、哈希函数、冲突解决</b>这三件事了。

<hr>

706 Design HashMap

题意：手写一个哈希表字典。

难度：easy

解法：哈希本身的<b>机制是一样的</b>，用于set或者map，那就是<b>形式和用途</b>不同了。通常我们说“哈希表”，都是指的hash map。说“集合”，则指hash set。

<hr>

707 Design Linked List

题意：手写一个<b>链表</b>，支持<b>对特定下标</b>的<b>查询、插入、删除</b>。

难度：medium

解法：还真是，这连续几题就是<b>数据结构的基础课</b>。这次是<b>单链表</b>。

<hr>

708 Insert into a Cyclic Sorted List

题意：给定一个<b>首尾相连的有序循环链表</b>，请插入一个值val，使得插入后<b>依然有序</b>。

难度：medium

解法：因为是链表，<b>没法二分搜索</b>。那就用head开始，往前<b>一步步找</b>插入位置吧。注意<b>边界case</b>。

<hr>

709 To Lower Case

题意：字符串转小写。

难度：easy

解法：水题。

<hr>

712 Minimum ASCII Delete Sum for Two Strings

题意：给定字符串s1、s2。请删除最少的字符，使得两串相等。返回删除字符的ASCII值之和。

难度：medium

解法：就是<b>最长公共子序列</b>（LCS）。把LCS之外的字符的ASCII码加起来即可。

<hr>

713 Subarray Product Less Than K

题意：给定数组nums和整数k。请求出<b>子数组乘积</b>小于k的个数。

难度：medium

解法：乘积，那么数组元素是否非负就很重要了。这题里，数组元素确实<b>大于零</b>，因此<b>连乘是递增的</b>。还是非常标准的<b>双指针+滑动窗口</b>思路，不多说了。总代价<b>O(n)</b>。

<hr>

714 Best Time to Buy and Sell Stock with Transaction Fee

题意：121的变体。已知股价，你可以做多次交易。但这次，每一笔交易有<b>固定的交易费</b>。请求出<b>最大获利</b>。

难度：medium

解法：还是DP问题，O(n^2)的思路很容易。对于当前位置i，往前枚举位置j，做一次交易，找出`max(dp[j-1]+max(0,p[i]-p[j]))`最大获利。但这题肯定有<b>O(n)</b>的思路，这个需要一点思考。看了下当年的代码，我很怀疑<b>是不是我自己独立想出来的</b>？很难理解。关键思路是，<b>不论你做几次买卖</b>，都将其视为<b>“一次”</b>。这样你总是考虑当前的价格p[i]是否是一个好的<b>卖价</b>，注意是卖价。那么<b>买价</b>怎么算？就把当前的最大获利max_sum减掉，就是卖价`p[i]-max_sum`。每次都用这个买价做一次交易，`max_sum=max(max_sum, p[i]-max_sum-fee)`，就得到了当前最优值。这思路挺诡异的，我怎么可能想得出来。

<hr>

716 Max Stack

题意：设计一个<b>最大栈</b>，有标准的入栈、出栈操作，还可以获取、弹出<b>当前最大值</b>。

难度：easy

解法：付费题。这题在<b>155</b>已经有了，为什么重复出题？

<hr>

717 1-bit and 2-bit Characters

题意：给定一个01字符串，由<b>0、10、11</b>三种“字符”组成。如果给定的字符串以0结尾，请判断最后一个字符是否必须是0？

难度：easy

解法：<b>线性DP</b>，O(n)代价递推到结尾。用dp[i]表示前i位组成的串<b>是否合法</b>。那么，如果<b>dp[n-1]合法，但dp[n-2]不合法或最后两位不是10</b>，则只有<b>一种可能</b>，就是最后一个字符必须是0。

<hr>

718 Maximum Length of Repeated Subarray

题意：给定两个数组nums1、nums2，请判断两个数组的<b>最长公共子数组</b>的长度。

难度：medium

解法：不是最长公共子序列，是<b>子数组</b>。如果你第一思路是做<b>类似字符串匹配</b>的方法。比如枚举nums1，取和nums2做匹配；又比如枚举nums1、nums2的子数组，记录哈希值并且比较。那你就掉坑里了。这题用<b>DP思路</b>其实非常简单，用dp[i][j]表示<b>nums1[i]结尾、nums2[j]结尾</b>的<b>最长公共长度</b>。

<hr>

719 Find K-th Smallest Pair Distance

题意：整数a、b的距离，定义为`|a-b|`。给定数组nums和整数k，请找出所有`(nums[i],nums[j])`对的距离里，第k小的值。第k小指的是所有值里，<b>不去重的第k个</b>。

难度：hard

解法：首先，第一想法是把nums<b>排序</b>，代价O(nlogn)。那么这样总共有C(n,2)=n*(n-1)/2个值，因此k的规模是O(n^2)的。这也就代表，在题目给定的n范围，<b>一个O(k)代价的做法也会超时</b>，不可接受。更不用说O(klogn)了。所以<b>用n-1个指针+最小堆的解法</b>，就不用说了。现在我们<b>反向思维</b>，找一个x，使得x在这些距离里，<b>恰好排第k位</b>。于是，针对这个值的<b>二分搜索</b>就可以做了。那么给定一个值x，怎么确定<b>它排第几位</b>？用O(nlogn)代价可以做到。具体做法，对于x，在nums（已有序）里针对每个位置i，<b>bisect_left方式</b>二分搜索<b>nums[i]+x的位置j</b>。把所有j-i累加起来，就知道有多少个数对(nums[i],nums[j-1])的<b>距离是小于x</b>的。因此，对x的一次二分的代价是O(nlogn)，则总代价为`O(nlogn*log(max(max)-min(nums)))`，效率不错。这种<b>反向思维，用二分直接搜结果</b>的做法，也不是第一次见了。

<hr>

720 Longest Word in Dictionary

题意：给定一个词表，请找出其中最长的单词word，使得<b>word的每个前缀</b>都在这个词表里。

难度：medium

解法：从头到尾都是<b>前缀匹配</b>，完美的<b>字典树</b>使用场景。

<hr>

721 Accounts Merge

题意：给定一些账户信息，每条信息的第一个是<b>名字</b>，随后<b>都是邮箱</b>。如果两个账户存在一个<b>共同的邮箱</b>，则属于同一用户。用户名字相同，不代表任何依据。

难度：medium

解法：以数据规模来看，O(n^2)的效率也是可接受的。对于邮件列表，因为需要求交集，直接用set保存比较方便，可以<b>一键求交</b>。至于账户合并，可以先给账户<b>分配一个唯一id</b>，然后建立`邮箱->[id列表]`的映射，这相当于<b>倒排索引</b>了。这样的话，也更方便进行<b>账户合</b>并了。看了下当年写的代码，确实是这么做的。

<hr>

722 Remove Comments

题意：给定一段C++代码，用source[i]表示第i行。请编写代码，去除代码中的<b>“//”单行注释和“/* ... */”多行注释</b>。

难度：medium

解法：parser题。这个是真麻烦啊...注意各种边界case。看来我当年的代码写的太难看了，现在保存的这份是别人的。<b>网友的版本总是那么简洁</b>。

<hr>

723 Candy Crush

题意：著名的<b>消消乐游戏</b>，我们这边也有开心消消乐。基本规则是，<b>3个以上的横排、竖排同类棋子</b>，可以消除。且消除后棋子会下落，如果<b>下落产生了可消除的组合</b>，则<b>继续执行</b>直到无法消除为止。在本题中，棋盘外不会落下额外棋子，仅对当前棋盘board，<b>实现消除算法</b>。注意一些特殊形状，比如<b>L型、T型、5连</b>等等。

难度：medium

解法：付费题。字面意思的<b>模拟题</b>了。数据规模非常小，因此可以实现得<b>朴素一点</b>，无须特别优化。按规则写，<b>不断检查不断消除</b>即可。

<hr>

724 Find Pivot Index

题意：给定数组nums，如果某个位置i，<b>左侧元素和恰好等于右侧元素和</b>，则称i为<b>支点</b>。请找出<b>最左的支点</b>，不存在则返回-1。

难度：easy

解法：<b>前缀和后缀和</b>，代价都是O(n)。按每个位置，检查一下左右和即可。

<hr>

725 Split Linked List in Parts

题意：给定单链表，将其分为k段。要求所有段<b>长度相差不超过1</b>，且<b>前段的长度不短于后段</b>。

难度：medium

解法：其实就是<b>尽可能均分</b>，且前面可以多分一个。纯粹考验耐心+仔细，追求<b>一遍过+bug free</b>。

<hr>

726 Number of Atoms

题意：给定化学式，请统计各种元素的原子个数。结果按<b>字典序</b>返回。

难度：hard

解法：<b>字符串解析题</b>。除了<b>对括号的乘法处理</b>外，其他特殊情况其实并不多。难度中规中矩。

<hr>

728 Self Dividing Numbers

题意：如果一个整数x，可以被它的每个位数整除，则称为<b>自除数</b>。给定left、right，返回`[left,right]`当中<b>所有自除数</b>。

难度：easy

解法：数据规模小，可以直接枚举。

<hr>

729 My Calendar I

题意：对于一个<b>事件</b>，记录开始和终止时间为`[start,end)`。请设计一个<b>日历</b>结构，实现<b>添加事件的add()函数</b>。每次调用add()时，如果事件<b>不会发生时间重叠</b>，则成功添加并返回true；否则返回false。

难度：medium

解法：定义<b>已成功添加的事件数组</b>为events，它是<b>不能存在重叠的</b>。这给我们插入新事件提供了方便，可以直接二分搜索。比如新事件为`[x,y)`，那么bisect_left查找start>=y的最小位置j。则应该插入在j-1处。如果j>=1，则检查events[j-1]和`[x,y)`是否存在重叠。<b>如果不重叠，就成功插入</b>，否则false。如果觉得<b>插入的O(n)代价</b>不可接受，还可以继续优化。<b>用一个map代替数组</b>，来保存这些区间。这样<b>查找和插入都是O(logn)</b>了。

<hr>

731 My Calendar II

题意：729的变体。这次重叠的要求，从两区间变成了<b>三区间重叠</b>。如果<b>三个时间共享了某个时段</b>，则存在冲突。

难度：medium

解法：如果你想<b>重新找一个思路</b>，那就想复杂了。比如两区间冲突，这是<b>是或否的问题</b>；k区间冲突，这是<b>计数问题</b>。其实k区间冲突，等于是<b>k-1区间冲突了，再冲突一次</b>。因此，你可以在<b>插入区间</b>时，把<b>二区间的交集结果events2</b>记录好。然后把新区间`[x,y)`和<b>events2</b>再求交。如果<b>还有交集</b>，那就是三区间冲突了。如果没有，则可以插入。看了下当年的代码，显然我当年脑子不开窍，居然写了<b>线段树</b>。<b>老实人</b>了属于是。不过，即使用上面提到的<b>“求交再求交”</b>的思路，也<b>不是三两句话就写完</b>的。这题还是有一定难度。

<hr>

732 My Calendar III

题意：729的变体。这次是<b>k区间重叠</b>了。但这次问题变了，要求在添加所有区间后，求出<b>区间的最大重叠数</b>。

难度：hard

解法：实际上<b>问题变简单了</b>，这个hard难度是不公允的。731题明显更难。对于区间重叠数，直接采取树状数组的<b>区间+1，然后单查最大值的思路</b>即可。<b>因为是批处理，并不需要用树状数组</b>。直接用一个dict记录<b>每个区间两端点的计数</b>也能满足我们的需求。代码很简短，思路也不算难。

<hr>

733 Flood Fill

题意：实现<b>画图程序</b>中的<b>油漆桶功能</b>。对某个像素和<b>它周围所有的同色像素</b>，将其变为指定颜色。

难度：easy

解法：标准的<b>洪泛算法</b>，flood fill。

<hr>

734 Sentence Similarity

题意：两个句子，由<b>单词数组</b>表示。给定一些<b>相似的词对</b>。如果两句子的所有<b>对应位置</b>的词，<b>都相同或者相似</b>，则两句子相似。注意，相似关系是<b>对称但不传递的</b>。

难度：easy

解法：付费题。首先检查长度是否相等。然后把<b>相似词对</b>转换成一个<b>哈希表</b>，方便查询。再对句子中<b>每个位置做检查</b>即可。

<hr>

735 Asteroid Collision

题意：给定一些小行星，从左到右排成一排。用数组asteroids表示每个小行星的<b>尺寸和方向</b>。+表示右，-表示左。所有小行星<b>运动速率相同</b>。如果小行星碰撞，<b>大的无损，小的消灭</b>。如果两个一样大，则都消灭。请求出最终剩余的小行星状态。

难度：medium

解法：第一反应，这题肯定有O(n)的解法。用一个<b>栈</b>记录正值，也就是<b>向右走的小行星</b>。比如我<b>拿到负值</b>，则对<b>当前所有的正值</b>做判断。如果<b>没有正值</b>，则这个负值可以保留；如果有，则判断<b>谁消灭谁</b>，或者同时消灭。比如我拿到正值，则直接入栈即可。最终的结果里，<b>负值一定都在左，正值一定都在右</b>。

<hr>

737 Sentence Similarity II

题意：734的变体。这次相似关系是<b>对称且传递的</b>。还是判断两个句子是否相似。

难度：medium

解法：付费题。既然唯一的区别就是<b>传递性</b>，那么相似集合的处理方式就变了。这次改用<b>并查集</b>。为什么？因为<b>传递性+对称性</b>，这就是<b>无向图的连通</b>，并查集，对吧？

<hr>

738 Monotone Increasing Digits

题意：给定整数n，求出不超过n，且<b>数位递增</b>的最大整数。

难度：medium

解法：在10^9范围内，<b>搜索空间</b>其实很小。先<b>确定n的位数</b>，然后<b>从9开始反着搜</b>就行了。结果并不多，直接<b>预计算</b>也是可以的。

<hr>

739 Daily Temperatures

题意：给定一个数组表示每天温度。对于每个位置i，请求出第i天之后，<b>第一次温度超过这天</b>需要<b>等多少天</b>。如果不存在，则结果视为0。

难度：medium

解法：翻译过来，就是i之后，第一个符合`nums[j]>nums[i]`的`j-i`值。一看，就很像<b>单调栈、单调队列</b>之类的做法。那就用栈吧。如果遇到<b>更小的元素</b>，就不断入栈；如果遇到一个<b>大于栈顶</b>的元素，就一直出栈出栈出栈，这些出栈位置的答案就有了。等弹完了，当前这个再入栈。最终<b>留在栈里</b>，出不去的元素，就是没找到<b>更大值</b>的。这些位置的<b>结果都置为0</b>。总代价O(n)，思路和实现都不难。

<hr>

740 Delete and Earn

题意：给定数组nums，允许你做某种操作。从数组中选一个`nums[i]`，删除它并<b>得分nums[i]</b>。但同时，你也必须删除所有值为`nums[i]+1`和`nums[i]-1`的元素。请问数组全部删光时，你的最大得分是多少？

难度：medium

解法：乍一看没什么思路。先想想，比如你删了nums[i]，然后如何如何。那假如数组里<b>还有值为nums[i]的元素</b>，你会怎么办？<b>当然是都删掉</b>。因为重复删一个值，后面那些+1-1的<b>副作用删除</b>就没意义了，也就没有额外损失。因此，对于某个值x，你必然要删除所有值为x的元素，并得到x*count(x)分。有这个思路，就可以把nums进行<b>计数+排序</b>。比如`[2,2,3,3,3,4]`变成了`[(2,2),(3,3),(4,1)]`那么接下来这就成了个<b>DP题</b>。比如你删了2，3就没了，4不影响；比如你删了3，2和4都没了；比如你删了4，3就没了，2不影响。如果值相差超过1了，就互不影响。剩下不讲了，DP解决吧。看了下几年前的代码，和这个思路完全一致。

<hr>

741 Cherry Pickup

题意：给定一个n x n地图，每一格可能是0、1、-1三种值。0是空地、1是樱桃、-1是墙。你从`(0,0)`出发，每次<b>向右或向下</b>到达`(n-1,n-1)`。沿途可以<b>采樱桃</b>。到达之后，再<b>向左或向上</b>返回(0,0)，沿途可以采樱桃。请返回<b>最大的采樱桃个数</b>。

难度：hard

解法：如果只有一次路径，问题就简单多了，用dp[i][j]做<b>二维DP</b>即可。现在允许返回，其实是<b>等价于从(0,0)出发两次</b>。如果按<b>贪心思路</b>，第一个路径最优，然后在最优基础上，<b>第二个路径还找最优</b>，这样行吗？看来是不行的，结果不对。最后<b>没想出很好的思路</b>，看了下讨论区，原来真是<b>搜索剪枝+记忆化</b>的。这就有点束手无策了。

<hr>

742 Closest Leaf in a Binary Tree

题意：给定一个二叉树，<b>节点值无重复</b>。现在给定其中某节点的值k，请找到离这个节点<b>最近的叶子结点</b>。<b>“最近”</b>指的是，从该节点出发，沿任意方向<b>经过最少的边</b>，到达一个叶子节点。请返回<b>节点的值</b>。

难度：medium

解法：付费题。首先，这个k值是代表一个<b>存在的节点</b>的。因此，你需要求的是<b>这个节点，和所有叶节点的距离</b>。有一种很容易想，但<b>稍浪费空间</b>的办法。对于每个叶子结点，在遍历时都记录下它的路径。比如<b>“左右左左左”</b>，我记为<b>“01000”</b>。同理，节点k也记一个路径。然后把这些<b>字符串做比较</b>，就知道两节点间的距离了。比如<b>“01000”和“001”</b>，公共前缀“0”，后面不同部分的长度是`4+2=6`，因此两节点的距离就是6。最后找出这个<b>和k距离最小</b>的节点，返回节点值就行了。

<hr>

743 Network Delay Time

题意：给定一个<b>有向图</b>，一条边`(x,y,w)`表示从x到y的延迟时间为w。现在从k发出一个广播信号，请求出所有点都收到信号的<b>最小时间</b>。

难度：medium

解法：有向图，<b>单源最短路径</b>。非常标准的Dijkstra算法场景了。这题求的是所有<b>最短路径中的最大值</b>。

<hr>

744 Find Smallest Letter Greater Than Target

题意：给定一个<b>有序的字符数组</b>和一个字符target。请返回数组中大于target的最小字符。如果不存在，则返回第一个字符。

难度：easy

解法：二分搜索即可，这就是bisect_right。

<hr>

745 Prefix and Suffix Search

题意：给定一些单词，请设计一个结构，提供针对<b>前缀和后缀</b>的检索。如果检索结果有多个，只返回<b>字典序最大</b>的一个。

难度：hard

解法：很显然，这种问题都需要<b>分析数据规模</b>，看看难点在哪儿。这题的单词数量很多，检索次数也多，但每个单词很短。这就很适合<b>字典树</b>了。字典树是前缀结构，对<b>后缀</b>的处理怎么办？那就建一个反转的字典树，<b>后缀变前缀</b>好了。执行检索时，前后缀用<b>两个字典树</b>分别查，求交集，并取最大值。这个解法可行，也确实能过。但仅仅是针对这题能过，其实解法<b>并不健壮</b>。其实我想了很多种办法，但几乎每种办法，我都能<b>轻松找到worst case</b>，让这个办法的<b>效率一塌糊涂</b>。干脆还是选最直观的一种吧。

<hr>

746 Min Cost Climbing Stairs

题意：给定0-n级台阶，从第i级往上，需要花代价cost[i]。可以爬到i+1或i+2级。请问从0级出发，<b>到达n级</b>的最小代价是多少？

难度：easy

解法：水题，最直接的<b>DP</b>。

<hr>

747 Largest Number At Least Twice of Others

题意：给定数组，判断最大值是否是其他<b>所有元素的至少两倍</b>。返回最大元素的下标，否则返回-1。

难度：easy

解法：水题。

<hr>

748 Shortest Completing Word

题意：不写了。

难度：easy

解法：评论区对这题的评价是<b>无聊又冗长</b>。这个题目的意义，就是告诉你现实工作就是这样的，有非常多的<b>具体、简单、重复</b>的事情要做，不可能总有那么多<b>精彩的脑力运动</b>。

<hr>

749 Contain Virus

题意：给定一个m x n矩阵isInfected。值为1表示被病毒感染。每过一天，病毒会按<b>4邻接</b>方向传播一格。在每天病毒传播之前，你可以选定<b>一个</b>病毒<b>面积最大的区域</b>建立隔离墙。直到隔离全部完成，或者全部被感染为止，请问隔离墙的<b>总周长</b>是多少？

难度：hard

解法：首先题目的关键是隔离墙，这个不是占用格子，而是<b>占用边</b>。因此，你要算的是<b>周长</b>。比如一个1 x 1格子，周长是4。题目明确告诉你了隔离顺序，每次都找<b>当前面积最大</b>的病毒区域，那你就需要有比较高效的办法，来动态更新每个区域的面积。无向连通图，统计节点个数，这显然适合用<b>并查集</b>。给每个区域设置一个点作为根，其他点都连上去，连的时候顺便<b>做好计数</b>，就可以知道面积了。再用一个哈希表，保存`根节点->该区域面积`的映射。这样，当你做病毒扩散时，就能随时更新面积了。找最大面积，就直接`max(mm.values())`枚举一下就行了，<b>区域个数</b>毕竟不会很多。对于<b>病毒传播和面积统计</b>，效率都是尽可能高的，总体效率不错。

<hr>

750 Number Of Corner Rectangles

题意：给定一个m x n的01矩阵。如果四个1的位置恰好能构成<b>矩形的4个角</b>，则称为一个“角矩形”。

难度：medium

解法：付费题。从题目规模看，暗示你时间应该是O(n^3)。那么比如我枚举<b>左上和右下</b>，则左下和右上的位置，可以用O(1)代价进行检查。这样的话，时间是`O(n^2*n^2)=O(n^4)`，太慢了。怎么优化？现在我们想想两行，比如`10101`和`00110`，那么比如某两行，有几个<b>列位置</b>有<b>共同的1</b>。就比如有k个，这代表我可以找出`C(k,2)=k*(k-1)/2`个矩形，因为从中任选两列，就是一个矩形。那么，<b>枚举两行，求1的交集</b>，这个代价就是`O(n^2*n)=O(n^3)`，算矩形个数代价是O(1)，<b>总代价是O(n^3)</b>，符合题目要求，因此这个办法能过。还有更好的解法，比如O(n^2)吗？暂时没想出来。

<hr>

751 IP to CIDR

题意：给定一个起始IP，和需要的IP个数。请返回对应<b>IP子网的掩码</b>。

难度：easy

解法：付费题。这个倒是没什么难点，纯粹的<b>计算机网络知识</b>。请查阅CIDR的相关定义。因为比如子网a.b.c.d/xx，那么这个a.b.c.d的二进制表示中，<b>后32-xx位</b>必须全部是0，这是起始地址的要求，否则就不叫<b>“掩码”</b>了。比如192.168.0.8，这个地址可以搭配/29，却不能搭配28。因为8=1000，第4位非零，不能组建一个大小为2^4=16的子网。按这个思路，把n拆分成一些<b>2的幂之和</b>。

<hr>

752 Open the Lock

题意：4位数字锁，行李箱那样的。<b>0-9一圈</b>，可以旋转拨动。现在从0000开始，如果你<b>每次操作</b>可以转动<b>任意一格一位</b>。存在一些死锁密码，如果你转到这些状态，则<b>轮子锁定</b>，无法再拨。给定某个目标密码，请问<b>最少多少次</b>能拨出？如果做不到，则返回-1。

难度：medium

解法：首先，你知道总的<b>搜索空间只有10000</b>。那么效率就不成问题了。从0000开始，每个状态直接<b>用一个整数</b>表示，按+-1、+-10、+-100、+-1000的方式做状态转移（还有9变0的情况），<b>执行BFS</b>。在BFS过程中，对于<b>死锁状态</b>，则停止搜索。如果能搜到<b>目标密码</b>，则<b>对应的步数</b>就是答案。

<hr>

753 Cracking the Safe

题意：有一个<b>n位k进制</b>的密码锁，你可以不断输入数字。每次都只检查最后n位，判断是否正确。现在给定n和k，请找出一个<b>最短的</b>输入序列，使其能解锁<b>任何n位k进制序列</b>。

难度：hard

解法：题目读得人一头雾水，意思其实是让你找出一个最短的串，让这个串包含了<b>k^n</b>个不同的n位串。题目还特地提示你k^n<=4096，这就是告诉你虽然问题很难，但规模非常小。可以用比较暴力的方式，比如<b>尝试生成这个串</b>。实际上，按<b>贪心策略</b>尝试生成一个这种串，可以，但是很可能是错的。这个串有个名字，叫<b>de Brujin序列</b>。求解这个序列可以转化成一个<b>Hamilton路径</b>问题。有人提交了贪心+暴力搜索的解法，过了。这足以证明这题实在是<b>难得离谱</b>，以至于只能用<b>很弱的测试集</b>。这题是真的被Google拿来面试的，无话可说。想不到<b>建图</b>的话，这题真就没什么<b>准确思路</b>了。可没有<b>先验知识</b>的话，谁能<b>第一时间</b>想到？

<hr>

754 Reach a Number

题意：给定一个数轴，你从0位置出发，可以走任意步。在第i步（1开始）时，你可以选择<b>走-i或者+i距离</b>。如果目的地为target，请问最少多少步可以到达。

难度：medium

解法：这个target是10^9范围，但你的步长是逐渐递增的，因此需要的步数大致是`O(sqrt(target))`的。首先，问题是<b>对称</b>的。于是负数可以改为正数。最直白的思路，就是从0开始执行BFS。这么做的问题，在于每次有两种选择，是不是很快就会出现<b>2^k个状态</b>，导致<b>搜索爆炸</b>？其实不用搜，1+...+n求和，找这个n即可。剩余部分的思路，就很<b>小聪明</b>了。这题被很多人吐槽，我也有同感。就是<b>坑人的智力题</b>。

<hr>

755 Pour Water

题意：一维接雨水，但这次<b>水量有限</b>。如果在<b>位置k</b>，倒入了<b>总量为v</b>的水。因为如果地势存在高低，则水优先向左流，其次向右。如果处在低洼，则可以存水。请求出<b>每个位置</b>最终存了多少水。

难度：medium

解法：付费题。和接雨水其实有<b>两个关键不同</b>，但总体确实相似。一个是水量有限，一个是<b>优先往左</b>。怎么处理？其实这题比接雨水简单，因为<b>数据量太小</b>了。如果真的按同规模，有限水量的情况就难想很多。但因为水量v和数组长度都很小，你甚至可以<b>一滴一滴地模拟</b>。那就模拟吧。看了下，我还真是一滴一滴做的。

<hr>

756 Pyramid Transition Matrix

题意：给定一个字符串s，由一些字母组成。你需要在上面继续用字母堆金字塔。要求第i层有i个字符，字符串s作为最底层。在堆金字塔时，要求每个小三角（上一下二共3个字符）都包含在allowed集合中。一个三角用ABC形式表示，意思是<b>A左B右C上</b>。按照给定的底座s，请问能否搭出一个符合要求的完整金字塔。

难度：medium

解法：题目讲得这么复杂，难度却不是hard，那一定<b>数据规模很小</b>。确实很小，直接<b>搜索+回溯</b>吧。

<hr>

758 Bold Words in String

题意：给定一个字符串s和一个词表words。请将s中所有词表中的词用`<b>...</b>`加粗。如果<b>存在重叠</b>，则整个部分只使用一次加粗标签。

难度：easy

解法：付费题。<b>数据规模小</b>，因此不用在<b>匹配算法</b>上做很多优化。

<hr>

759 Employee Free Time

题意：有一些员工的<b>工作时段</b>记录，以list[list[list[int]]]形式给出，每个时段是`[x,y]`这样的区间。请求出<b>所有员工</b>都空闲的<b>有限时间段</b>，不包括<b>最早之前和最晚之后</b>这两种情况。

难度：hard

解法：付费题。如果要求一些别的，可能很难。但要求的是所有人的公共空闲时间，那相当于所有区间<b>求并集</b>，再用<b>总区间相减</b>。这样的话，倒是不算很难了。对区间排序，不断做<b>区间合并</b>即可，最后减一下。总区间是`[min(x),max(y)]`。我之前的代码是<b>先取反，再求交集</b>。道理相同，方法不同而已。

<hr>

760 Find Anagram Mappings

题意：给定数组A和B，已知A和B互为anagram。请确定一种A元素到B元素的下标映射。比如`A=[1,2,3],B=[3,1,2]`，则一种`A->B`的映射是`[1,2,0]`。

难度：easy

解法：付费题。这个映射是<b>一定能找到的</b>，而且方案<b>可能不唯一</b>，我们只需要用找一个就行。比如以A为基准，把B里面元素的值做一下位置映射`值->[出现下标列表]`。对于<b>A的每个元素</b>，查找B里面的对应下标，<b>每次pop一个</b>。这样的话，每次的代价都是O(1)，总代价是O(n)。

<hr>

761 Special Binary String

题意：给定一个01串，我们定义一种<b>特别串</b>。如果这个串的<b>1和0个数相同</b>，且它的<b>所有前缀</b>，1的个数都不少于0的个数。现在给定一个特别串s，允许你交换其中两个<b>相邻的特别子串</b>任意次。请求出能得到的<b>字典序最大</b>的特别串。

难度：hard

解法：题目讲得挺深奥，仔细读一下会发现这就是<b>括号匹配串</b>。1是“(”，0是“)”。不过这点其实并不重要，重要的是很快看出其中的<b>DP思路</b>。对于每个子串dp[i][j]，首先你要知道它<b>是否特别</b>。然后，你需要判断能不能从中做一下交换，得到<b>更大的字典序</b>。这个交换，是可以<b>递归往下做的</b>。但我们不需要递归，用DP方式<b>从短到长</b>计算就行了。DP总代价应该是<b>O(n^3)</b>，判断每个子串是否特别，也是O(n^3)。总体可接受。

<hr>

762 Prime Number of Set Bits in Binary Representation

题意：给定整数left、right。请统计`[left,right]`中间所有二进制表示里，<b>1个数是质数</b>的数的个数。

难度：easy

解法：数据范围很小，而且这样的数本身也不多。<b>预计算</b>也可以，<b>直接算</b>也可以。都挺好。

<hr>

763 Partition Labels

题意：给定一个字符串s，请将其<b>划分</b>为几个子串。使得这些子串之间，<b>互相没有共同字符</b>。

难度：medium

解法：记录每个字符出现的所有位置，不过我们只关心<b>第一个和最后一个</b>。比如当前i位置，字母是c，c的最后出现位置是j，那么<b>`[i,j]`这段</b>必须分到一个子串内。这时要继续检查`[i,j]`范围内的其他字符，按相同逻辑，这个边界还<b>可能继续延伸</b>。如果发现边界不用延伸，<b>到达j了</b>，则<b>这个子串结束</b>。这个思路是<b>贪心</b>的，因此问题不算难。

<hr>

764 Largest Plus Sign

题意：给定一个n x n的01矩阵，除了一些0之外，其余元素都是1。0的位置通过一些`[x,y]`坐标给出。请求出其中能找到的<b>最大的“+”号</b>。如果加号的四条边的长度为k-1，则称为“k阶加号”。返回<b>最大的k</b>。

难度：medium

解法：对于矩阵或者数组，<b>统计前缀</b>是个常见操作。那么这题求的是<b>四个方向</b>的延伸长度，实际上就是求<b>上下左右的“前缀”</b>。每个前缀计算的代价都是O(n^2)，<b>总代价还是O(n^2)</b>。

<hr>

766 Toeplitz Matrix

题意：给定一个m x n矩阵，如果每个<b>对角线</b>（不是反对角线）上的元素都是同一个值，则称为<b>Toeplitz矩阵</b>。请判断给定矩阵是否满足要求。

难度：easy

解法：按规则检查即可，<b>每个对角线</b>检查一次。

<hr>

767 Reorganize String

题意：给定字符串s，请将其字母重排，使得<b>任意相邻字符</b>都不同。如果做不到，则返回“”。

难度：medium

解法：其实这题和358题很像，而且更简单。为了使相邻字符都不同，我们可以认为有一个<b>cd机制，且cd时间是1</b>。用一个最大堆，每次总是取<b>剩余个数最多</b>的字母，但要判断一下<b>是否在cd中</b>。cd本质上是一个<b>等待队列</b>，但因为cd=1，这个队列其实容量只有1。因此你<b>用一个变量</b>记录它，也等效于一个队列了。也可以<b>不用堆</b>，而是<b>哈希+按个数排序</b>，思路大同小异。

<hr>

769 Max Chunks To Make Sorted

题意：给定一个`0~n-1`的排列。允许你划分几个子数组，并对每个子数组排序。如果这样就能得到`[0,1,...,n-1]`的升序结果，请问最多能划分几个子数组。

难度：medium

解法：这个题其实和763有点像。比如对于某个子数组`arr[i:j+1]`，如果它的所有值也恰好都在`[i,j]`范围内，那等于它就是一段<b>“完整的局部排列”</b>。我们需要找出几段，这样的局部排列。对arr的所有值做一下位置记录`值->下标`，从0开始，按照下标找右边界。比如`[1,0,2,3,4]`，其中[1,0]为什么分为一段？因为0在1位置，边界<b>最远延伸到1</b>；1在0位置，没有延伸边界。因此第一段的边界就是[0:2]，按这个思路，<b>一段段地找边界</b>，就能得到最终答案。

<hr>

771 Jewels and Stones

题意：给定一个串jewels，每个字符是一种宝石。给定一个串stones，都是石头。请判断石头里有多少个宝石。

难度：easy

解法：水题。

<hr>

773 Sliding Puzzle

题意：<b>华容道游戏</b>玩过吗？给定一个m x n的棋盘，分布了`1~m*n-1`个方块，有一块是<b>空位</b>，可以让<b>上下左右的方块</b>挪动。如果最后能移动成`1~m*n-1`从上到下、从左到右顺序排列，且<b>空位到了右下角</b>，则成功。本题的棋盘为固定的<b>2 x 3</b>，请求出最少的移动次数，如果做不到，则返回-1。

难度：hard

解法：实际上外面卖的华容道，以4 x 4的居多，格子从<b>1到15</b>。一个小朋友经过训练，都可以在两分钟内完成一局。判断无解其实也容易，如果移到最后，发现始终有<b>两格的位置恰好相反</b>，则无解。对于4 x 4，搜索空间最大是16!，已经非常大了。2 x 3则还好，总共只有6!=720种。直接按照华容道的规则，进行<b>BFS</b>，效率可接受。

<hr>

775 Global and Local Inversions

题意：给定数组nums，请判断是否<b>不存在</b>`(i,j)`，使得`j-i>1且nums[i]>nums[j]`。

难度：medium

解法：原题目的说法很啰嗦，但翻译过来就是这个意思。<b>逆序对</b>，且距离大于1。因为只用<b>判断存在</b>，不用统计总数。用统计后缀min的方法可以解决。对于arr[i]，我总是判断`min(arr[i+2:])`是否小于arr[i]，如果是，则<b>表示存在</b>。如果始终找不到，则不存在。

<hr>

776 Split BST

题意：给定二叉搜索树，请将其划分为<b>两个二叉搜索树</b>t1
、t2。使得t1节点均小于等于target，t2均大于target。

难度：medium

解法：付费题。这题因为要调整树的结构，遍历时，最好记录一下<b>父节点的位置</b>。往下递归，找到分界的节点p，以及它的父节点q。如果p.right非空，则让`q.left=p.right`。然后切断`q->p`这条边。注意一些<b>边界case</b>，比如t1为空、t2为空的情况。

<hr>

777 Swap Adjacent in LR String

题意：给定一个由LRX组成的字符串。如果允许将XL变为LX，将RX变为XR。请问给定起点start和终点result，能否通过以上变换，将start变为result。

难度：medium

解法：这个变换，其实相当于把“X”看成空位，L左移、R右移。那么我们可以理解，LR交叉是不可能变成RL交叉的。也就是说，去掉所有X后，<b>所有L、R的相对位置</b>不能变。那么，只满足这一条就够了？<b>不够</b>。比如XLRX可以变成LXRX，还可以变成LXXR；但反过来就不行。<b>这个移动是单向的</b>。因此，先判断第一条，看<b>所有LR的相对位置</b>是否匹配。然后判断第二条，看result中每个L、R中间<b>夹住的X的个数</b>，如果存在result的X个数<b>小于</b>start的X个数，则<b>不可能</b>。为什么？因为L、R是分别往两边跑的，中间的X<b>只会变多，不会变少</b>。这题总体上<b>稍有点难想</b>，代码很短。

<hr>

779 K-th Symbol in Grammar

题意：给定一个序列，第1项是0，对于第i+1项，把第i项中的<b>0和1</b>分别替换为<b>01和10</b>。给定n和k，请求出第n项的第k位是什么。

难度：medium

解法：第n项总共有2^n位。可以用<b>倒推</b>的思路。比如0变01，1变10。那么第k位，k是奇数，则等于`[n-1][(k+1)/2]`；k是偶数，则等于`1-[n-1][k/2]`。倒推回去，总代价O(n)。

<hr>

781 Rabbits in Forest

题意：树林里有一些兔子，<b>不知多少只</b>。问一个问题，“有多收兔子和你的<b>颜色相同</b>”。你得到了n只兔子的回答，请问至少有多少只兔子。

难度：medium

解法：挺有意思的一题，有种浓厚的<b>智力题</b>观感。比如有x只兔子，说有y只兔子和自己颜色相同。这代表什么？比如`x==y+1`，是不是正好是一群？比如`x<y+1`，有可能有兔子<b>没采访到</b>？比如`x>y+1`，有可能是<b>两群或者多群兔子</b>，且每群的个数一样？这三种情况都考虑到位，就知道怎么做了。

<hr>

783 Minimum Distance Between BST Nodes

题意：给定<b>二叉搜索树</b>，求出任意两节点的值相差的最小值。

难度：easy

解法：和530题相同。很奇怪，为什么会有<b>完全相同</b>的题？

<hr>

784 Letter Case Permutation

题意：给定字符串s，你可以把其中的字母变为大写或小写。请输出所有可能的变化。

难度：medium

解法：就是<b>搜索枚举</b>。

<hr>

785 Is Graph Bipartite?

题意：给定一个无向图，判断是否为<b>二部图</b>。

难度：medium

解法：<b>二部图</b>的具体定义就不说了。简单讲就是将点集分成两组V1、V2，则边集里的所有边`e=(x,y)`，其中x、y都必须<b>在V1、V2中各取一个</b>。二部图有<b>很多实际应用</b>，是个好东西。判断二部图不难，比如你从一个点x出发，如果有边x->y，则y在另一边；再找y->z，则z必须和x在一起。在遍历边的同时，就这样<b>反复横跳</b>，如果出现了<b>矛盾</b>。比如某个点必须<b>同时属于两个集合</b>，则不可能。如果遍历完了<b>没有矛盾</b>，则这个图<b>是二部图</b>。注意，二部图是不需要连通的，<b>可以有多个分量</b>。

<hr>

786 K-th Smallest Prime Fraction

题意：给定一个数组，其中包含1和一些<b>质数</b>。允许你任选两个元素，组成一个`nums[i]/nums[j]`的分数。请求出第k小的分数，返回`[nums[i],nums[j]]`。

难度：medium

解法：其实用质数的原因，就是确保不会有相同值，因为每个分数都是<b>最简分数，但这并不重要</b>。O(n^2)或者更慢的解法就不说了。我们用<b>n指针</b>的思路，放入n个指针到<b>最小堆</b>中，每次取出最小值，并把相应指针<b>前进一步</b>。用这个思路，<b>总代价是O(klogn)</b>。这个思路在很多地方出现过了，最典型的例子，是<b>k个有序链表归并</b>。

<hr>

787 Cheapest Flights Within K Stops

题意：给定一个有向图，代表<b>城市</b>和城市间的<b>航班</b>，权重代表<b>价格</b>。给定起点、终点、k，请求出从起点到终点，至多飞k次的最便宜路径。返回<b>总价格</b>，无可选路径则返回-1。

难度：medium

解法：依然可以用标准的<b>Dijkstra算法</b>，只不过在执行时，<b>只迭代k轮</b>。

<hr>

788 Rotated Digits

题意：给定整数x，如果x<b>旋转180度</b>，会变成另一个<b>有效且不同</b>的整数y，则称x、y都是<b>“好数”</b>。请求出`[1,n]`中一共有多少个好数。

难度：medium

解法：<b>018、25、69</b>，这些可以旋转。在给定的n范围内，<b>好数并不多</b>，可以直接<b>预计算</b>。

<hr>

789 Escape The Ghosts

题意：一个简易的<b>吃豆子游戏</b>。如果你从`(0,0)`出发，需要到达某个`(ex,ey)`。地图上<b>有一些怪物</b>，位置已知。每一轮，你和怪物都可以选择<b>上下左右移动一格</b>，或原地不动。如果你<b>碰到怪物</b>，则游戏失败。请判断是否存在策略，使得怪物<b>不论怎么移动</b>，也抓不到你。

难度：medium

解法：有点难想。然后<b>我突然想通了</b>，什么破题目。

<hr>

790 Domino and Tromino Tiling

题意：多米诺骨牌，是2 x 1的。现在再给一种拐角型的L骨牌，用这两种形状，拼出一个2 x n的形状。请问总共有多少种拼法？结果模`1e9+7`返回。

难度：medium

解法：很明显是<b>线性DP</b>问题。考虑一下<b>2 x 1、2 x 2、2 x 3、2 x 4</b>这四种情况，然后递推。

<hr>

791 Custom Sort String

题意：给定一个字符串order，其中的字符不重复，代表了一种<b>特殊字典序</b>。请按此顺序，对字符串s做排序。

难度：medium

解法：显然，order代表了某种和abcde...<b>默认顺序</b>的一一对应，但这种对应关系，最好<b>只局限在order里出现的字母</b>，这样不容易搞乱。因此，我们把<b>order和sorted(order)</b>建立一一映射。然后对s执行<b>替换->排序->换回来</b>这三步操作，得到的串就是最终结果。

<hr>

792 Number of Matching Subsequences

题意：给定字符串s和词表words。请返回词表中<b>属于s子序列</b>的个数。

难度：medium

解法：给定串s1和s2，判断子序列的代价是O(n1+n2)。那么这里有个小技巧，如果<b>s1很长，s2很短而且有多个</b>，那是不是应该减少<b>重复检查s1的次数</b>？因此，我们遍历s一次，<b>同时检查words里的所有词</b>就行了。这样，效率能做到最好。

<hr>

794 Valid Tic-Tac-Toe State

题意：井字棋游戏。给定一个用“XO ”表示的棋局，请判断这个状态<b>是否可能出现</b>。具体游戏规则就不说了。

难度：medium

解法：总的棋局状态是3^9个，但实际上，<b>有效的状态少很多</b>。因为<b>三子连线</b>，游戏就结束了。从空棋盘开始，直接<b>搜吧</b>。另外，还有先手X、轮流下棋等规则，都作为<b>搜索约束</b>。

<hr>

795 Number of Subarrays with Bounded Maximum

题意：给定数组nums和整数left、right。请求出<b>最大元素</b>在`[left,right]`范围内的子数组的个数。

难度：medium

解法：<b>滑动窗口</b>，用<b>SortedDict</b>做记录。剩下细节不说了。

<hr>

796 Rotate String

题意：给定字符串s和goal。请判断s能否通过<b>循环移位</b>变成goal。

难度：easy

解法：判断长度相等，其<b>s+s是否包含goal</b>即可，或者goal+goal是否包含s。

<hr>

797 All Paths From Source to Target

题意：给定一个有向无环图（DAG），请找出起点到终点的<b>所有路径</b>。返回完整路径。

难度：medium

解法：这题没什么陷阱。因为我们都很习惯做<b>不重复的图遍历</b>，于是这次给了你一个<b>需要重复遍历</b>的任务。你不必对点、边做visited标记，因为可能要走多次。直接<b>不标记</b>，搜就行了。<b>DAG的性质</b>保证了这个搜索能终止，如果存在<b>环</b>，那就卡死了。

<hr>

799 Champagne Tower

题意：给定一个香槟金字塔，每高一层少一个杯子。现在按<b>二维平面</b>考虑，不断倒酒，如果一个<b>杯子满了</b>，则会将酒<b>均匀流向</b>左右两边的<b>下方杯子</b>。每个杯子容量为1.0，请问在倒了<b>k单位的酒</b>后，<b>第p行q位</b>的杯子，有多少酒？

难度：medium

解法：这题难度medium，但评论区很多人觉得<b>奇难无比</b>。当年我也想不出来，但最近做了这题，很快就想到了。我也无法理解，这是<b>进步还是衰退</b>。其实最难想的主要是，第i行是不是<b>全满了</b>，第i+1行才有<b>第一滴酒</b>？答案是<b>否</b>。第二个坑，是不要每次<b>只倒1单位酒</b>，而是像接雨水那样，把<b>poured全倒出去</b>。然后通过<b>DP的思想</b>，逐层<b>往下分配</b>。这是浮点计算，中间都是0.5的关系，除了<b>两个端点</b>之外。具体递推关系就不说了，能把这个<b>思路想清楚</b>，代码就会写了。

<hr>

800 Similar RGB Color

题意：用`#RRGGBB`表示16进制的<b>RGB颜色</b>。如果单通道的两个16进制数相同，可以<b>简写成一个</b>。比如FF可以简写成F，11可以简写成1。现在定义两颜色的<b>相似度</b>为-(diff(R)^2+diff(G)^2+diff(B)^2)。给定一个颜色`#ABCDEF`，请找出形如<b>简写`#XYZ`</b>且和它<b>相似度最高</b>的颜色。

难度：easy

解法：付费题。讲得这么复杂，其实题目很简单。对RGB三个通道，问题是一样的。对于AB，找一个CC使得两者差的平方最小，也就是<b>绝对值`|AB-CC|`最小</b>。剩下不说了。

## 0801 - 0900

801 Minimum Swaps To Make Sequences Increasing

题意：给定数组nums1、nums2，允许从两数组<b>各选一个元素交换</b>，可交换任意次。请问<b>最少交换多少次</b>，能让两数组都<b>严格递增</b>？

难度：hard

解法：难，读完了毫无思路。实在想不出，看了下当年的代码。好像当年很轻易就搞定了，线性<b>DP解法</b>。DP的思路，在于递推时只关心<b>上一步</b>。存在`(a[i],a[i-1]),(b[i],b[i-1])`和`(a[i],b[i-1]),(b[i],a[i-1])`这两种情况。前者是上一步没交换，后者是<b>上一步交换过</b>。再根据i和i-1位置是否存在<b>值的逆序</b>，来判断<b>这一步</b>是否要交换。然后用`dp[cur]=min(dp[cur], dp[last])`的形式来更新当前的<b>最小交换次数</b>。感觉这<b>很难想</b>啊，虽然代码写起来很简短。怎么当年就轻易想出来了，不懂。

<hr>

802 Find Eventual Safe States

题意：给定一个有向图，出度为0的点，称为<b>终点</b>；从某点出发，一定会到达终点的点，称为<b>安全点</b>。终点也算安全点。请求出所有安全点。

难度：medium

解法：首先<b>建图</b>。不难看出，只要存在环，<b>环路上的点</b>都不是安全点。那是不是做环检测，去遍历一下？其实没必要。用<b>拓扑排序</b>就行了。拓扑排序的过程，会逐渐从<b>入度为0</b>的点开始，一个个移除。环路的点入度一定不为0，会始终留在里面。因此，<b>被去掉的所有点</b>，其实就是安全点。拓扑排序的具体做法就不说了。看了下当年的代码，我还真去遍历找环了...和现在想法不一样。

<hr>

804 Unique Morse Code Words

题意：摩尔斯电码。给定<b>编码方式</b>，以及一些单词words。请将其转为摩尔斯电码，并统计编码结果的不同值有多少个。

难度：easy

解法：按字面意思实现即可。

<hr>

806 Number of Lines To Write String

题意：给定26个字母的字符宽度，以及一个字符串s。请判断s总共需要多少宽度。

难度：easy

解法：水题。

<hr>

807 Max Increase to Keep City Skyline

题意：给定一个n x n的城市区域，每一格有一栋楼，高低不同。现在给定高度grid[i][j]。如果允许你<b>增加</b>任意建筑的高度，但要求任何高度改变，从<b>东南西北四个方向</b>都<b>看不出</b>任何变化。请问，建筑高度的<b>增加总和最大值</b>是多少？

难度：medium

解法：题目不是很难，但<b>描述有点晕</b>，让人容易理解错。其实意思就是，你从四个方向看，中间的某些房子变高了，但还是被挡住了。因此，你<b>看不见</b>。翻译过来，就是对于每个房子grid[i][j]，你可以让它变成`min(max(东),max(南),max(西),max(北))`，也可以写成`min(max(行),max(列))`，max值里要<b>去掉自身</b>。这个值怎么求，就不用说了。四个方向，<b>前缀max</b>搞定。

<hr>

808 Soup Servings

题意：我们有AB两种汤，开始都有n毫升。现在按照<b>25%的等概率</b>，四种方式使用汤：`(100,0),(75,0),(50,50),(25,75)`。如果剩余汤不足这个给定分量了，则<b>按比例用完</b>。请求出`p(A汤先用完)+0.5*p(AB同时用完)`。

难度：medium

解法：挺少见，纯粹的数学题。<b>这概率论的问题，要编程？</b>n的范围可以到1e9，完整的模拟就不考虑了。想不出来，看了下代码，发现<b>果然离谱</b>。首先<b>对数据/25</b>，缩小规模，这个可以理解。进行<b>记忆化搜索</b>，直接算，而放弃数学推导，这个很聪明，但至少还能理解吧。最离谱的是，根据<b>1e-5这个精度要求</b>，直接设了一个<b>搜索上限</b>，这个是真想不到了。没办法，以后<b>再遇到，我还是不会</b>。这脑洞题，难度仅仅是medium？

<hr>

809 Expressive Words

题意：给定单词t。如果把t中的<b>连续字母</b>进行延伸得到t'，使其<b>连续长度至少为3</b>，则称t'为<b>延长词</b>。给定字符串s和一些词words，请判断s是<b>words中多少词</b>的延长词。

难度：medium

解法：题目的描述<b>很拗口</b>。不过题目本身不难，对s和words中的每个词w进行检查。对照<b>字符是否匹配</b>，以及连续个数是否<b>至少3个</b>。比如`s=hello,w=helo`，<b>l不够3个</b>，就不符合要求。

<hr>

811 Subdomain Visit Count

题意：网站域名有<b>顶级、二级、三级</b>等等分类。比如com顶级、xxx.com二级、www.xxx.com三级。给定一些域名的<b>访问计数</b>，统计并返回所有子域（不是应该叫父域？）的访问计数。

难度：medium

解法：题目描述<b>太啰嗦</b>，实际是个水题。

<hr>

812 Largest Triangle Area

题意：给定二维平面的一些点，请从中找出三个，组成<b>最大的三角形</b>。返回面积。

难度：easy

解法：虽然说难度easy，直接枚举就行。但<b>三角形面积计算</b>，还是有不同方法的。最基础的，底乘高除以二；其次，海伦公式，很麻烦；最后，三点做<b>向量叉乘</b>除以二。其中，向量叉乘这个做法挺巧妙的，而且是<b>对称的</b>。具体公式是，`abs(|1 1 1;x1 x2 x3;y1 y2 y3|)/2`，这个<b>行列式</b>的绝对值除以二。学过线性代数的话，可以理解一下`|AB X AC|`和这个行列式的关系，<b>两者其实是等价的</b>。

<hr>

813 Largest Sum of Averages

题意：给定数组nums，你可以将其<b>划分</b>为<b>至多k个</b>子数组。请求出这些子数组的<b>平均值之和</b>的<b>最大值</b>。精度控制在`1e-6`。

难度：medium

解法：虽然这次答案不是整数，但<b>用值进行二分搜索</b>的思路还是很明显。给定一个值x，我们判断能不能划分至多k个子数组，使得这个<b>平均值总和>=x</b>。按这个条件去二分搜索。以这题的规模，判断方法有很多种，比如<b>DP思路</b>。不过，看了下当年的代码和评论区，没有人提到二分，都是<b>直接用DP解决</b>，包括我自己。看来想法不一样了。也难怪，<b>前缀和+DP</b>确实比二分的思路容易多了。

<hr>

814 Binary Tree Pruning

题意：给定二叉树，请将所有<b>节点值不包含1</b>的子树都删除。

难度：medium

解法：递归处理，同时记录好<b>父节点</b>。返回值表示是否包含1，如果否，则让<b>父节点</b>删除这个子树。唯一的特殊情况，就是<b>整棵树</b>都被删了。

<hr>

815 Bus Routes

题意：公交路线。现在给定一些公交路线，每条都是<b>环路</b>。每个站点用一个整数编号，你从src出发，需要到达dst。可以在不同公交上<b>换乘</b>，请返回<b>搭乘线路</b>的最小个数。如果无法到达，则返回-1。

难度：hard

解法：注意，不是总站点数，是<b>线路个数</b>。这就不在乎<b>一条线路有多长</b>了。可以认为<b>这不是图论题</b>，直接<b>BFS</b>就行。从src开始，把和src同线路（可能有多条）的所有站点都<b>入队</b>，计数为1。比如到达某个换乘站x，再把和x同线路，且<b>未访问</b>的站点都入队，<b>计数加1</b>。这样，<b>搜到dst或者队列清空</b>为止。如果始终搜不到dst，表示不可到达，返回-1。

<hr>

816 Ambiguous Coordinates

题意：给定类似`(1, 2.3)`这样的实数二维坐标。如果去掉<b>逗号、空格、点</b>变成了`(123)`。现在给定一个变化后的坐标，请返回所有可能的<b>原坐标</b>。

难度：medium

解法：这个没什么技巧，就是<b>搜索枚举</b>。注意，测试集里有些坑人的情况，需要<b>想得仔细点</b>。

<hr>

817 Linked List Components

题意：给定链表L和数组nums。nums中的值是L的子集。如果L中两点相邻，则表示<b>连通</b>。请返回nums中的<b>所有连通分量</b>。

难度：medium

解法：题目描述几乎<b>不知所云</b>，而且<b>歧义很大</b>。对于题目本身，并不难，直接视为<b>无向图的连通分量</b>即可，<b>并查集</b>解决。

<hr>

819 Most Common Word

题意：给定一段英文，请找出不在banned词表里，且最频繁的词。对文本按<b>大小写不敏感、忽略标点</b>处理。

难度：easy

解法：按题意实现即可，字符串处理。

<hr>

820 Short Encoding of Words

题意：给定一些单词words，可将其编码为一个参考串s和下标数组indices。比如`["time","me","bell"]`编码为`"time#bell#"`和`[0,2,5]`。编码规则是，对于words[i]，在s里找<b>indices[i]开始，到下一个“#”结束</b>的子串。请找出参考串s的<b>最小长度</b>。

难度：medium

解法：首先，很容易发现这个<b>后缀规律</b>。比如abcde和cde，那么我用“abcde#”就能表示了。前缀或中间包含可以吗？<b>不行</b>。所以，把所有字符串<b>反转</b>，然后<b>排序</b>。这样，前缀关系的串就会排在一起（其实就是后缀）。对于<b>每组前缀</b>，都只保留<b>最长的串</b>。最后<b>加上“#”的个数</b>，求和算出总长度。

<hr>

821 Shortest Distance to a Character

题意：给定字符串s和字符c，对于s[i]，求出s中离它最近的字符c的位置j，返回所有|i-j|。

难度：easy

解法：数据规模不支持直接<b>枚举搜索</b>。可以把c的位置记录下来，做<b>二分搜索</b>。

<hr>

822 Card Flipping Game

题意：有n张卡片，<b>正反面</b>都有<b>一个正数</b>，用fronts、backs表示。开始时，所有front面都朝上，你可以<b>翻转任意卡任意次</b>。如果一个整数存在于<b>朝下的面</b>，但不存在于<b>朝上的面</b>，则称为<b>好数</b>。请找出<b>最小的好数</b>。

难度：medium

解法：题目<b>有点难懂</b>。意思是随便翻，如果一个数能被<b>“藏起来”</b>，就是好数。那比如某个数x，我们<b>把所有x都朝下</b>，它就藏起来了。那加入一张牌<b>正反都是x</b>，就没法藏起来。既然这样，只要从fronts、backs里找出<b>最小值</b>，且这个值不存在<b>一张牌正反面都有</b>的情况，就是答案。这是个<b>脑筋急转弯</b>，不是算法题。

<hr>

823 Binary Trees With Factors

题意：给定一个数组arr，元素值不重复。用这些值构建<b>二叉树</b>，每个值可以用<b>任意次</b>。要求二叉树的<b>非叶节点</b>，必须是<b>子节点的乘积</b>。比如6=2x3、6=6这样。请计算用arr总共可组成多少不同的二叉树。结果模`1e9+7`返回。

难度：medium

解法：首先，数组规模不大，可以枚举找出这些<b>乘积关系</b>。对于z=x*y这种，左右可以交换；对于z=z这种，一个子节点可左可右。按这个方式，继续往下<b>递归搜索</b>即可。这个搜索是可以<b>记忆化</b>的，记录为“<b>以x值为根节点</b>的树，共有多少棵”。

<hr>

824 Goat Latin

题意：做一种奇怪的字符串变换，细节不讲。

难度：easy

解法：水题。

<hr>

825 Friends Of Appropriate Ages

题意：有n个人，年龄是ages[i]。对于两个人x和y，如果三个条件符合<b>任意一个</b>，则x<b>不会</b>给y发好友邀请。三个条件就不贴了。请统计，共有<b>多少好友邀请</b>发出。

难度：medium

解法：这个邀请关系是单向的，<b>不对称</b>。n的规模不支持<b>直接O(n^2)枚举</b>。那么，得想办法优化。把条件反过来，相当于三条件<b>取反，全满足</b>才发出邀请。那么就是`x>=100||y<=100`、`x>=y`、`0.5x+7<y`。所以，这好像成了个<b>线性规划</b>，围一个区域之类的？其实不必想那么复杂，把ages排序，因为`0.5x+7<y<=x`，这个可以<b>二分搜索</b>。再配合`x>=100||y<=100`筛选一下结果，这样单次的代价可以做到O(logn)，总代价为O(nlogn)。挺有价值的一题，<b>数据分析</b>就是这样，<b>很具体</b>。你换个条件，可能难度就登天，也可能难度降为0。

<hr>

826 Most Profit Assigning Work

题意：你有n个任务、m个工人。difficulty[i]是任务难度，worker[j]是工人能力。分配任务，必须<b>难度不超过能力</b>。profit[i]是任务利润。每个工人<b>至多分配一个任务</b>，但一个任务可以被<b>完成多次</b>。请求出能得到的<b>最大利润</b>。

难度：medium

解法：第一念头是，<b>贪心</b>是否管用？让每个工人，都找自己<b>能力范围</b>内的<b>最大利润</b>。那这个其实是一个二维数组`(d,p)`，第一维<b>难度</b>，第二维<b>利润</b>。首先，对这个数组<b>排序</b>，对于能力为a的工人，在数组里二分搜索a，找到<=a的边界，边界往左的任务都可以做。其中的利润最大值，用前缀max可以得到。这样，分配每个工人的代价是O(logn)，<b>总代价O(mlogn)</b>。还有一种做法，就是<b>把worker也排序</b>，然后用O(n)代价扫一次，其实思路大同小异。

<hr>

830 Positions of Large Groups

题意：给定字符串s，请找出其中所有连续<b>至少3个字符</b>的情况，按<b>起始位置`[x,y]`</b>形式返回所有区间。

难度：easy

解法：水题。

<hr>

831 Masking Personal Information

题意：给定各种格式的邮箱、电话号码，请对其做<b>加*屏蔽</b>处理。

难度：medium

解法：<b>非常非常非常细节</b>的字符串处理题，边界case<b>考验你的耐心</b>。说实话，我并不觉得用<b>一行很难懂的正则</b>完成这类问题，是一个好工程师应该做的。那样其实<b>很不工程</b>，因为不可维护，而且正则串的效率需要仔细考虑。

<hr>

832 Flipping an Image

题意：给定一个n x n图像，值都是0或1。将其<b>水平翻转</b>，并对每个值<b>取反</b>。

难度：easy

解法：按题意实现即可。

<hr>

833 Find And Replace in String

题意：给定字符串s，你需要做k次<b>替换操作</b>。给定<b>indices、sources、targets</b>，表示替换起始位置、替换前的串、替换后的串。注意，<b>是串</b>，不是单个字符。第i次替换的所有信息都在三数组的<b>i元素</b>中。如果sources[i]在s的对应位置<b>没有出现</b>，则<b>不执行替换</b>。最重要的一点，所有替换的位置<b>互不重叠</b>，且<b>同时发生</b>。请返回替换后的结果s'。

难度：medium

解法：既然<b>不重叠</b>，那我只需要<b>扫一次</b>。确保indices里的位置是升序的就行了。这样，每当我到达一个<b>起点位置</b>，就做匹配。匹配<b>如果成功，就替换</b>。整个过程都是<b>一次性</b>，没有重复访问。这题本身不难，把<b>问题描述一遍</b>比解题还难。

<hr>

834 Sum of Distances in Tree

题意：给定一棵用<b>无向图</b>表示的<b>树</b>，对于<b>每个节点</b>，请求出其他所有节点到它的<b>距离之和</b>。

难度：hard

解法：这题真的非常简洁、清晰，但<b>就是很难</b>。而且是那种你知道它<b>难</b>，也知道它<b>巧妙</b>，于是你想很久，就是想不出那个<b>巧妙的办法</b>。我花了2h+想各种办法，最后写了个比较丑的<b>双层递归</b>思路。细节很难讲清，大致思路就是，对于当前点x，我的下一层递归y，一定要<b>尽可能复用x的结果</b>。但我应该<b>前序复用还是后序复用</b>？这就是最大的难点，好像有种前后<b>互相依赖</b>的感觉，<b>谁复用谁</b>？现在保存的这版代码，是我看了讨论区代码后，做了一些简化的。和网友思路几乎一样，但我的比别人的代码<b>难看、冗长</b>。那几行关键代码，我确实想不出语言讲清楚。我还是<b>没彻底想明白</b>。

<hr>

835 Image Overlap

题意：给定两个n x n的01图像img1和img2。如果允许你<b>随意平移</b>，使得两图像出现<b>重叠区域</b>。请统计重叠区域中，两图像<b>均为1的位置</b>，<b>最多</b>有多少个？

难度：medium

解法：其实<b>平移、重叠</b>这些，都是<b>迷惑</b>用词。你可以这么想，从img1、img2中的<b>边缘</b>，任取两个<b>形状大小相同的矩形</b>。这就可以通过平移做到，这是<b>等价</b>的。那我们只管取两个矩形的问题。接下来，用<b>暴力枚举</b>的方式就行了。枚举时，唯一注意的，就是两个矩形都需要在img1、img2的边缘，<b>不能包在内部</b>。总代价是`O(n^2*n^2)=O(n^4)`。按给定的数据量，确实能过。但还<b>有没有更好的思路</b>？

<hr>

836 Rectangle Overlap

题意：给定两个矩形的<b>左上、右下</b>坐标。矩形和xy轴对齐，请判断是否<b>重叠</b>。

难度：easy

解法：水题。<b>max(左上)，min(右下)</b>，算面积。

<hr>

837 New 21 Game

题意：类似21点纸牌游戏。你从0分开始，每次抽牌，随机等概率获得[1,mx]中的一张，并得到对应分数。如果<b>总分不小于k</b>，则停止。请求出最终<b>总分不超过n</b>的概率。

难度：medium

解法：是个概率论题，怎么搞呢？记忆化搜索吧。记录`search(i,j)`为第i次总分为j的概率。其实没必要，因为这是个<b>Markov chain</b>。这个链的<b>窗口大小</b>，就是mx。这样，问题就变成了<b>线性DP</b>。显然，我当年并没想出来，写了个O(n^2)解法，超时了。

<hr>

838 Push Dominoes

题意：<b>多米诺骨牌</b>。有n个骨牌开始排列一行，同时选择其中<b>一些牌</b>，按<b>左或右</b>的方式推倒。每1秒，倒下的骨牌将旁边的骨牌撞到，形成<b>连锁反应</b>。如果两边同时有骨牌倒下，则中间的骨牌保持平衡，不动。如果出现`...RL...`的情况，则两个已倒下骨牌<b>保持倾斜</b>。

难度：medium

解法：首先，解法肯定是<b>O(n)</b>的。怎么让模拟<b>尽量高效</b>？可以把初始的L、R位置，我们称为<b>L种子、R种子</b>记录下来，进行<b>配对</b>。比如<b>R左L右</b>，这样就会向<b>中间靠拢</b>。因此，我们总是找这样的配对。对于<b>不配对</b>的情况，比如<b>最左的L、最右的R</b>，那这些就会<b>传播到边界</b>，或者到<b>一个已倒下的位置为止</b>。这样的话，整个模拟过程是<b>严格O(n)</b>，没有重复计算的。

<hr>

840 Magic Squares In Grid

题意：<b>3阶幻方</b>，是一个3 x 3矩阵，每行、每列、正反对角线的和都相等。给定一个n x m矩阵，请判断其中有多少个3阶幻方。

难度：medium

解法：直接数。

<hr>

841 Keys and Rooms

题意：有n个房间，编号`0~n-1`。开始只有房间0开放，你可以访问房间并得到一些钥匙，钥匙可用于<b>解锁其他房间</b>。请判断是否可以<b>访问所有房间</b>。

难度：medium

解法：其实就是<b>可达性、连通性</b>的问题，而且是<b>双向</b>的。因此，<b>无向连通图，用并查集</b>。不过我以前的代码是BFS解决的。无所谓，<b>怎么都行</b>。

<hr>

842 Split Array into Fibonacci Sequence

题意：给定一个字符串num，由<b>数字</b>组成。允许你对其做<b>划分</b>，得到一个<b>数组f</b>，并把每个元素转为<b>整数</b>。要求划分的子串不能有<b>多余的前置0</b>，且必须满足f[i]=f[i-1]+f[i-2]，就像Fibonacci数列那样。

难度：medium

解法：数据规模不大，而且Fibonacci序列的要求还是<b>很严格</b>的，因此能搜到的<b>结果不会很多</b>。这给<b>暴力搜索</b>提供了可能。在搜索的基础上，加一点<b>剪枝策略</b>就行了。

<hr>

843 Guess the Word

题意：猜词游戏。有一个候选词表words，所有词都是<b>6字母</b>。其中一个词是<b>关键词</b>。你有一个工具类Master，提供guess()函数给你猜。但会有一个最大次数，超过了则失败。guess()函数会告诉你，输入词是否在词表中，是否命中，或者有几个字母是<b>位置和值均正确</b>。请设计策略，用<b>尽可能少的guess()调用</b>，找到这个关键词。

难度：hard

解法：题目看得云里雾里，大概明白了。对每次猜词，你能知道<b>对了几个</b>。其实这题你想得天马星空的话，就掉坑里了，尽量<b>往简单想</b>。比如关键词是<b>w0</b>，具体哪个，<b>我当然不知道</b>。我随便猜个词w，得到的计数是cc，且cc<6。那我把词表里所有<b>和w匹配数为cc的词</b>，都留下来。则<b>w0一定被留下来了。</b>照这样，继续猜就行了。<b>是不是很无聊？</b>智力题。

<hr>

844 Backspace String Compare

题意：给定一个字符串，其中的<b>“#”</b>代表<b>退格键</b>，删去一个字符。现在给定这样的串s和t，请判断两者输出内容是否相同。

难度：easy

解法：水题。

<hr>

845 Longest Mountain in Array

题意：一个数组，如果长度至少3，且存在位置i，使得i左边<b>严格递增</b>，右边<b>严格递减</b>。则称为<b>“山数组”</b>。现在给定数组nums，请求出子数组中<b>最长的山数组</b>。返回长度。

难度：medium

解法：用<b>前后缀</b>，统计<b>递增、递减</b>的思路，不难找出<b>O(n)</b>的解法。都<b>需要O(n)空间</b>来做记录。题目还给了一个挑战，能否在<b>O(1)空间，遍历数组一次</b>的情况下搞定？这个我确实<b>没想出来</b>。现在想想，好像也可以。用一变量up作为bool标记变量，表示目前检查的阶段（或者用一个变量，同理）。在不同阶段执行不同的判断逻辑。`up=True`时，判断<b>升</b>；`up=False`时，判断<b>降</b>。到了<b>降结束、又开始升</b>（或者数组末尾）时，更新<b>当前最大长度</b>。这个符合<b>O(1)空间+一遍过</b>的要求。

<hr>

846 Hand of Straights

题意：扑克牌，有<b>顺子</b>。给定一手牌hand，和一个大小gs。请问能否将手里的牌分成<b>gs个顺子</b>，每个顺子<b>长度也是gs</b>。

难度：medium

解法：首先长度必须是gs^2。<b>顺子</b>意思就是<b>+1的等差数列</b>。英文叫“straight hand”。这题和<b>659题</b>非常像，因此可以用同一思路。对牌进行计数，用SortedDict保存。从<b>最小key</b>开始找顺子。因为这次顺子的<b>长度是固定的</b>，你甚至不需要<b>判断顺子的边界</b>。所以，以同样的方法，<b>这题比659更简单</b>。

<hr>

847 Shortest Path Visiting All Nodes

题意：给定一个无向图，你可以<b>重复访问节点和边</b>。请求出<b>遍历所有节点</b>的<b>最短路径</b>的长度。

难度：hard

解法：Hamilton路径，对吧？很容易第一念头就想到这个。<b>但是，不对。</b>Hamilton路径是对所有节点<b>恰好访问一次</b>，这个对于单连通图，<b>并非总是存在</b>。即使去找，思路也并不对，而且<b>找起来也很难</b>。我又想了用<b>Floyd算法</b>求全最短路，然后动脑子尝试，试了半天<b>也不对</b>。最后实在没办法，看讨论区。结果是<b>DP+位压缩</b>。n最大是12，这给编码整个图的状态，提供了可能。然后用<b>DP的思想</b>，结合<b>图里的边</b>，找<b>状态转移关系</b>。沿着这个思路，写出来了。当然，这不能算是<b>独立完成</b>了。所以，这是一道图论+DP+位压缩的题，<b>有点离谱</b>。甚至还<b>伪装Hamilton路径</b>来迷惑你。

<hr>

848 Shifting Letters

题意：给定字符串s和数组shifts。s由a-z组成，shifts[i]表示把s[0:i+1]按字母<b>全部循环右移shifts[i]位</b>。注意，<b>z右移变成a</b>。经过所有移位操作后，请返回最终结果。

难度：medium

解法：既然shifts是<b>前缀移位</b>，那就求一个<b>后缀和</b>就行了。比如`shifts=[3,5,8]`，则求和之后变为`sum=[16,13,8]`。对s按照sum的值进行移位即可。

<hr>

849 Maximize Distance to Closest Person

题意：给定一个数组seats，0表示空位，1表示有人。已知seats不会<b>全满或者全空</b>。现在你想要找一个空位坐下，希望和<b>离你最近的人距离最大</b>。请求出这个最大距离。

难度：medium

解法：其实很简单。考虑每一段<b>连续的0</b>有多少个。比如有k个，则我总是尽量<b>坐在这k个0的中间</b>。显然，找出最大的k，然后<b>取中间</b>即可。但有个<b>特殊情况</b>，如果是`00..001`这样，那么我应该坐在<b>最左边</b>。右边情况同理。

<hr>

851 Loud and Rich

题意：n个人，编号1-n。给定一个richer数组，每个元素`[x,y]`表示x比y有钱。还有一个quiet数组，表示每个人的<b>安静值</b>。

难度：medium

解法：loud and rich，这是什么标题...总之就是两步，第一步<b>拓扑排序</b>，第二步对<b>拓扑+quiet</b>值进行一个<b>二维数组排序</b>。然后可以通过<b>后缀min</b>的方式，找出对于<b>每个x</b>，所有<b>比x有钱</b>的人中，最吵闹，也就是`min(quiet)`的那个y。不得不说，这个数学问题其实不算复杂，但这个什么richer、quiet<b>真的很绕嘴</b>。看了下我当年的代码，思路类似，但第二步我用了更笨的办法。所幸数据量比较小，<b>O(n^2)也能过的</b>。

<hr>

852 Peak Index in a Mountain Array

题意：给定一个<b>山数组</b>，定义参考845题。请找出峰值，要求O(logn)时间完成。

难度：medium

解法：这个不难，因为<b>先升、后降</b>，且题目保证了这个数组一定有峰值，那就检测nums[mm]和相邻元素比较，是<b>><、<>还是>></b>。><在左，<>在右，>>就是峰值位置。

<hr>

853 Car Fleet

题意：在一条直线上，有n辆车。出发位置不同，速度不同，都朝target位置前进。位置和时速用position和speed数组表示。如果<b>快车追上了慢车</b>，将会和慢车以同速度一起前进，组成<b>一个车队</b>。请计算在到达target时，总共有<b>多少个不同车队</b>。

难度：medium

解法：比如出发位置x，速度为v，则这辆车到达target的时间原本应该是`(target-x)/v`。怎么处理<b>追车合并</b>的情况呢？考虑<b>到达时间</b>，已经<b>很接近正确思路</b>，但还不够。应该考虑`(剩余距离,速度)`这个二维关系，按<b>升序排列</b>。这样才能处理<b>从后往前追</b>的情况。如果你只考虑到达时间，可能某个<b>速度快</b>的车，<b>距离也短</b>，那样是<b>追不上</b>的。排好序后，按照`min_d/min_v`和`d/v`比较，来确定是否可以追上。如果<b>追不上</b>，就更新min值，且车队+1。min代表的是<b>后面</b>出现了<b>更快的车</b>。

<hr>

855 Exam Room

题意：给定一个教室，里面只有一横排n个座位。每次学生进入，需要选一个座位坐下，使得自己<b>离最近的人最远</b>。如果教室无人，则在0位置坐下。请设计一个数据结构，支持相应的<b>seat()、leave()</b>功能。

难度：medium

解法：leave()功能是明确的，O(1)代价。对于坐下，这个功能其实和<b>849题</b>完全一样，不重复了。

<hr>

856 Score of Parentheses

题意：给定一个括号序列s，请计算它的<b>分数</b>。分数规则有三条：()记1分；AB两个序列连接，则分数相加；(A)记2*A的分数。

难度：medium

解法：按照规则处理即可。不过，要区分<b>A+B和(A)</b>这两种情况，因此，还是需要<b>O(n^2)时间</b>的。比如`()(())`，如果直接拿掉左右的“(”和“)”，中间的一段<b>并不是有效序列</b>。

<hr>

857 Minimum Cost to Hire K Workers

题意：有n个工人，期望最低工资是wage[i]，工作品质是quality[i]。如果你需要雇佣k个工人，则付的薪水需要按照他们的<b>quality比例分配</b>，且必须满足每个人的工资期望。给定k，请求出组成一个<b>k工人团队</b>的<b>最低总薪资</b>。

难度：hard

解法：按quality[i]比例，但是要不小于wage[i]，那么至少有一个人是恰好拿到wage[i]的。这个人应该是<b>quality/wage的值</b>最低的。其他所有人的薪资，都会`>=wage`。比如我选定了起始点`(q1,w1)`，则后面选择的点(qi,wi)，所得薪资都和wi无关了，而是等于`w1/q1*qi`。因此，总薪资就是`w1/q1*sum(qi)`。所以，这个选择问题其实<b>主要都在quality上</b>，只有<b>一个wage值</b>参与计算。那么<b>思路有了</b>。首先，按照<b>(quality/wage,wage)</b>二维值升序排列。我<b>从后往前</b>枚举。并用一个<b>最小堆</b>，在其中保存<b>k-1个当前最小</b>的quality值。为什么是k-1个？因为我开头选的这个<b>最低性价比</b>的元素，已经<b>占了一个名额</b>。用最小堆是方便每次以O(logk)的代价更新统计，这样我<b>枚举的总代价是O(nlogk)</b>，符合要求。<b>总结一下</b>，关键思路是先按`(性价比,期望工资)`升序，然后枚举每个a[i]作为开头，如何<b>从i+1之后</b>，再选出<b>k-1个quality最低</b>的元素。看了下代码，当年我没想出来，但这次<b>独立想出来了</b>。而且和代码一模一样。<b>有进步。</b>

<hr>

858 Mirror Reflection

题意：给定一个正方形，左下在(0,0)，右上在(p,p)。其他三个角都有<b>接收器</b>。从左下发出一束光，照到(p,q)点并<b>继续反射</b>。请根据反射规律，计算这束光线总共被<b>几个接收器</b>探测到？

难度：medium

解法：几何题，需要一点<b>空间思维</b>。首先，比如我们说p是个<b>有理数</b>，q是<b>无理数</b>，那两者不可能形成有理分数的关系。这种肯定就<b>碰不上了</b>，对吧？题目保证了<b>可以碰上</b>，我们就不考虑这个了。那这个反射关系是怎么样的？不要<b>真的去考虑反射</b>，你想象这束光线穿过了板子，<b>继续直线向前</b>就行了。但是，注意，<b>只能穿过竖板子</b>。对于<b>横板子</b>，要把它<b>反射回去</b>。（其实你横板子也按穿过处理，也行。）用这种思维，计算光线有没有到达y=p、y=0的情况。如果到达了，那就可能被探测了。但还没完，y=p时，也要分<b>x=kp，其中k是奇偶的情况</b>。想想为什么？y=0同理，也要分奇偶。<b>有点难想</b>的一题。

<hr>

859 Buddy Strings

题意：给定字符串s和goal，请判断是否可以交换s的两个字符，变成goal。

难度：easy

解法：水题。

<hr>

860 Lemonade Change

题意：在一个果汁摊子，卖柠檬汁，5元一杯。有n个客人，依次给你一些现金付钱，你需要按给的金额找零钱。<b>开始时你没有现金</b>，请判断能否<b>依次</b>给n位客人正确的零钱。

难度：easy

解法：只需要判断当前现金是否<b>>=当前客人需要的零钱</b>。

<hr>

861 Score After Flipping Matrix

题意：给定一个m x n的01矩阵。每次你可以选<b>一行或一列</b>，把所有值反转。在任意次操作之后，把每行当成一个<b>二进制数</b>，并给这些数求和。请求出能得到的<b>最大和</b>。

难度：medium

解法：如果题目要求的是<b>最多有多少个1</b>，那问题就更难了。但这题求的是，每行作为<b>二进制数的求和</b>，这就可以用<b>贪心策略</b>了。一个数，我们肯定是希望<b>越高的位，越大</b>。因此，让<b>第1列全变成1</b>，是肯定的。要<b>固定某列</b>，你需要做<b>行反转</b>。这代表你<b>不能再用行反转</b>，因为固定了。剩下n-1列，你只能用列反转。什么时候反转？当这列的<b>0个数>1个数</b>时，反一下。关键思路就这么多。这题有一定难度，难在想明白<b>第1列全为1</b>。

<hr>

863 All Nodes Distance K in Binary Tree

题意：给定二叉树，和一个target值，一个距离k。请返回所有和target对应节点，<b>距离为k</b>的节点的值。距离指将树看成<b>无向图</b>，两节点的距离。

难度：medium

解法：这种题也遇到过几次，对于一个<b>单向结构</b>，却让你<b>干双向的事情</b>。你可以在递归时处理一下，<b>上、下、上下拐弯</b>之类的不同情况。不过这样比较费脑子，想不清楚的话容易出bug。一种很直观的办法，是直接遍历节点，并记录每个节点的<b>路径</b>。类似00101、1011这样，0左1右。这样的两个<b>路径字符串</b>，计算距离很容易，不细说了。这样的话，时空代价都是O(n^2)。如果按中序遍历，可以<b>提前结束遍历</b>，但最坏情况的复杂度还是一样。

<hr>

865 Smallest Subtree with all the Deepest Nodes

题意：给定一个二叉树，请找出一个所有<b>深度最大的叶节点</b>的<b>最近公共祖先</b>。

难度：medium

解法：原题目不是这么说的，但是意思完全等价。比如我遍历过程中，记录节点x为根节点的<b>最大深度d[x]</b>。全局最大深度为md。那么再递归一次，对于当前根节点x，如果`d[x.left]==md`且`d[x.right]==md`，这就是答案。如果只有一边满足，就往满足的方向走。比如<b>`d[x.left]==md`</b>，我就<b>往左</b>。递归是<b>自顶向下</b>，因此不可能错过答案。这题其实<b>方法不止一种</b>，但思路都差不多。

<hr>

866 Prime Palindrome

题意：给定整数n，请返回不小于n而且是<b>质数</b>的<b>最小回文数</b>。

难度：medium

解法：对于n，质数的规模大致是`O(n/logn)`，回文数的规模则是`O(sqrt(n))`。这两个加起来，对于`1e8`范围，可枚举的结果应该不会很多。那么直接<b>枚举回文数</b>，然后<b>判断质数</b>好了。奇怪，这题思路很简单，我之前的代码怎么写得这么难看？应该很简短啊。

<hr>

867 Transpose Matrix

题意：给定矩阵，做<b>转置</b>。

难度：easy

解法：就是线性代数的定义，<b>行变列、列变行</b>。

<hr>

868 Binary Gap

题意：给定整数n，请返回n的二进制中，<b>相邻1</b>之间的最大距离，也就是<b>中间0的个数加1</b>。

难度：easy

解法：水题。

<hr>

869 Reordered Power of 2

题意：给定一个正整数，允许你<b>任意排列数位</b>，但最高位不能为0。请判断能否变成<b>2的幂</b>。

难度：medium

解法：<b>2的幂</b>在给定范围内只有<b>不到30个</b>，判断每个幂是否和n有相同数位即可。也就是<b>anagram</b>。

<hr>

870 Advantage Shuffle

题意：给定同长度数组nums1和nums2，如果给定位置i，`nums1[i]>nums2[i]`，则称为<b>1个优势</b>。允许对nums1任意排序，请求出能得到的<b>最大总优势</b>。

难度：medium

解法：这就是著名的<b>田忌赛马</b>了。要获得最大优势，你总是尽可能把nums1的元素分配给nums2中<b>恰好小于它</b>的，这样<b>最“经济”</b>。对nums1、nums2都<b>排序</b>。双指针`i=0,j=0`。按<b>贪心策略</b>。每当`nums1[i]>nums2[j]`时，则ij前进；否则只有i前进。这样最后<b>j的值</b>就是答案。

<hr>

872 Leaf-Similar Trees

题意：给定二叉树，所有叶节点从左到右，构成一个<b>叶序列</b>。请判断两棵树的叶序列是否相同。

难度：easy

解法：任意方式遍历，得到叶序列，比较即可。

<hr>

873 Length of Longest Fibonacci Subsequence

题意：给定一个严格递增的数组nums，请找出其中的最长Fibonacci序列。

难度：medium

解法：也就是满足`f[i]=f[i-1]+f[i-2]`这样的规律的序列。在严格递增的情况下，这题更容易了。对于任意nums[i]、nums[j]作为起点，后面的元素值<b>都是确定的</b>，只需要判断<b>是否存在，存在几个</b>。不过，枚举的方式需要注意效率。比如按照枚举i、j，然后<b>往后找</b>，找到一个子序列的代价为O(n)，这样会导致`O(n^2*n)=O(n^3)`的总代价，太慢了。但是可以<b>优化</b>，在找到一个长度k的Fibonacci序列时，其实你已经处理了k-1个相邻数对。这k-1个数对，都不用重复搜了。只要用哈希记录一下数对，<b>判重</b>即可。比如这个序列`[1,2,3,5,8]`，对应下标是`[0,1,2,4,7]`，则`(0,1),(1,2),(2,4),(4,7)`这四个对的答案都确定了。这样，枚举`O(n^2)`的总代价降回了`O(n^2)`。我以前的代码是<b>DP解法</b>，不过关键思路差不多。

<hr>

874 Walking Robot Simulation

题意：在二维平面，(0,0)处有个机器人，朝+y方向。有三种命令：-2左转90度、-1右转90度、k前进k距离，但需要1格1格地走。如果给定一些障碍物的位置(xi，yi)。当机器人前进遇到障碍物时，则会<b>停在障碍物前</b>，放弃本条前进命令，<b>继续执行下一条</b>。请求出机器人到达的<b>最远位置</b>，按`x^2+y^2`计算。

难度：medium

解法：没什么算法，定义非常具体的<b>模拟题</b>。按题意实现即可。

<hr>

875 Koko Eating Bananas

题意：有n堆香蕉，每堆若干个。你有h小时可以吃掉所有香蕉，但每小时你只能选某1堆，且至多吃k个。请问k至少多大，才能保证吃完所有香蕉？

难度：medium

解法：很明显，这个k是有<b>单调性</b>的。因此，<b>二分搜索</b>。

<hr>

876 Middle of the Linked List

题意：给定单链表，返回<b>中间的节点</b>。如果总数是偶数个，则返回中间两个的后者。

难度：easy

解法：<b>快慢指针</b>，一个一步，一个两步。

<hr>

877 Stone Game

题意：拿石头。这次有n堆石头，n为偶数，且石头总和为奇数。每次可以从<b>最左或者最右</b>拿<b>1堆石头</b>。Alice先手，最后总石头数多的人胜利。请问Alice是否必胜？

难度：medium

解法：属于博弈论题里，<b>相对简单</b>的一题。因为能一眼看出<b>DP思路</b>，以及<b>子问题</b>的划分。对于nums[i:j+1]，则定义dp[i][j]为先手可拿到的最大石头数。则`dp[i][j]=max(nums[i]+sum(nums[i+1:j+1])-dp[i+1][j], nums[j]+sum(nums[i:j])-dp[i][j-1])`，也就是从左拿，或者从右拿。你拿了，<b>就轮到对手了</b>，因此要<b>用sum减一下</b>。最终判断`dp[0][n-1]`是否超过一半即可。对了，还有个更扯的解法，<b>`return True`就行了</b>。想想为什么？

<hr>

880 Decoded String at Index

题意：给定一个编码字符串s，请进行解码。解码规则有两条：对于字母c，直接输出c；对于数字d(2-9)，将目前<b>已输出字符</b>复制d遍（包括已有的1遍）。请求出解码序列中的第k个字符（从1开始）。

难度：medium

解法：这个信息量，当然在于`循环节+循环次数`。那么只要循环节没有特别特别长，我们是可以记一下的。再记录一下循环次数，求出第k个字符也就很容易了。我们用`rep="",cc=1`表示初始状态。每次遇到数字d，则`cc*=d`；遇到字符c，则`rep=rep*cc+c,cc=1`。只要<b>rep的长度还没爆炸</b>，问题就不大。不过，看样子rep长度<b>确实会爆</b>。那就得<b>用k作为起点</b>，逐渐<b>做除法、做模</b>的思路来处理了。

<hr>

881 Boats to Save People

题意：有n个人要过河，每人体重为people[i]。现在给定<b>充足的船</b>，每条船最大承重为limit，每只船最多坐2人。请求出n人过河至少要几条船？

难度：medium

解法：如果没有<b>1船2人</b>的限制，这题就是一个集装箱问题。有这个限制，问题就简单了。可以对数组排序。然后按照小大、小大这样的<b>两两匹配</b>。双指针`i=0,j=n-1`，j不断后退，i不断前进。只要`people[i]+people[j]<=limit`，就可以配一对。优先检查j，这样在最后可能会剩下一些较大的people[j]无法配对，这些都按<b>1船1人</b>处理。排序代价O(nlogn)，检查代价O(n)，总代价O(nlogn)。

<hr>

883 Projection Area of 3D Shapes

题意：给定一个3维地形，grid[x][y]表示对应位置的高度，也就是z值。请按照xy、yz、xz三方向，计算总的投影面积。

难度：easy

解法：难度是easy，问题本身也不算复杂。不过需要一些<b>基本的几何思维</b>。xy不用说，对于<b>xz和yz</b>，要想清楚这个投影是怎么算的。比如xz，对于同一xi，z值的取值应该是所有yj位置的<b>最大值`max(grid[xi][yj])`</b>。

<hr>

884 Uncommon Words from Two Sentences

题意：给定两个句子，求出所有<b>只在一个句子出现</b>的单词。

难度：easy

解法：给定集合S1和S2，结果就是`(S1-S2)U(S2-S1)`。

<hr>

885 Spiral Matrix III

题意：54的变体。我不知道怎么描述这个题目，也不想写。

难度：medium

解法：很无聊的一题，唯一难点是<b>把题意讲明白</b>。意思就是，从某个点出发，<b>顺时针</b>螺旋遍历一个矩阵。如果你走出边界，就在<b>边界+1的位置</b>转弯，前进到第一个未遍历过的位置，再转进矩阵内部。如此转圈，直到完成所有元素的遍历。<b>你看得懂我在说什么吗？我自己都看不懂。</b>

<hr>

886 Possible Bipartition

题意：有n个人，互相可能存在一些<b>不合</b>的关系。能否将所有人分为两组，使得任何<b>两个不合的人</b>，都不在同一组中。

难度：medium

解法：这和<b>785题</b>完全一样。分为两组，这就是标准的<b>二部图</b>。那么，给定的dislikes也就是<b>边集</b>。按照这个边集，判断这个图是不是二部图即可。

<hr>

888 Fair Candy Swap

题意：Alice和Bob各有几盒糖，个数不一。已知选取两人各一盒糖果交换，可以使两边总和相等。请求出这<b>两盒的对应个数</b>。

难度：easy

解法：分别对两边求和，算出`d=sum2-sum1`差值。那么对于aliceSizes中的每个元素x，都在bobSizes中找`x+d/2`是否存在。因为题目保证了答案存在，我们也不用处理边界case了。

<hr>

889 Construct Binary Tree from Preorder and Postorder Traversal

题意：给定<b>前序和后序</b>遍历，请重建一棵二叉树。<b>答案并不唯一</b>，可以返回任意一个符合条件的。

难度：medium

解法：<b>前+中</b>或者<b>中+后</b>都是准确的，唯独<b>前+后</b>不行。因为前+后这种组合，对于<b>度为1</b>的中间节点，是无法<b>区分左右</b>的。除了这个之外，其他的重建方式和之前一样，参考<b>105题</b>。对于度为1的节点，你可以<b>随意选择左右</b>。

<hr>

890 Find and Replace Pattern

题意：给定一个词表words和一个模式p。请判断words中<b>和p同构</b>的词。同构指的是长度相同，且存在`字符<->字符`的<b>一一对应关系</b>。

难度：medium

解法：很显然，对于xyy、abb，你都可以按照字符出现的<b>先后顺序</b>，给它们<b>依次映射</b>成a、b、c等等。这样，对所有串都处理一下，同构的字符串就会变成<b>相同字符串</b>。

<hr>

892 Surface Area of 3D Shapes

题意：给定一个n x n的三维地形。每个格子是1 x 1，且高度为grid[x][y]，由对应个1 x 1 x 1的小方块堆成。请求出这所有形状的<b>总共表面积</b>，包括底面。

难度：easy

解法：这竟然是easy？几何题，这也算有一点难度了。这题需要想想，表面积应该<b>怎么算</b>？一种思路是，<b>顶面、底面</b>简单，按<b>xy面的投影</b>考虑即可。<b>侧面</b>，需要动脑子。比如对于1个方块，有四个侧面，我关心它的侧面有没有<b>被旁边的方块遮住</b>。因此，用`grid[i][j]>grid[i+di][j+dj]`来判断这个面是否<b>露出来了</b>。实际上，露出来的侧面总共有`sum(abs(grid[i][j]-grid[i+di][j+dj]))`，细节不讲了，不难理解。这显然<b>应该是medium</b>。

<hr>

893 Groups of Special-Equivalent Strings

题意：给定两个串s和t，如果只允许你交换<b>两个偶数</b>或<b>两个奇数</b>位置的字符。如果通过任意次交换，能使s==t，则称s和t是<b>特别等价</b>。现在给定一个词表words，请将其划分为几个<b>最大特别等价集</b>。注意，每个集合都是<b>最大集</b>，无法再扩充。请求出集合的个数。

难度：medium

解法：其实也好办，比如一些字符串<b>特别等价</b>，对吧？那总有一个是<b>字典序最小</b>，对吧？怎么才能最小呢？把<b>奇数串</b>排序，<b>偶数串</b>排序，再<b>穿插</b>一下就行了。比如`wfgeaxs`，对应的字典序最小就是`aegfsxw`。如此，把words所有元素，按这个<b>最小等价串</b>作为key，进行<b>分组</b>就行了。

<hr>

894 All Possible Full Binary Trees

题意：给定整数n，请返回所有不同的n节点<b>正则二叉树</b>，所有节点值都为0。正则二叉树指的是，所有点的度都是0或2。

难度：medium

解法：正则二叉树，这个名称很不常用。但它确实叫这个，<b>regular</b>。至于生成不同二叉树，这个不难，直接按<b>节点数</b>进行<b>记忆化搜索</b>，然后<b>拼装结果</b>就行。拼装时，注意判断<b>度不能为1</b>。一定要记忆化，否则<b>搜索很快就炸了</b>。

<hr>

895 Maximum Frequency Stack

题意：设计一个特别的栈，可以push元素入栈，也可以pop当前频率最大的一个元素。如果存在多个频率最大，则pop<b>更接近栈顶</b>的。

难度：hard

解法：其实你可以把题目里的要求<b>一一做到</b>，比如用`SortedDict[int,SortedSet[(int,int)]]`之类的奇奇怪怪的形式。关键在于保持<b>合理复杂度</b>的情况下，尽量100%满足它的要求。频率最大，我就用频率作为key，用SortedDict方便得到最大频率。要接近栈顶，那么我保持一个<b>真的栈st</b>，push的时候确实push到栈顶。但是，<b>重点来了</b>，因为pop的并不一定是栈顶，如果我pop中间元素，会造成<b>单次操作O(n)时间</b>，效率崩掉。那怎么办？我可以对频率统计，保持实时准确，但对于这个栈，我做<b>延迟删除</b>。比如某个元素x，<b>频率已经降到5了</b>，但我的栈里，还有<b>10个x</b>。当我发现当前栈顶是x，如果<b>st里x的个数>x的真实频率</b>，则当前x值<b>应该扔掉</b>，相当于<b>垃圾回收</b>。看了下当年代码，应该是没搞出来。当年存的这份代码<b>没有用有序结构</b>，超级简洁。果然还是<b>比不上网友</b>。总之这题我能搞定，但<b>搞得不好</b>。

<hr>

896 Monotonic Array

题意：给定数组nums，如果<b>单调递增</b>或者<b>单调递减</b>，则称为<b>单调</b>。请判断是否单调。

难度：easy

解法：水题。

<hr>

897 Increasing Order Search Tree

题意：给定二叉搜索树，请重排节点，使得每个点的<b>中序后继结点</b>成了<b>右节点</b>。

难度：easy

解法：题目没说<b>中序遍历</b>，但看例子一目了然。

<hr>

898 Bitwise ORs of Subarrays

题意：给定数组nums，请求出所有子数组的<b>按位或</b>里，有多少个<b>不同值</b>。

难度：medium

解法：实在想不出好思路，还是<b>暴力解法</b>吧。每次添加一个元素x，针对已有的子数组值的集合st，计算`st1={x | y for y in st}`，就这样迭代。如果数据比较好，则st1会和st几乎重合，也就是说<b>重复结果占了大多数</b>。这样<b>计算时间</b>就不会爆炸。事实证明也确实如此，这题的<b>测试集比较弱</b>。有什么好思路吗？

<hr>

899 Orderly Queue

题意：给定一个字符串s，你可以从前k个字符中，选出1个移动到末尾。如果这个操作可以执行任意次，请问能得到的<b>最小字符串</b>是什么？

难度：hard

解法：标题叫“queue”，但好像也不一定要用队列。首先，我们总是可以做循环移位。我们只拿第一位，拿任意次，这就相当于<b>循环移位</b>了。为了<b>让结果更小</b>，我们看看<b>前k位</b>的选取，能不能起到一个<b>排序交换</b>的作用？比如`cbada`，排序后是`aabcd`。如果k=3，我能变出`aabcd`吗？`cbada->cbdaa->cdaab->aabcd`。其中循环移位我直接算作一步，<b>交换</b>则是<b>一步步来</b>。每次在前k位中<b>出现逆序对</b>，我都把<b>较小值</b>换到末尾，因为循环移位后，它就到了最前面。那么，比如k>1，如果我<b>找不到逆序对</b>，也就<b>没什么可换</b>了。这时，代表任何相邻元素都是有序的，则<b>整个串也有序</b>了。因此，对于任何k>1，答案就是sorted(s)。对于k=1，答案则是所有<b>循环移位</b>里，字典序最小的一个。总结，这题是个<b>坑爹智力题</b>。虚假的hard。

<hr>

900 RLE Iterator

题意：给定数组，用<b>游程码</b>编码。比如编码前`[8,8,8,5,5]`，编码后`[3,8,2,5]`。注意，<b>编码方式</b>并不唯一，比如`[3,8]`拆成`[1,8,2,8]`也允许。给定一个<b>编码后</b>的数组作为输入，请实现一个<b>游程码迭代器</b>，可以持续调用`next()`，输出整个数组的值。

难度：medium

解法：RLE本身规则很清晰，照规则实现，在迭代器里保存好<b>相应状态</b>即可。

## 0901 - 1000

901 Online Stock Span

题意：请设计一个数据结构，可以新增当日股价记录，并计算当日股价的<b>“跨度”</b>。跨度指的是，对于当前股价a[i]，求出<b>最大的k</b>，使得a[i]是<b>最近k天内的最大值</b>。

难度：medium

解法：我不知道这个<b>“跨度”</b>是真的金融术语，还是这个算法题发明的？好像到处都搜不到相关概念。朴素解法，当然是直接枚举并计算出每个k，单次代价O(n)，总代价是O(n^2)。优化思路也不难，一句话，<b>尽量复用上一个结果</b>。比如用sp[i]表示当前结果，那么我们对比a[i]和a[i-1]。如果`a[i]<a[i-1]`，sp[i]就是1；如果`a[i]>=a[i-1]`，则继续比较`a[i]和a[i-1-sp[i-1]]（或者出界）`，直到`比a[i]大为止`。这样的话，均摊代价是O(1)，总代价O(n)。看了下以前代码，一个<b>最小栈</b>就搞定了，比这个思路简单。

<hr>

904 Fruit Into Baskets

题意：给定数组，请求出至多包含<b>两种不同值</b>的<b>最长子数组</b>。

难度：medium

解法：原题目非常拗口，但翻译过来就是这个意思。<b>滑动窗口</b>解决。

<hr>

905 Sort Array By Parity

题意：给定数组nums，请将所有<b>偶数</b>移动到<b>奇数</b>左侧。

难度：easy

解法：采用<b>双指针</b>向中间靠拢，一边检查，一边<b>交换</b>即可。

<hr>

908 Smallest Range I

题意：给定数组nums和整数k。你可以对<b>每个位置</b>执行<b>至多1次操作</b>，对这个位置加上一个[-k,k]的数。请问执行操作后，`max(nums)-min(nums)`最小为多少？

难度：easy

解法：`max(max(nums)-min(nums)-2*k,0)`。

<hr>

909 Snakes and Ladders

题意：给定n x n矩阵，从左下，往上左右交替，依次填编号`1~n^2`。已知某些格子的位置有<b>梯子</b>。如果踩到这个格子，则传送到对应位置，传送值用board[i][j]表示，传送值-1表示没有梯子。每次向前移动的步数为1-6。至多到达n^2，此时游戏结束。请求出完成游戏<b>最少的步数</b>？无法完成，则返回-1。

难度：medium

解法：<b>“Boustrophedon”</b>，什么生僻词？查了下意思是<b>左右左右左</b>。这是个来自古希腊的组合词。这个题目描述真的<b>非常晦涩</b>，且加了很多<b>无意义的信息</b>。实际上，这就是一个往前<b>跳跳跳</b>的<b>飞行棋</b>。<b>BFS</b>解决即可。

<hr>

910 Smallest Range II

题意：908的变体。这次加上的值只能是<b>-k或+k</b>。请求出`max(nums)-min(nums)`的最小值。

难度：medium

解法：有点难想。首先<b>排序</b>，然后我将数组nums分为<b>前后两段</b>。前段+k，后段-k。则修改后的数组，最大值可能是`max(a[i]+k,a[n-1]-k)`，最小值可能是`min(a[i+1]-k,a[0]+k)`。然后我枚举这些max-min的差值，求的最小值即可。不过这里面有一个问题，如果我改成<b>前中后三段</b>，分别按照<b>-k、0、+k</b>处理，会不会得到<b>更优解</b>？我没想出完整的证明方法，但<b>从结果看</b>是<b>不会</b>。排序代价`O(nlogn)`，扫一遍是`O(n)`，总代价`O(nlogn)`。

<hr>

911 Online Election

题意：给定两个数组persons、times。表示times[i]时刻persons[i]得了1票。请实现统计函数q(t)，统计在t时刻，<b>票数最多</b>的人是谁。如果有同票数，则返回<b>最近被投票</b>的一个。

难度：medium

解法：这题其实<b>可以变得很复杂</b>，但因为计票数据是<b>一次性给定</b>的，因此这个<b>批处理问题</b>就简单了。我们对数组进行统计，针对每个`(person,time)`投票，我们都统计这个时刻的最高票是谁。至于<b>“最近被投票”</b>这个原则，也容易实现。在比较时，<b>采用>=</b>，而不是>即可。这样，我们会得到一个长度为n的`(top,time)`数组，表示times这些时刻的最高票统计。针对`q(t)`查询的t时刻，在统计结果里，按times做二分查找即可。如果这个题是<b>随时更新、查询</b>的话，问题就难多了。

<hr>

912 Sort an Array

题意：数组排序，对，<b>就是排序</b>。不准用sort函数。尽可能降低空间复杂度。

难度：medium

解法：那就是手写。空间复杂度最低，时间也要快。那这么看，就是<b>堆排序</b>了。显得很刻意，<b>为了这点醋包一桌饺子</b>之类的。之前提交的代码是手写快排，快排的<b>空间复杂度是O(n)</b>的。堆排是O(1)额外空间。对了，网上有无数文章，介绍<b>堆排序、归并排序、快速排序</b>的各种优劣比较和应用场景。堆排序在这三个里面，<b>理论复杂度最好</b>，但<b>实际应用最少</b>，是有科学道理的。

<hr>

914 X of a Kind in a Deck of Cards

题意：给定一把牌deck，请问deck能否分为几组，每组都是同种牌且数量大于1。

难度：easy

解法：水题。

<hr>

915 Partition Array into Disjoint Intervals

题意：给定数组nums，请划分为左右两段，使得<b>左边所有元素<=右边所有元素</b>，且左边<b>尽可能短</b>。

难度：medium

解法：简单。<b>前缀max，后缀min</b>，找到第一个符合`max<=min`的位置即可。

<hr>

916 Word Subsets

题意：对于字符串s和t，如果s的所有不同字符的<b>个数</b>都不超过t，则称<b>s为t的子集</b>。现在给定词表words1和words2。如果words1中某个词w，words2所有词都是<b>w的子集</b>，则称w为<b>“通用”</b>。请找出words1中所有通用的词。

难度：medium

解法：判断子集，既可以用哈希计数，也可以对字符串排序，然后判断子序列。如果<b>sorted(s)是sorted(t)的子序列</b>，则s是t的子集。针对words2中所有词，按照哈希计数，统计出每种字符的max计数。用这个结果，拼出一个<b>最小通用串w_min</b>。然后对words1中每个词w，<b>判断w_min是否为w的子集</b>。是的话，则w是一个通用词。不考虑字符串长度的话，总代价是O(n1+n2)，可接受。

<hr>

917 Reverse Only Letters

题意：给定字符串s，只针对其中所有字母做反转，其他字符保持不动。

难度：easy

解法：双指针，<b>从两边向中间靠拢</b>，遇到字母就做反转。

<hr>

918 Maximum Sum Circular Subarray

题意：给定数组nums，但是是<b>循环数组</b>。请求出最大子数组和。

难度：medium

解法：分两种情况，一种是普通的最大子数组，一种是左右各取一段。对于两段的情况，可以用<b>前缀max+后缀max</b>的方法得到最大结果。

<hr>

919 Complete Binary Tree Inserter

题意：<b>完全二叉树</b>，定义就不讲了。请设计一个完全二叉树，<b>插入新值</b>的功能。

难度：medium

解法：既然是插入，插入后还要保持完全二叉树的特点。因此，你需要以<b>对数代价</b>，定位到<b>插入点</b>。其实比较简单的办法，就是保持一个计数，知道<b>当前有多少节点</b>，这样就不用去<b>试探</b>了。按照当前总数n，判断<b>走到哪层，左还是右</b>。最后插入新节点。

<hr>

921 Minimum Add to Make Parentheses Valid

题意：括号序列，匹配规则不说了。给定一个括号序列s，请在任意位置插入<b>最少的“(”或“)”</b>，使得序列匹配。请返回<b>插入个数</b>。

难度：medium

解法：首先，数据范围暗示你可以用O(n^2)解法。可能会考虑dp[i][j]之类的思路，其实没有必要。这题可以用<b>贪心策略</b>解决，贪心的地方，在于我每次遇到<b>多余的“)”</b>时，没必要多想，直接补足一个“(”即可。因为题目求的是个数，我甚至不需要考虑这个左括号的插入位置。在处理结束后，如果有<b>多余的“(”</b>，则一口气补足右括号。总代价<b>O(n)</b>。

<hr>

922 Sort Array By Parity II

题意：905的变体。给定数组nums，有一半奇数一半偶数。请排序，使得奇数位置是奇数，偶数位置是偶数。

难度：easy

解法：<b>奇偶位置两个指针</b>，从0、1开始前进，遇到不符合条件的，就<b>执行交换</b>。

<hr>

923 3Sum With Multiplicity

题意：15的变体。给定数组nums和值target，请求出`nums[i]+nums[j]+nums[k]=target`的`(i,j,k)`组合个数，其中`i<j<k`。注意，数组值可能有重复。结果模`1e9+7`返回。

难度：medium

解法：如果数据规模吗没什么限制，则考虑用枚举一维，剩下两维用two sum思路。但因为<b>target的范围</b>限制得很小，可以用<b>背包问题</b>的思路来处理。以`n<=3000、target<=300`的范围，<b>什么背包都行</b>。看了下我以前的代码，竟然是<b>搜索</b>做的，看来当年没注意数据范围。

<hr>

925 Long Pressed Name

题意：给定字符串s，有可能其中某些字母<b>被长按，导致重复多次</b>。给定字符串t，请判断t是不是s的<b>“长按”版本</b>。

难度：easy

解法：水题。

<hr>

926 Flip String to Monotone Increasing

题意：给定01字符串s，每次你可以反转一个字符。请问至少多少次反转，才能<b>让所有1都在0之后</b>。

难度：medium

解法：统计<b>前缀1、后缀0</b>的个数。对于每个位置i，求`min(c1[i]+c0[i+1])`即可。原因是，<b>左侧的1</b>都要反成0，<b>右侧的0</b>都要反成1。

<hr>

929 Unique Email Addresses

题意：邮件地址`local@domain`，其中local部分有两个规则。“.”点号忽略；“+”加号之后部分忽略。给定一些emails，请<b>判重</b>，统计唯一值个数。

难度：easy

解法：题目描述非常啰嗦，其实就是按<b>这两条规则</b>进行去重。

<hr>

930 Binary Subarrays With Sum

题意：给定01数组nums和值goal。请求出和为goal的非空子数组个数。

难度：medium

解法：是不是01数组无所谓，统计<b>子数组和的个数</b>，这个用<b>前缀和+哈希计数</b>即可。

<hr>

931 Minimum Falling Path Sum

题意：给定n x n矩阵，你可以从0行任意列出发，每次必须<b>下降一行i+1</b>，且列位置必须取j、j+1、j-1其中一个。请求出<b>最小路径和</b>。

难度：medium

解法：非常典型的DP，不细说了。

<hr>

932 Beautiful Array

题意：请求出一个<b>1~n的排列</b>，使得对于任意位置(i,j)，对于其中所有`i<k<j`，都有`2*a[k]!=a[i]+a[j]`。称这个序列为<b>漂亮序列</b>。

难度：medium

解法：意思就是，不能有任何一个<b>长度为3的等差数列</b>。等差数列，奇偶性一定是`奇奇奇、偶偶偶、奇偶奇、偶奇偶`这几种组合。而且，如果我有一个长度为k的漂亮序列，对它<b>做任何ax+b线性变换</b>，变换后依然是漂亮序列。因此，我们将其`*2-1`，将其`*2`，然后拼到一起。<b>交界处的奇偶性</b>保证了不可能出现等差数列，因此拼出来的序列<b>还是漂亮序列</b>。

<hr>

933 Number of Recent Calls

题意：设计一个数据结构，支持ping(t)函数，表示在t毫秒有一个ping信号。函数返回最近3000毫秒内的ping个数。调用的t参数是<b>严格递增</b>的。

难度：easy

解法：如果调用ping的t参数是无序的，就稍微麻烦点。因为<b>t有序</b>，我们插入的数据是可以直接<b>二分搜索</b>的。二分找到`t-3000`的位置，统计一下个数即可。

<hr>

934 Shortest Bridge

题意：给定n x n的01矩阵表示地形。1表示陆地，0表示水。现在已知有两个小岛，请求出<b>至少</b>需要<b>几块陆地</b>，才能让两个小岛连起来。

难度：medium

解法：以一个小岛的边<b>所有边缘1格子</b>为搜索起点，<b>执行BFS</b>。到达另一个小岛时，则停止搜索。得到的<b>距离</b>，就是<b>这个“桥”的长度</b>。

<hr>

935 Knight Dialer

题意：象棋，<b>马走日</b>。现在给定一个传统的<b>手机9键键盘</b>，左下右下分别是“*”和“#”。你可以从<b>任意数字</b>出发，跳到任意数字。请问能跳出几种n位号码？结果模`1e9+7`返回。

难度：medium

解法：出题人是<b>真的无聊</b>。思路并不难，按照马走日的<b>邻接关系</b>，做<b>线性DP</b>，累加结果即可。

<hr>

937 Reorder Data in Log Files

题意：给定一些特定格式的日志，按特定要求排序。

难度：medium

解法：很具体、繁琐，但没有算法难度的一题。<b>字符串处理</b>，不说了。

<hr>

938 Range Sum of BST

题意：给定二叉搜索树，求出所有在`[low,high]`范围内的节点和。

难度：easy

解法：任意方法遍历，最好用<b>中序遍历</b>。求和即可。

<hr>

939 Minimum Area Rectangle

题意：给定二维平面一些点points，请判断其中能形成的，和<b>xy轴对齐</b>的<b>最小矩形面积</b>。

难度：medium

解法：枚举其中两个<b>对角点</b>，则另两个点可以通过<b>哈希</b>的方式，以O(1)代价判断是否存在。这样，总代价是O(n^2)，可接受。

<hr>

941 Valid Mountain Array

题意：给定数组nums，请判断是否为一个<b>“山数组”</b>。定义以前遇到过，不说了。

难度：easy

解法：<b>先增后降</b>，没有平地。

<hr>

942 DI String Match

题意：给定数组，将<b>相邻元素</b>进行比较，用“D”表示降、“I”表示增。现在给定长度为n-1的DI串，请给出任意一个`0~n-1`的排列，使其满足s串的要求。

难度：easy

解法：这个是easy？感觉需要想一想，然后我<b>突然明白</b>了。比如给定I，我<b>从0开始增</b>；比如给定D，我<b>从n-1开始降</b>。这样的话，我用到的值总是满足这些DI要求的。有点坑人，<b>智力题</b>。

<hr>

944 Delete Columns to Make Sorted

题意：给定n个长度为m的字符串，可以依次排列成一个n x m字符矩阵。请删除其中没有按<b>升序排列的列</b>，统计总共删了多少列。

难度：easy

解法：按题意实现即可。

<hr>

945 Minimum Increment to Make Array Unique

题意：给定数组nums，每次你可以对任意nums[i]执行+1。请问至少多少次操作，能使数组没有重复值。

难度：medium

解法：用贪心策略应该就可以了。先对数组<b>排序</b>，然后统计每个值的重复次数。比如例子`[3,3,4,4,4,6,8]`，变成`[3,4,4,4,4,6,8]`，变成`[3,4,5,5,5,6,8]`，变成`[3,4,5,6,6,6,8]`，诸如此类。当然，这个变换<b>每次的代价是O(1)</b>，我<b>不会真的做n次+1操作</b>。总代价O(n)。

<hr>

946 Validate Stack Sequences

题意：给定一对入栈pushed、出栈popped序列，请判断这个序列是否来自一个<b>合法的栈</b>。

难度：medium

解法：用一个栈来模拟整个过程。比如`[1,2,3,4,5]`，出栈是`[4,5,3,2,1]`。那么对于每个出栈元素，比如4，到达它时，1234一定都在栈中了。如果我<b>要出栈</b>的元素，<b>不是当前栈顶的值</b>，我就<b>继续push</b>。按这个逻辑检查到最后，如果<b>栈能清空，结果就合法</b>。

<hr>

947 Most Stones Removed with Same Row or Column

题意：给定<b>二维平面</b>，有一些石头stones分布在不同的点，不存在重合。如果同x或者同y存在<b>至少2个石头</b>，你可以<b>全部拿掉</b>。请问<b>最多</b>能拿掉多少个石头？

难度：medium

解法：这题不难，但是题目描述很容易<b>令人误会</b>。并不是说你选择某个点(x,y)，然后把<b>同x或同y</b>拿走，也不是说把<b>同x和同y</b>。而是说，你检查任意点`(x,y)`，只要有另一个点`(x,y')`或者`(x',y)`存在，你就可以拿走`(x,y)`。继续这个检查，直到找不到为止。因此，这个模型其实是<b>无向图的连通性</b>。因此，<b>并查集</b>。很容易理解成别的规则，<b>把题目读错</b>。看了下评论区，确实有一堆人读错了。

<hr>

948 Bag of Tokens

题意：开始时，你有power力量，0分数。给定一些卡牌tokens。如果当前力量>tokens[i]，则可以用tokens[i]力量<b>换取</b>1分数；如果当前分数>0，则可以用1分数换取tokens[i]力量。如果每张牌<b>至多用1次</b>，且只能选<b>一种玩法</b>，请问最后能获得的<b>最大分数</b>是多少？

难度：medium

解法：有意思的一题，别想太复杂。比如tokens按升序排列，我当然希望用<b>小token换分数</b>，再用<b>大token换力量</b>。因此有了一个<b>贪心策略</b>。先把tokens排序，让`i=0,j=n-1`。只要<b>力量够用</b>，我就从左边减力量获取分数。<b>力量不够了</b>，我就从右侧用分数补充力量。这样得到的解，一定是<b>最优的</b>。

<hr>

949 Largest Time for Given Digits

题意：给定4个数字，请组成一个有效的<b>“HH:MM”</b>时间，使得这个时间最大。如果没有合法答案，则返回空。

难度：medium

解法：数据空间非常小，<b>直接搜索</b>即可。

<hr>

950 Reveal Cards In Increasing Order

题意：你有一手牌deck，每张都不一样。现在按照<b>拿走、放最后、拿走、放最后</b>的交替顺序，直到拿光所有牌。请给出某个deck的顺序，使得最后拿出的牌，恰好按照升序排列。

难度：medium

解法：这题目我读了两遍才读懂。意思就是每次，按照<b>02468</b>这样，拿走<b>偶数位置</b>的牌。剩下的，再02468，<b>直到全部拿完</b>。既然如此，我们先对deck排序，然后求出这个对应的`0~n-1`排列，再把`sorted(deck)[i]`对应填入，就是最终结果。每拿一轮，长度都是减半的，最终<b>总代价O(n)</b>。

<hr>

951 Flip Equivalent Binary Trees

题意：给定一棵二叉树，对其中某个节点的<b>左右子树做交换</b>，称为<b>1次操作</b>。现在有两棵树t1和t2，请问能否通过一些操作，使得t1和t2完全相同。

难度：medium

解法：<b>递归比较</b>，左=左、右=右，或者左=右、右=左。

<hr>

953 Verifying an Alien Dictionary

题意：给定一个a-z的<b>新顺序</b>。按照这个字符串，请判断一个字符串s中的字母是否按<b>“升序”</b>排列。

难度：easy

解法：按照一一对应关系，变回<b>a-z的默认顺序</b>，检查是否升序即可。

<hr>

954 Array of Doubled Pairs

题意：给定偶数长度的数组nums，请判断能否将其重新排序，使得`nums[2*i]=2*nums[2*i+1]`。

难度：medium

解法：两倍关系，那么正数一组、负数一组、零一组。这三组分别进行配对。从<b>绝对值小</b>的开始遍历，对于每个x，都判断是<b>否存在2x</b>和它配对。这个过程，用一个<b>SortedDict</b>实现最方便。看了下当年的代码，和现在的思路完全一致。

<hr>

955 Delete Columns to Make Sorted II

题意：944的变体。有一个字符串数组strs，所有元素<b>等长</b>。定义一种操作，你可以任选所有串的<b>同一个位置的字符</b>进行删除。经过若干次删除操作后，可以使strs的字符串按升序排列（字典序）。请问<b>最少删除几次</b>？

难度：medium

解法：字典序，从前往后比较。那么我们总是希望<b>越靠前</b>有序，就越好。比如第i列有<b>逆序</b>，那我<b>必须删除</b>这列。比如第i列有序，但存在<b>相等情况</b>，那我得继续判断i+1列，因为<b>后面</b>可能还存在<b>逆序</b>。按这个逻辑，依次判断每列。如果第i列有序，且不存在相等，则可以<b>提前结束</b>。如果共n个串，每个串长度为m，则<b>总代价为O(n*m)</b>。

<hr>

957 Prison Cells After N Days

题意：有8个房间排成一排，用1表示有人、0表示空闲。如果一个格子<b>左右都有人或者都空闲</b>，则第二天这个格子有人。否则，第二天这个格子空闲。按这个变换逻辑，请求出<b>经过n天后</b>，8个格子的状态。

难度：medium

解法：这就是<b>Conway生命游戏</b>的一种类似模型，这个应该叫<b>元胞自动机</b>。对于8位，很显然出题者就是告诉你，用位压缩来直接表示8间房的状态，<b>1个字节</b>就搞定了。然后，建立一个<b>256 x 8bit</b>的转移矩阵即可，算出每种状态的<b>下一步变化</b>。最后，执行<b>n次变化</b>，求出最终结果。状态变化必然是<b>存在循环</b>的，注意处理循环节。

<hr>

958 Check Completeness of a Binary Tree

题意：给定二叉树，判断是否为<b>完全二叉树</b>。

难度：medium

解法：完全二叉树之前遇到很多次了。就是一种<b>结构非常紧凑</b>，除最后一层外，都是满的，最后一层所有叶节点也<b>尽可能靠左</b>的二叉树。判断的话，可以通过检查叶节点的深度，如果<b>符合`[h,h,...,h,h-1,h-1,...,h-1]`</b>这种形式，或者<b>全都是h</b>，就符合条件。还有一种思路，就是<b>层次遍历</b>。如果遇到null节点，表示已经到达<b>边界</b>了，跳过null。继续层次遍历，如果<b>又发现了非null节点</b>，则这棵树<b>不可能是完全二叉树</b>。

<hr>

959 Regions Cut By Slashes

题意：给定一个n x n矩阵，每个格子用“/\ ”三者之一表示，意思是空格、左斜杠、右斜杠。这些斜杠可以连成一个分界线。请判断整个n x n矩阵被划分成了多少个区域。

难度：medium

解法：很神奇的一题，觉得出题人<b>很有脑洞</b>。想了五分钟，毫无思路。然后突然想到了，既然是<b>搜索区域、统计区域个数</b>，这应该是典型的<b>洪泛算法</b>。但是洪泛算法需要有<b>格子或者像素点</b>作为立足点，现在一个格子内<b>被斜杠分成两半</b>，我<b>不能搜1/2格</b>，对吧？答案是，<b>放大</b>。放大镜，朝这个方向想想。剩下不说了。

<hr>

961 N-Repeated Element in Size 2N Array

题意：有一个长度2n的数组nums，有n+1个不同值。其中一个值恰好重复了n遍。请找出这个重复值。

难度：easy

解法：<b>众数</b>的定义，要求出现次数<b>超过一半</b>。这个恰好一半，用众数统计，可能会出错。因此，还是直接<b>哈希计数</b>好了。比如例子`[1,3,1,2,1,5]`，如果你按照众数统计，<b>众数值会不断变化</b>，并且最终落不到1，而是以5结束。这样行不通的。

<hr>

962 Maximum Width Ramp

题意：给定数组nums，如果`i<j`且`nums[i]<=nums[j]`，则称为一个长度为`j-i`的坡。请求出数组nums的<b>最大坡长度</b>，不存在则返回0。

难度：medium

解法：想了十分钟才有思路。我需要针对每个值a[i]，找到最小的j，使得`a[j]<=a[i]`。那么我希望a[i]尽可能大，j尽可能小。我就对数组做一个`(值,下标)`的排序，<b>从最大值开始往回找</b>。比如`[6,0,8,2,1,5]`，排序后是`[(8,2),(6,0),(5,5),(2,3),(1,4),(0,1)]`。令j从0开始，一步步前进。因为a[i]值是逐渐减小的，<b>减到`<a[j]`时，j就可以+1了</b>，因为后面的a[i]更小，不可能再有匹配。按这个思路，扫一次的代价是O(n)。加上排序，<b>总代价O(nlogn)</b>。看了下当年代码，<b>当年没做出来</b>。但这次<b>独立想到</b>的思路，和当年代码一模一样。有进步。

<hr>

963 Minimum Area Rectangle II

题意：939的变体。还是给定一些二维点points，这次允许你组成<b>和xy轴不对齐</b>的矩形。请求出最小矩形面积。

难度：medium

解法：如果矩形可以是倾斜的，计算会更复杂。比如我指定两个对角点p1、p2，其实<b>p3点有无数解</b>，但<b>整点</b>的个数是<b>有限的</b>。求这个整点，还要一点点数学技巧，稍麻烦。因此，我们还是<b>偷个懒</b>，在points至多50个点的情况下，<b>枚举p1、p2、p3</b>好了。总代价O(n^3)。

<hr>

965 Univalued Binary Tree

题意：一个二叉树如果所有节点都是相同值，则称为<b>单值二叉树</b>。请判断给定树是否单值。

难度：easy

解法：水题，而且印象中好像有个<b>一模一样的题</b>，之前出过了？

<hr>

966 Vowel Spellchecker

题意：实现一个拼写检查器。<b>依次</b>按照精确匹配、大小写不敏感、元音修改三种方式进行<b>纠错匹配</b>。如果存在多种匹配，总是返回满足条件的第一个。

难度：medium

解法：没难度，<b>具体而繁琐</b>的一道<b>字符串处理题</b>。

<hr>

967 Numbers With Same Consecutive Differences

题意：给定n和k，请返回所有n位、<b>相邻数位之间都相差k</b>、没有前置0的正整数。

难度：medium

解法：n和k都在10以内，范围很小，可以<b>直接搜索</b>。

<hr>

969 Pancake Sorting

题意：给定数组arr，你可以选择arr[0:k]前k个元素反转，称为<b>一次操作</b>。通过若干次操作，将这个数组排序。现在请给出一个<b>k序列</b>，表示执行的反转操作。如果这个序列<b>能把数组排序</b>，且<b>序列长度小于10*n</b>，则视为通过。

难度：medium

解法：这好像是编程珠玑上，那个<b>著名的“翻煎饼”问题</b>？所幸这个问题不难，如果要求<b>最短的k序列</b>，就有点挑战性。比如<b>值排第n</b>的元素，假设它现在位于a[i]，我们总可以通过`i->1->n`这<b>两次反转</b>，把它翻到n的位置。因此，对于任意位置，至多2次反转可以让它归位。因此，反转次数不超过2n。照这个逻辑，生成一个k序列即可。

<hr>

970 Powerful Integers

题意：给定x、y、bound。请求出在`[1,bound]`范围内，所有符合`x^i+y^j`形式的数。返回结果可任意顺序，不包含重复值。

难度：medium

解法：数据范围至多1e6，在这个范围内，幂的个数不会很多。因此直接<b>枚举+去重</b>即可。

<hr>

971 Flip Binary Tree To Match Preorder Traversal

题意：给定一个二叉树root，和一个前序遍历序列voyage。请选择树中的部分节点，进行左右子树反转，使得修改后的前序遍历，结果符合voyage。请反转最少的节点。返回反转的节点列表。如果无法完成，则返回`[-1]`。

难度：medium

解法：前序的特点是<b>“根左右”</b>，那么不论反转与否，根节点总是得匹配的。如果不匹配，则无法符合要求。从根节点出发，依次按照<b>左右or右左</b>进行<b>子树递归匹配</b>。如果<b>左右失败、右左成功</b>，则需要进行<b>一次交换</b>。注意递归写法，不要搞晕了。

<hr>

973 K Closest Points to Origin

题意：给定二维平面一些点points，请返回里离原点`(0,0)`最近的k个点。

难度：medium

解法：按照`x^2+y^2`直接<b>排序</b>就好了，或者<b>用最大堆选出前k小</b>也可以。

<hr>

974 Subarray Sums Divisible by K

题意：给定数组nums和整数k，请求出<b>子数组和</b>是<b>k的倍数</b>的个数。

难度：medium

解法：<b>前缀和，计数，同余</b>。关键思路就这些了。

<hr>

975 Odd Even Jump

题意：给定数组nums，你可以从任意位置i出发。每次跳一步，且不能倒退，也就是`j>i`。按照1,2,...标号这些跳跃，如果标号奇数，则要求`nums[i]<=nums[j]`；如果标号偶数，则要求`nums[i]>=nums[j]`。如果从某个位置i出发，能<b>到达n-1</b>，则称为一个<b>“好起点”</b>。请统计好起点的个数。

难度：hard

解法：这个题目简直是<b>火星文</b>，不知道在讲什么。简单理解，就是你必须按照<b>增减增减</b>这样跳，跳到最后，且每次<b>必须前进</b>。其实，题目本身不算难，就是题目描述太差了。我们用`dp_dec[i]`表示从i位置，按<b>减增减增</b>方式能否到达n-1；用`dp_inc[i]`表示从i位置，按<b>增减增减</b>方式能否到达n-1。如果存在`j>i`，使得`nums[j]>=nums[i]`，且dp_inc[j]=True，则`dp_dec[i]=True`。那么是否需要用O(n^2)代价枚举？<b>不需要</b>。我只需要记录满足dp_inc为True的后缀max值，以及满足dp_dec为True的后缀min值。毕竟我不关心这个<b>序列长度</b>，我只关心能不能到达n-1位置。这样，总体的DP思路是线性的，代价O(n)。最后所有<b>满足dp_inc为True的值</b>，就是答案。看了下当年的代码，<b>和这个思路完全不同</b>，是用的SortedDict做的。

<hr>

976 Largest Perimeter Triangle

题意：给定数组nums，请从中选出3个值作为边长。如果可以组成三角形，请求出<b>最大周长</b>。

难度：easy

解法：排序，<b>从后往前</b>，依次检查<b>连续3个元素</b>。

<hr>

977 Squares of a Sorted Array

题意：给定一个有序数组，请返回每个元素平方后的结果，要求返回数组也有序。请在<b>O(n)时间</b>完成。

难度：easy

解法：分界线在于正负。平方的单调性是<b>先减后增</b>，在0处取得<b>极小值</b>。因此，对于原数组，我们找出<b>最接近0</b>的位置k，然后<b>双指针i=k、j=k+1向两边走</b>，i左j右。每次比较`a[i]^2`和`a[j]^2`，取两者的较小值即可。

<hr>

978 Longest Turbulent Subarray

题意：给定数组nums，求出最长的<b>波动子数组</b>长度。如果数组中元素按照<b>大小大小</b>或<b>小大小大</b>这样的相邻关系不断变化，则称为<b>波动</b>。相邻关系必须是<b>>或<</b>，不能相等。

难度：medium

解法：因为大小关系是<b>交替变换</b>的，我从a[i]位置开始统计，判断条件不断在<b>“大小”之间切换</b>。遇到<b>不符合</b>时，更新当前最优答案，并开始新一轮的判断。整个过程访问数组一次，O(n)时间，O(1)空间。

<hr>

979 Distribute Coins in Binary Tree

题意：给定二叉树，每个节点值代表<b>硬币个数</b>，数量<b>有多有少</b>。定义一种操作，允许你从某节点，移动1个硬币到相邻节点，上下均可。请问最少多少次操作，能使得每个节点<b>恰好1个硬币</b>。

难度：medium

解法：首先，<b>别想太复杂</b>。我们只考虑两种节点，<b>一种>1，一种=0</b>。对于节点x和y，如果x有多余硬币，我总可以找到一条唯一路径，<b>从x给y送去1个硬币</b>。那么对于所有<b>硬币为0的y</b>，我都找出<b>对应的最近的x</b>就行了。至于实现，个人认为二叉树并不方便，还是转化为<b>无向图，执行BFS</b>更直观。看了下当年的代码，发现<b>比这巧妙多了</b>。直接按照每个节点的<b>净流入、净流出</b>考虑，一个递归搞定了。<b>神奇。</b>

<hr>

980 Unique Paths III

题意：62的变体。给定m x n矩阵，<b>1起点、2终点、0空格、-1墙</b>。请求出能访问到<b>所有非墙格子恰好一次</b>的路径个数。

难度：hard

解法：<b>每个节点</b>恰好一次，<b>Hamilton路径</b>？这个很难，有没有别的思路？想了十分钟，实在没思路。也不想研究Hamilton路径，还是<b>暴力搜</b>吧。

<hr>

981 Time Based Key-Value Store

题意：设计一个KV存储，key为字符串，但是额外支持对于<b>同一key</b>，存储基于<b>不同时间戳</b>的值。检索时，按照`(k，t)`返回符合k键值，且<b>时间戳<=t的最新数据</b>。

难度：medium

解法：KV映射简单，可以用<b>dict</b>作为基础结构。对于时间戳，则可以用一个<b>有序且方便插入</b>的结构。因为题目中调用的时间戳是<b>严格递增</b>的，因此无须使用<b>SortedDict</b>，直接用<b>list</b>就行了。检索时间戳时，用<b>二分搜索</b>找到对应位置，具体做法是<b>bisect_right-1</b>。

<hr>

983 Minimum Cost For Tickets

题意：给定一个数组days，表示你<b>一年内</b>出行的日期。如果有1天、7天、30天三种票，你可以选定特定时间段内（比如7天）多次旅行，通过一张票支付。已知3种票的价格在costs中，请问完成所有旅行，<b>最少的总票价</b>是多少？

难度：medium

解法：这个很容易看出<b>DP的思路</b>。比如我以`dp[i][j]`表示<b>前i次旅行</b>，且第i次使用<b>j类票</b>的总价。j的取值为<b>0、1、2</b>，对应<b>1天、7天、30天</b>的通票。天数是有序的，向前倒推时，可以用二分搜索找到位置。也可以用`local+global`的方式<b>再优化一下</b>，把刚才的dp数据称为`local[i][j]`，则我们定义`global[i]=min(local[i][j])`。关键思路就这些，剩下不讲了。看了下当年代码，当年我似乎想了很久，终归还是想出来了。这次可以<b>一眼看出</b>了。

<hr>

984 String Without AAA or BBB

题意：给定一个由ab字母组成的串s。如果已知有x个“a”、y个“b”，且其中不存在“aaa”、“bbb”。请返回<b>任意一个</b>符合条件的s。

难度：medium

解法：如果只生成一个，那我们考虑x和y的关系。不能是aaa、bbb，那可以是aba、abb、aab或者反过来。总之，是1a2b或者2a1b。因此x和y必须<b>保持在2:1或者1:2之间</b>，才能保证我们生成一个这样的序列。<b>按对称性</b>，不妨假设`x<=y`，也就是<b>a少b多</b>。那么我把y个“b”摆成一条，往其中插入“a”。按照`bb|bb`这样，<b>两个一空</b>。计算<b>有多少空，插入多少“a”</b>。总之，是一些<b>简单的算数</b>。在草稿纸上算清楚，再写代码。

<hr>

985 Sum of Even Numbers After Queries

题意：给定数组nums，针对每次操作`(val,i)`，执行`nums[i]+=val`，然后返回数组中<b>偶数元素的和</b>。

难度：medium

解法：因为+val这个操作<b>只改变一个元素</b>，因此每次更新<b>偶数元素和</b>的代价是O(1)的。具体怎么更新，就不细说了。

<hr>

986 Interval List Intersections

题意：给定两个<b>区间数组</b>l1和l2，已知每个数组内部的区间都升序排列且互不相交，都是`[x,y]`形式的闭区间。请对两个数组<b>求交集</b>，返回结果也按如上形式。

难度：medium

解法：因为输入已经有序了，无须排序。用<b>i、j双指针</b>，采取类似<b>归并排序</b>的思路，往前移动。如果当前`l1[i]`和`l2[j]`已经<b>无交集</b>，则较小的区间前进一位。如果<b>有交集</b>，则把交集加入结果，并让`l1[i]`和`l2[j]`中，<b>y值较小</b>的区间前进一步。总代价O(n1+n2)。注意<b>闭区间</b>，结果中可能存在`[x,x]`这种<b>单点区间</b>。

<hr>

987 Vertical Order Traversal of a Binary Tree

题意：给定二叉树，建立一个<b>坐标系</b>。以根节点为`(0,0)`，向下x+1，左右对应y-1和y+1。按照<b>从左到右、从上到下、先x后y</b>的顺序，遍历二叉树。

难度：hard

解法：用给定的<b>坐标系</b>，遍历二叉树，把对应节点放入对应位置即可。这题的<b>hard</b>并不合适，题目本身定义清晰，且没什么特殊的难点和技巧。

<hr>

988 Smallest String Starting From Leaf

题意：给定二叉树，每个节点代表一个<b>小写字母</b>。请找出一条<b>叶到根</b>的路径，使得组成的字符串<b>字典序最小</b>。

难度：medium

解法：<b>从根到叶</b>进行遍历，得到所有的字符串都进行<b>反转</b>。然后选出其中最小的即可。注意不要弄混概念，s1、s2比较，s1[::-1]、s2[::-1]比较，<b>这是两码事，不相干的</b>。

<hr>

989 Add to Array-Form of Integer

题意：给定大数num和整数k，求num+k的结果。

难度：easy

解法：注意，这个大数表示和<b>常规的方式</b>是反着的，num[0]表示<b>最高位</b>。可以<b>反转一下</b>再做加法。

<hr>

990 Satisfiability of Equality Equations

题意：给定一些形如“x==y”、“x!=y”的方程。其中“x”、“y”可能是不同的<b>单字符变量名</b>。请判断这个方程组<b>是否有解</b>。

难度：medium

解法：其实可以理解为一个图论题，我们将<b>“==”理解成连通</b>，<b>“!=”就是不连通</b>。那么用<b>并查集</b>就可以判断是否存在矛盾。比如<b>xy已经连通了，又说xy不连通</b>，这就是矛盾。并查集是<b>均摊O(1)</b>的，因此，总代价就是处理所有方程一次，<b>O(n)</b>。

<hr>

991 Broken Calculator

题意：给定初始值x，每次你可以<b>x*2或者x-1</b>。请问至少多少次操作，可以把x变成y。

难度：medium

解法：BFS解决。如果想<b>时空上</b>更优化，可以<b>双向BFS</b>。

<hr>

992 Subarrays with K Different Integers

题意：给定数组nums，请求出其中包含<b>k个不同值</b>的子数组的个数。

难度：hard

解法：后面还有一题，和这题<b>一模一样</b>。还是典型的<b>滑动窗口+计数</b>问题。用dict保存当前的`值->个数`记录，一边移动一边更新。唯一的技巧，就是把<b>“恰好k个”</b>转化为<b>“至多k个-至多k-1个”</b>

<hr>

993 Cousins in Binary Tree

题意：给定二叉树，和其中两个值x、y，请判断对应的两节点，是否<b>同深度且不同父节点</b>。

难度：easy

解法：按要求遍历，找到两节点判断即可。

<hr>

994 Rotting Oranges

题意：给定m x n矩阵，其中部分格子有<b>桔子</b>，而且一部分桔子是<b>烂的</b>。每过1时间，烂桔子会把<b>上下左右</b>的<b>新鲜桔子</b>弄坏。请问至少经过多长时间，<b>所有桔子都烂了</b>。如果不会，则返回-1。

难度：medium

解法：把所有<b>烂桔子</b>作为起点，执行<b>BFS</b>。搜索结束时，就知道答案了。如果有新鲜桔子<b>被隔离开</b>，则不会被传染。

<hr>

995 Minimum Number of K Consecutive Bit Flips

题意：给定一个01数组nums，定义一种操作，允许你选择任意<b>连续的k个元素</b>进行<b>反转</b>。请问至少多少次操作，能使得nums中不包含0。如果做不到，则返回-1。

难度：hard

解法：首先考虑下，是否可以<b>贪心</b>？比如我<b>从左往右</b>？我们考虑，比如0~i-1位都是1，i位是0。则我不论怎么做，这个0我<b>必须反转</b>。那么，我没必要<b>把之前的1变回0</b>。因此，<b>反转的起点肯定是i</b>。因此，总体思路<b>是贪心的</b>。在贪心的思路下，这题的唯一难点，就是<b>保证O(n)复杂度</b>了。比如在检查<b>位置i</b>时，如果我执行了反转，那么随后的k-1位，应该把<b>0变1、1变0</b>。因此判断时，需要做好这个变换，<b>负负得正</b>。总体上，有一点点难想，不算很难。

<hr>

997 Find the Town Judge

题意：给定一个n节点<b>有向图</b>，请找出<b>入度n-1、出度为0</b>的节点。

难度：easy

解法：翻译过来就是这个意思。

<hr>

998 Maximum Binary Tree II

题意：654的变体。一棵二叉树，如果每个子树的<b>最大值</b>都位于<b>对应根节点</b>，则称为<b>“最大树”</b>。现在给定<b>最大树ta</b>，如果<b>中序遍历</b>是一个数组a，在<b>a结尾添加一个值val</b>，得到数组b。请以b为中序遍历，生成一个新的最大树tb。

难度：medium

解法：题目本身不算难，数据量也不大，你可以用<b>比较低效的解法</b>。如果数据量大，就必须用<b>RMQ问题</b>的解法了。主要难点，是<b>题目看不懂</b>。思路上很直白，获取中序遍历、append(val)、<b>创建新的二叉树</b>。创建逻辑，在<b>654题</b>已经实现了。

<hr>

999 Available Captures for Rook

题意：国际象棋，白方有<b>一个车</b>，黑方有一些<b>象和卒</b>。请判断车可以攻击<b>几个卒</b>。

难度：easy

解法：具体规则就不说了，按规则判断即可。注意，<b>不能穿过棋子</b>。
